{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _Component = _interopRequireDefault(require(\"../../model/Component.js\"));\n\nvar _helper = require(\"./helper.js\");\n\nvar _model = require(\"../../util/model.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar DataZoomAxisInfo =\n/** @class */\nfunction () {\n  function DataZoomAxisInfo() {\n    this.indexList = [];\n    this.indexMap = [];\n  }\n\n  DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {\n    // Remove duplication.\n    if (!this.indexMap[axisCmptIdx]) {\n      this.indexList.push(axisCmptIdx);\n      this.indexMap[axisCmptIdx] = true;\n    }\n  };\n\n  return DataZoomAxisInfo;\n}();\n\nvar DataZoomModel =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(DataZoomModel, _super);\n\n  function DataZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = DataZoomModel.type;\n    _this._autoThrottle = true;\n    _this._noTarget = true;\n    /**\n     * It is `[rangeModeForMin, rangeModeForMax]`.\n     * The optional values for `rangeMode`:\n     * + `'value'` mode: the axis extent will always be determined by\n     *     `dataZoom.startValue` and `dataZoom.endValue`, despite\n     *     how data like and how `axis.min` and `axis.max` are.\n     * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,\n     *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,\n     *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.\n     *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.\n     *\n     * For example, when users are using dynamic data (update data periodically via `setOption`),\n     * if in `'value`' mode, the window will be kept in a fixed value range despite how\n     * data are appended, while if in `'percent'` mode, whe window range will be changed alone with\n     * the appended data (suppose `axis.min` and `axis.max` are not specified).\n     */\n\n    _this._rangePropMode = ['percent', 'percent'];\n    return _this;\n  }\n\n  DataZoomModel.prototype.init = function (option, parentModel, ecModel) {\n    var inputRawOption = retrieveRawOption(option);\n    /**\n     * Suppose a \"main process\" start at the point that model prepared (that is,\n     * model initialized or merged or method called in `action`).\n     * We should keep the `main process` idempotent, that is, given a set of values\n     * on `option`, we get the same result.\n     *\n     * But sometimes, values on `option` will be updated for providing users\n     * a \"final calculated value\" (`dataZoomProcessor` will do that). Those value\n     * should not be the base/input of the `main process`.\n     *\n     * So in that case we should save and keep the input of the `main process`\n     * separately, called `settledOption`.\n     *\n     * For example, consider the case:\n     * (Step_1) brush zoom the grid by `toolbox.dataZoom`,\n     *     where the original input `option.startValue`, `option.endValue` are earsed by\n     *     calculated value.\n     * (Step)2) click the legend to hide and show a series,\n     *     where the new range is calculated by the earsed `startValue` and `endValue`,\n     *     which brings incorrect result.\n     */\n\n    this.settledOption = inputRawOption;\n    this.mergeDefaultAndTheme(option, ecModel);\n\n    this._doInit(inputRawOption);\n  };\n\n  DataZoomModel.prototype.mergeOption = function (newOption) {\n    var inputRawOption = retrieveRawOption(newOption); //FIX #2591\n\n    (0, _util.merge)(this.option, newOption, true);\n    (0, _util.merge)(this.settledOption, inputRawOption, true);\n\n    this._doInit(inputRawOption);\n  };\n\n  DataZoomModel.prototype._doInit = function (inputRawOption) {\n    var thisOption = this.option;\n\n    this._setDefaultThrottle(inputRawOption);\n\n    this._updateRangeUse(inputRawOption);\n\n    var settledOption = this.settledOption;\n    (0, _util.each)([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = settledOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n\n    this._resetTarget();\n  };\n\n  DataZoomModel.prototype._resetTarget = function () {\n    var optionOrient = this.get('orient', true);\n    var targetAxisIndexMap = this._targetAxisInfoMap = (0, _util.createHashMap)();\n\n    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);\n\n    if (hasAxisSpecified) {\n      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();\n    } else {\n      this._orient = optionOrient || 'horizontal';\n\n      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);\n    }\n\n    this._noTarget = true;\n    targetAxisIndexMap.each(function (axisInfo) {\n      if (axisInfo.indexList.length) {\n        this._noTarget = false;\n      }\n    }, this);\n  };\n\n  DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {\n    var hasAxisSpecified = false;\n    (0, _util.each)(_helper.DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {\n      var refering = this.getReferringComponents((0, _helper.getAxisMainType)(axisDim), _model.MULTIPLE_REFERRING); // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n\n      if (!refering.specified) {\n        return;\n      }\n\n      hasAxisSpecified = true;\n      var axisInfo = new DataZoomAxisInfo();\n      (0, _util.each)(refering.models, function (axisModel) {\n        axisInfo.add(axisModel.componentIndex);\n      });\n      targetAxisIndexMap.set(axisDim, axisInfo);\n    }, this);\n    return hasAxisSpecified;\n  };\n\n  DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {\n    var ecModel = this.ecModel;\n    var needAuto = true; // Find axis that parallel to dataZoom as default.\n\n    if (needAuto) {\n      var axisDim = orient === 'vertical' ? 'y' : 'x';\n      var axisModels = ecModel.findComponents({\n        mainType: axisDim + 'Axis'\n      });\n      setParallelAxis(axisModels, axisDim);\n    } // Find axis that parallel to dataZoom as default.\n\n\n    if (needAuto) {\n      var axisModels = ecModel.findComponents({\n        mainType: 'singleAxis',\n        filter: function (axisModel) {\n          return axisModel.get('orient', true) === orient;\n        }\n      });\n      setParallelAxis(axisModels, 'single');\n    }\n\n    function setParallelAxis(axisModels, axisDim) {\n      // At least use the first parallel axis as the target axis.\n      var axisModel = axisModels[0];\n\n      if (!axisModel) {\n        return;\n      }\n\n      var axisInfo = new DataZoomAxisInfo();\n      axisInfo.add(axisModel.componentIndex);\n      targetAxisIndexMap.set(axisDim, axisInfo);\n      needAuto = false; // Find parallel axes in the same grid.\n\n      if (axisDim === 'x' || axisDim === 'y') {\n        var gridModel_1 = axisModel.getReferringComponents('grid', _model.SINGLE_REFERRING).models[0];\n        gridModel_1 && (0, _util.each)(axisModels, function (axModel) {\n          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', _model.SINGLE_REFERRING).models[0]) {\n            axisInfo.add(axModel.componentIndex);\n          }\n        });\n      }\n    }\n\n    if (needAuto) {\n      // If no parallel axis, find the first category axis as default. (Also consider polar).\n      (0, _util.each)(_helper.DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {\n        if (!needAuto) {\n          return;\n        }\n\n        var axisModels = ecModel.findComponents({\n          mainType: (0, _helper.getAxisMainType)(axisDim),\n          filter: function (axisModel) {\n            return axisModel.get('type', true) === 'category';\n          }\n        });\n\n        if (axisModels[0]) {\n          var axisInfo = new DataZoomAxisInfo();\n          axisInfo.add(axisModels[0].componentIndex);\n          targetAxisIndexMap.set(axisDim, axisInfo);\n          needAuto = false;\n        }\n      }, this);\n    }\n  };\n\n  DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (axisDim) {\n      !dim && (dim = axisDim);\n    }, this);\n    return dim === 'y' ? 'vertical' : 'horizontal';\n  };\n\n  DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (inputRawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  };\n\n  DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {\n    var rangePropMode = this._rangePropMode;\n    var rangeModeInOption = this.get('rangeMode');\n    (0, _util.each)([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      var percentSpecified = inputRawOption[names[0]] != null;\n      var valueSpecified = inputRawOption[names[1]] != null;\n\n      if (percentSpecified && !valueSpecified) {\n        rangePropMode[index] = 'percent';\n      } else if (!percentSpecified && valueSpecified) {\n        rangePropMode[index] = 'value';\n      } else if (rangeModeInOption) {\n        rangePropMode[index] = rangeModeInOption[index];\n      } else if (percentSpecified) {\n        // percentSpecified && valueSpecified\n        rangePropMode[index] = 'percent';\n      } // else remain its original setting.\n\n    });\n  };\n\n  DataZoomModel.prototype.noTarget = function () {\n    return this._noTarget;\n  };\n\n  DataZoomModel.prototype.getFirstTargetAxisModel = function () {\n    var firstAxisModel;\n    this.eachTargetAxis(function (axisDim, axisIndex) {\n      if (firstAxisModel == null) {\n        firstAxisModel = this.ecModel.getComponent((0, _helper.getAxisMainType)(axisDim), axisIndex);\n      }\n    }, this);\n    return firstAxisModel;\n  };\n  /**\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n\n\n  DataZoomModel.prototype.eachTargetAxis = function (callback, context) {\n    this._targetAxisInfoMap.each(function (axisInfo, axisDim) {\n      (0, _util.each)(axisInfo.indexList, function (axisIndex) {\n        callback.call(context, axisDim, axisIndex);\n      });\n    });\n  };\n  /**\n   * @return If not found, return null/undefined.\n   */\n\n\n  DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {\n    var axisModel = this.getAxisModel(axisDim, axisIndex);\n\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    }\n  };\n  /**\n   * @return If not found, return null/undefined.\n   */\n\n\n  DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(axisDim && axisIndex != null);\n    }\n\n    var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n    if (axisInfo && axisInfo.indexMap[axisIndex]) {\n      return this.ecModel.getComponent((0, _helper.getAxisMainType)(axisDim), axisIndex);\n    }\n  };\n  /**\n   * If not specified, set to undefined.\n   */\n\n\n  DataZoomModel.prototype.setRawRange = function (opt) {\n    var thisOption = this.option;\n    var settledOption = this.settledOption;\n    (0, _util.each)([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // Consider the pair <start, startValue>:\n      // If one has value and the other one is `null/undefined`, we both set them\n      // to `settledOption`. This strategy enables the feature to clear the original\n      // value in `settledOption` to `null/undefined`.\n      // But if both of them are `null/undefined`, we do not set them to `settledOption`\n      // and keep `settledOption` with the original value. This strategy enables users to\n      // only set <end or endValue> but not set <start or startValue> when calling\n      // `dispatchAction`.\n      // The pair <end, endValue> is treated in the same way.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];\n        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];\n      }\n    }, this);\n\n    this._updateRangeUse(opt);\n  };\n\n  DataZoomModel.prototype.setCalculatedRange = function (opt) {\n    var option = this.option;\n    (0, _util.each)(['start', 'startValue', 'end', 'endValue'], function (name) {\n      option[name] = opt[name];\n    });\n  };\n\n  DataZoomModel.prototype.getPercentRange = function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  };\n  /**\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @return [startValue, endValue] value can only be '-' or finite number.\n   */\n\n\n  DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {\n    if (axisDim == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();\n    }\n  };\n  /**\n   * @param axisModel If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   */\n\n\n  DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var firstProxy;\n\n    var axisDimList = this._targetAxisInfoMap.keys();\n\n    for (var i = 0; i < axisDimList.length; i++) {\n      var axisDim = axisDimList[i];\n\n      var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n      for (var j = 0; j < axisInfo.indexList.length; j++) {\n        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);\n\n        if (proxy.hostedBy(this)) {\n          return proxy;\n        }\n\n        if (!firstProxy) {\n          firstProxy = proxy;\n        }\n      }\n    } // If no hosted proxy found, still need to return a proxy.\n    // This case always happens in toolbox dataZoom, where axes are all hosted by\n    // other dataZooms.\n\n\n    return firstProxy;\n  };\n\n  DataZoomModel.prototype.getRangePropMode = function () {\n    return this._rangePropMode.slice();\n  };\n\n  DataZoomModel.prototype.getOrient = function () {\n    if (process.env.NODE_ENV !== 'production') {\n      // Should not be called before initialized.\n      (0, _util.assert)(this._orient);\n    }\n\n    return this._orient;\n  };\n\n  DataZoomModel.type = 'dataZoom';\n  DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];\n  DataZoomModel.defaultOption = {\n    // zlevel: 0,\n    z: 4,\n    filterMode: 'filter',\n    start: 0,\n    end: 100\n  };\n  return DataZoomModel;\n}(_Component.default);\n/**\n * Retrieve the those raw params from option, which will be cached separately.\n * becasue they will be overwritten by normalized/calculated values in the main\n * process.\n */\n\n\nfunction retrieveRawOption(option) {\n  var ret = {};\n  (0, _util.each)(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nvar _default = DataZoomModel;\nexports.default = _default;","map":{"version":3,"names":["DataZoomAxisInfo","indexList","indexMap","prototype","add","axisCmptIdx","push","DataZoomModel","_super","__extends","_this","apply","arguments","type","_autoThrottle","_noTarget","_rangePropMode","init","option","parentModel","ecModel","inputRawOption","retrieveRawOption","settledOption","mergeDefaultAndTheme","_doInit","mergeOption","newOption","merge","thisOption","_setDefaultThrottle","_updateRangeUse","each","names","index","_resetTarget","optionOrient","get","targetAxisIndexMap","_targetAxisInfoMap","createHashMap","hasAxisSpecified","_fillSpecifiedTargetAxis","_orient","_makeAutoOrientByTargetAxis","_fillAutoTargetAxisByOrient","axisInfo","length","DATA_ZOOM_AXIS_DIMENSIONS","axisDim","refering","getReferringComponents","getAxisMainType","MULTIPLE_REFERRING","specified","models","axisModel","componentIndex","set","orient","needAuto","axisModels","findComponents","mainType","setParallelAxis","filter","gridModel_1","SINGLE_REFERRING","axModel","dim","eachTargetAxis","hasOwnProperty","globalOption","throttle","animation","animationDurationUpdate","rangePropMode","rangeModeInOption","percentSpecified","valueSpecified","noTarget","getFirstTargetAxisModel","firstAxisModel","axisIndex","getComponent","callback","context","call","getAxisProxy","getAxisModel","__dzAxisProxy","process","env","NODE_ENV","assert","setRawRange","opt","setCalculatedRange","name","getPercentRange","axisProxy","findRepresentativeAxisProxy","getDataPercentWindow","getValueRange","getDataValueWindow","firstProxy","axisDimList","keys","i","j","proxy","hostedBy","getRangePropMode","slice","getOrient","dependencies","defaultOption","z","filterMode","start","end","ComponentModel","ret"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/component/dataZoom/DataZoomModel.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { each, createHashMap, merge, assert } from 'zrender/lib/core/util.js';\nimport ComponentModel from '../../model/Component.js';\nimport { getAxisMainType, DATA_ZOOM_AXIS_DIMENSIONS } from './helper.js';\nimport { MULTIPLE_REFERRING, SINGLE_REFERRING } from '../../util/model.js';\n\nvar DataZoomAxisInfo =\n/** @class */\nfunction () {\n  function DataZoomAxisInfo() {\n    this.indexList = [];\n    this.indexMap = [];\n  }\n\n  DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {\n    // Remove duplication.\n    if (!this.indexMap[axisCmptIdx]) {\n      this.indexList.push(axisCmptIdx);\n      this.indexMap[axisCmptIdx] = true;\n    }\n  };\n\n  return DataZoomAxisInfo;\n}();\n\nvar DataZoomModel =\n/** @class */\nfunction (_super) {\n  __extends(DataZoomModel, _super);\n\n  function DataZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = DataZoomModel.type;\n    _this._autoThrottle = true;\n    _this._noTarget = true;\n    /**\n     * It is `[rangeModeForMin, rangeModeForMax]`.\n     * The optional values for `rangeMode`:\n     * + `'value'` mode: the axis extent will always be determined by\n     *     `dataZoom.startValue` and `dataZoom.endValue`, despite\n     *     how data like and how `axis.min` and `axis.max` are.\n     * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,\n     *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,\n     *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.\n     *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.\n     *\n     * For example, when users are using dynamic data (update data periodically via `setOption`),\n     * if in `'value`' mode, the window will be kept in a fixed value range despite how\n     * data are appended, while if in `'percent'` mode, whe window range will be changed alone with\n     * the appended data (suppose `axis.min` and `axis.max` are not specified).\n     */\n\n    _this._rangePropMode = ['percent', 'percent'];\n    return _this;\n  }\n\n  DataZoomModel.prototype.init = function (option, parentModel, ecModel) {\n    var inputRawOption = retrieveRawOption(option);\n    /**\n     * Suppose a \"main process\" start at the point that model prepared (that is,\n     * model initialized or merged or method called in `action`).\n     * We should keep the `main process` idempotent, that is, given a set of values\n     * on `option`, we get the same result.\n     *\n     * But sometimes, values on `option` will be updated for providing users\n     * a \"final calculated value\" (`dataZoomProcessor` will do that). Those value\n     * should not be the base/input of the `main process`.\n     *\n     * So in that case we should save and keep the input of the `main process`\n     * separately, called `settledOption`.\n     *\n     * For example, consider the case:\n     * (Step_1) brush zoom the grid by `toolbox.dataZoom`,\n     *     where the original input `option.startValue`, `option.endValue` are earsed by\n     *     calculated value.\n     * (Step)2) click the legend to hide and show a series,\n     *     where the new range is calculated by the earsed `startValue` and `endValue`,\n     *     which brings incorrect result.\n     */\n\n    this.settledOption = inputRawOption;\n    this.mergeDefaultAndTheme(option, ecModel);\n\n    this._doInit(inputRawOption);\n  };\n\n  DataZoomModel.prototype.mergeOption = function (newOption) {\n    var inputRawOption = retrieveRawOption(newOption); //FIX #2591\n\n    merge(this.option, newOption, true);\n    merge(this.settledOption, inputRawOption, true);\n\n    this._doInit(inputRawOption);\n  };\n\n  DataZoomModel.prototype._doInit = function (inputRawOption) {\n    var thisOption = this.option;\n\n    this._setDefaultThrottle(inputRawOption);\n\n    this._updateRangeUse(inputRawOption);\n\n    var settledOption = this.settledOption;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = settledOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n\n    this._resetTarget();\n  };\n\n  DataZoomModel.prototype._resetTarget = function () {\n    var optionOrient = this.get('orient', true);\n    var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();\n\n    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);\n\n    if (hasAxisSpecified) {\n      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();\n    } else {\n      this._orient = optionOrient || 'horizontal';\n\n      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);\n    }\n\n    this._noTarget = true;\n    targetAxisIndexMap.each(function (axisInfo) {\n      if (axisInfo.indexList.length) {\n        this._noTarget = false;\n      }\n    }, this);\n  };\n\n  DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {\n    var hasAxisSpecified = false;\n    each(DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {\n      var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING); // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n\n      if (!refering.specified) {\n        return;\n      }\n\n      hasAxisSpecified = true;\n      var axisInfo = new DataZoomAxisInfo();\n      each(refering.models, function (axisModel) {\n        axisInfo.add(axisModel.componentIndex);\n      });\n      targetAxisIndexMap.set(axisDim, axisInfo);\n    }, this);\n    return hasAxisSpecified;\n  };\n\n  DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {\n    var ecModel = this.ecModel;\n    var needAuto = true; // Find axis that parallel to dataZoom as default.\n\n    if (needAuto) {\n      var axisDim = orient === 'vertical' ? 'y' : 'x';\n      var axisModels = ecModel.findComponents({\n        mainType: axisDim + 'Axis'\n      });\n      setParallelAxis(axisModels, axisDim);\n    } // Find axis that parallel to dataZoom as default.\n\n\n    if (needAuto) {\n      var axisModels = ecModel.findComponents({\n        mainType: 'singleAxis',\n        filter: function (axisModel) {\n          return axisModel.get('orient', true) === orient;\n        }\n      });\n      setParallelAxis(axisModels, 'single');\n    }\n\n    function setParallelAxis(axisModels, axisDim) {\n      // At least use the first parallel axis as the target axis.\n      var axisModel = axisModels[0];\n\n      if (!axisModel) {\n        return;\n      }\n\n      var axisInfo = new DataZoomAxisInfo();\n      axisInfo.add(axisModel.componentIndex);\n      targetAxisIndexMap.set(axisDim, axisInfo);\n      needAuto = false; // Find parallel axes in the same grid.\n\n      if (axisDim === 'x' || axisDim === 'y') {\n        var gridModel_1 = axisModel.getReferringComponents('grid', SINGLE_REFERRING).models[0];\n        gridModel_1 && each(axisModels, function (axModel) {\n          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', SINGLE_REFERRING).models[0]) {\n            axisInfo.add(axModel.componentIndex);\n          }\n        });\n      }\n    }\n\n    if (needAuto) {\n      // If no parallel axis, find the first category axis as default. (Also consider polar).\n      each(DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {\n        if (!needAuto) {\n          return;\n        }\n\n        var axisModels = ecModel.findComponents({\n          mainType: getAxisMainType(axisDim),\n          filter: function (axisModel) {\n            return axisModel.get('type', true) === 'category';\n          }\n        });\n\n        if (axisModels[0]) {\n          var axisInfo = new DataZoomAxisInfo();\n          axisInfo.add(axisModels[0].componentIndex);\n          targetAxisIndexMap.set(axisDim, axisInfo);\n          needAuto = false;\n        }\n      }, this);\n    }\n  };\n\n  DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (axisDim) {\n      !dim && (dim = axisDim);\n    }, this);\n    return dim === 'y' ? 'vertical' : 'horizontal';\n  };\n\n  DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (inputRawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  };\n\n  DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {\n    var rangePropMode = this._rangePropMode;\n    var rangeModeInOption = this.get('rangeMode');\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      var percentSpecified = inputRawOption[names[0]] != null;\n      var valueSpecified = inputRawOption[names[1]] != null;\n\n      if (percentSpecified && !valueSpecified) {\n        rangePropMode[index] = 'percent';\n      } else if (!percentSpecified && valueSpecified) {\n        rangePropMode[index] = 'value';\n      } else if (rangeModeInOption) {\n        rangePropMode[index] = rangeModeInOption[index];\n      } else if (percentSpecified) {\n        // percentSpecified && valueSpecified\n        rangePropMode[index] = 'percent';\n      } // else remain its original setting.\n\n    });\n  };\n\n  DataZoomModel.prototype.noTarget = function () {\n    return this._noTarget;\n  };\n\n  DataZoomModel.prototype.getFirstTargetAxisModel = function () {\n    var firstAxisModel;\n    this.eachTargetAxis(function (axisDim, axisIndex) {\n      if (firstAxisModel == null) {\n        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n      }\n    }, this);\n    return firstAxisModel;\n  };\n  /**\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n\n\n  DataZoomModel.prototype.eachTargetAxis = function (callback, context) {\n    this._targetAxisInfoMap.each(function (axisInfo, axisDim) {\n      each(axisInfo.indexList, function (axisIndex) {\n        callback.call(context, axisDim, axisIndex);\n      });\n    });\n  };\n  /**\n   * @return If not found, return null/undefined.\n   */\n\n\n  DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {\n    var axisModel = this.getAxisModel(axisDim, axisIndex);\n\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    }\n  };\n  /**\n   * @return If not found, return null/undefined.\n   */\n\n\n  DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(axisDim && axisIndex != null);\n    }\n\n    var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n    if (axisInfo && axisInfo.indexMap[axisIndex]) {\n      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n    }\n  };\n  /**\n   * If not specified, set to undefined.\n   */\n\n\n  DataZoomModel.prototype.setRawRange = function (opt) {\n    var thisOption = this.option;\n    var settledOption = this.settledOption;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // Consider the pair <start, startValue>:\n      // If one has value and the other one is `null/undefined`, we both set them\n      // to `settledOption`. This strategy enables the feature to clear the original\n      // value in `settledOption` to `null/undefined`.\n      // But if both of them are `null/undefined`, we do not set them to `settledOption`\n      // and keep `settledOption` with the original value. This strategy enables users to\n      // only set <end or endValue> but not set <start or startValue> when calling\n      // `dispatchAction`.\n      // The pair <end, endValue> is treated in the same way.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];\n        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];\n      }\n    }, this);\n\n    this._updateRangeUse(opt);\n  };\n\n  DataZoomModel.prototype.setCalculatedRange = function (opt) {\n    var option = this.option;\n    each(['start', 'startValue', 'end', 'endValue'], function (name) {\n      option[name] = opt[name];\n    });\n  };\n\n  DataZoomModel.prototype.getPercentRange = function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  };\n  /**\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @return [startValue, endValue] value can only be '-' or finite number.\n   */\n\n\n  DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {\n    if (axisDim == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();\n    }\n  };\n  /**\n   * @param axisModel If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   */\n\n\n  DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var firstProxy;\n\n    var axisDimList = this._targetAxisInfoMap.keys();\n\n    for (var i = 0; i < axisDimList.length; i++) {\n      var axisDim = axisDimList[i];\n\n      var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n      for (var j = 0; j < axisInfo.indexList.length; j++) {\n        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);\n\n        if (proxy.hostedBy(this)) {\n          return proxy;\n        }\n\n        if (!firstProxy) {\n          firstProxy = proxy;\n        }\n      }\n    } // If no hosted proxy found, still need to return a proxy.\n    // This case always happens in toolbox dataZoom, where axes are all hosted by\n    // other dataZooms.\n\n\n    return firstProxy;\n  };\n\n  DataZoomModel.prototype.getRangePropMode = function () {\n    return this._rangePropMode.slice();\n  };\n\n  DataZoomModel.prototype.getOrient = function () {\n    if (process.env.NODE_ENV !== 'production') {\n      // Should not be called before initialized.\n      assert(this._orient);\n    }\n\n    return this._orient;\n  };\n\n  DataZoomModel.type = 'dataZoom';\n  DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];\n  DataZoomModel.defaultOption = {\n    // zlevel: 0,\n    z: 4,\n    filterMode: 'filter',\n    start: 0,\n    end: 100\n  };\n  return DataZoomModel;\n}(ComponentModel);\n/**\n * Retrieve the those raw params from option, which will be cached separately.\n * becasue they will be overwritten by normalized/calculated values in the main\n * process.\n */\n\n\nfunction retrieveRawOption(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nexport default DataZoomModel;"],"mappings":"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"},"metadata":{},"sourceType":"script"}