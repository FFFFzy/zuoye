{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sankeyLayout;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar layout = _interopRequireWildcard(require(\"../../util/layout.js\"));\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar _model = require(\"../../util/model.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction sankeyLayout(ecModel, api) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = zrUtil.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    var orient = seriesModel.get('orient');\n    var nodeAlign = seriesModel.get('nodeAlign');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);\n  });\n}\n/**\n * Get the layout position of the whole view\n */\n\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {\n  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);\n  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);\n  computeEdgeDepths(nodes, orient);\n}\n/**\n * Compute the value of each node by summing the associated edge's value\n */\n\n\nfunction computeNodeValues(nodes) {\n  zrUtil.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var nodeRawValue = node.getValue() || 0;\n    var value = Math.max(value1, value2, nodeRawValue);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\n * Compute the x-position for each node.\n *\n * Here we use Kahn algorithm to detect cycle when we traverse\n * the node to computer the initial x position.\n */\n\n\nfunction computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {\n  // Used to mark whether the edge is deleted. if it is deleted,\n  // the value is 0, otherwise it is 1.\n  var remainEdges = []; // Storage each node's indegree.\n\n  var indegreeArr = []; //Used to storage the node with indegree is equal to 0.\n\n  var zeroIndegrees = [];\n  var nextTargetNode = [];\n  var x = 0; // let kx = 0;\n\n  for (var i = 0; i < edges.length; i++) {\n    remainEdges[i] = 1;\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    indegreeArr[i] = nodes[i].inEdges.length;\n\n    if (indegreeArr[i] === 0) {\n      zeroIndegrees.push(nodes[i]);\n    }\n  }\n\n  var maxNodeDepth = -1; // Traversing nodes using topological sorting to calculate the\n  // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')\n  // position of the nodes.\n\n  while (zeroIndegrees.length) {\n    for (var idx = 0; idx < zeroIndegrees.length; idx++) {\n      var node = zeroIndegrees[idx];\n      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n      var isItemDepth = item.depth != null && item.depth >= 0;\n\n      if (isItemDepth && item.depth > maxNodeDepth) {\n        maxNodeDepth = item.depth;\n      }\n\n      node.setLayout({\n        depth: isItemDepth ? item.depth : x\n      }, true);\n      orient === 'vertical' ? node.setLayout({\n        dy: nodeWidth\n      }, true) : node.setLayout({\n        dx: nodeWidth\n      }, true);\n\n      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {\n        var edge = node.outEdges[edgeIdx];\n        var indexEdge = edges.indexOf(edge);\n        remainEdges[indexEdge] = 0;\n        var targetNode = edge.node2;\n        var nodeIndex = nodes.indexOf(targetNode);\n\n        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {\n          nextTargetNode.push(targetNode);\n        }\n      }\n    }\n\n    ++x;\n    zeroIndegrees = nextTargetNode;\n    nextTargetNode = [];\n  }\n\n  for (var i = 0; i < remainEdges.length; i++) {\n    if (remainEdges[i] === 1) {\n      throw new Error('Sankey is a DAG, the original data has cycle!');\n    }\n  }\n\n  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;\n\n  if (nodeAlign && nodeAlign !== 'left') {\n    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);\n  }\n\n  var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;\n  scaleNodeBreadths(nodes, kx, orient);\n}\n\nfunction isNodeDepth(node) {\n  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n  return item.depth != null && item.depth >= 0;\n}\n\nfunction adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {\n  if (nodeAlign === 'right') {\n    var nextSourceNode = [];\n    var remainNodes = nodes;\n    var nodeHeight = 0;\n\n    while (remainNodes.length) {\n      for (var i = 0; i < remainNodes.length; i++) {\n        var node = remainNodes[i];\n        node.setLayout({\n          skNodeHeight: nodeHeight\n        }, true);\n\n        for (var j = 0; j < node.inEdges.length; j++) {\n          var edge = node.inEdges[j];\n\n          if (nextSourceNode.indexOf(edge.node1) < 0) {\n            nextSourceNode.push(edge.node1);\n          }\n        }\n      }\n\n      remainNodes = nextSourceNode;\n      nextSourceNode = [];\n      ++nodeHeight;\n    }\n\n    zrUtil.each(nodes, function (node) {\n      if (!isNodeDepth(node)) {\n        node.setLayout({\n          depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)\n        }, true);\n      }\n    });\n  } else if (nodeAlign === 'justify') {\n    moveSinksRight(nodes, maxDepth);\n  }\n}\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param nodes.  node of sankey view.\n * @param maxDepth.  use to assign to node without outEdges as x-position.\n */\n\n\nfunction moveSinksRight(nodes, maxDepth) {\n  zrUtil.each(nodes, function (node) {\n    if (!isNodeDepth(node) && !node.outEdges.length) {\n      node.setLayout({\n        depth: maxDepth\n      }, true);\n    }\n  });\n}\n/**\n * Scale node x-position to the width\n *\n * @param nodes  node of sankey view\n * @param kx   multiple used to scale nodes\n */\n\n\nfunction scaleNodeBreadths(nodes, kx, orient) {\n  zrUtil.each(nodes, function (node) {\n    var nodeDepth = node.getLayout().depth * kx;\n    orient === 'vertical' ? node.setLayout({\n      y: nodeDepth\n    }, true) : node.setLayout({\n      x: nodeDepth\n    }, true);\n  });\n}\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param nodes  node of sankey view\n * @param edges  edge of sankey view\n * @param height  the whole height of the area to draw the view\n * @param nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param iterations  the number of iterations for the algorithm\n */\n\n\nfunction computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {\n  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);\n  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);\n  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n    relaxLeftToRight(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  }\n}\n\nfunction prepareNodesByBreadth(nodes, orient) {\n  var nodesByBreadth = [];\n  var keyAttr = orient === 'vertical' ? 'y' : 'x';\n  var groupResult = (0, _model.groupData)(nodes, function (node) {\n    return node.getLayout()[keyAttr];\n  });\n  groupResult.keys.sort(function (a, b) {\n    return a - b;\n  });\n  zrUtil.each(groupResult.keys, function (key) {\n    nodesByBreadth.push(groupResult.buckets.get(key));\n  });\n  return nodesByBreadth;\n}\n/**\n * Compute the original y-position for each node\n */\n\n\nfunction initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {\n  var minKy = Infinity;\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    zrUtil.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;\n\n    if (ky < minKy) {\n      minKy = ky;\n    }\n  });\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node, i) {\n      var nodeDy = node.getLayout().value * minKy;\n\n      if (orient === 'vertical') {\n        node.setLayout({\n          x: i\n        }, true);\n        node.setLayout({\n          dx: nodeDy\n        }, true);\n      } else {\n        node.setLayout({\n          y: i\n        }, true);\n        node.setLayout({\n          dy: nodeDy\n        }, true);\n      }\n    });\n  });\n  zrUtil.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * minKy;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\n * Resolve the collision of initialized depth (y-position)\n */\n\n\nfunction resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    nodes.sort(function (a, b) {\n      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];\n    });\n    var nodeX;\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';\n\n    for (var i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout()[keyAttr];\n\n      if (dy > 0) {\n        nodeX = node.getLayout()[keyAttr] + dy;\n        orient === 'vertical' ? node.setLayout({\n          x: nodeX\n        }, true) : node.setLayout({\n          y: nodeX\n        }, true);\n      }\n\n      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;\n    }\n\n    var viewWidth = orient === 'vertical' ? width : height; // If the bottommost node goes outside the bounds, push it back up\n\n    dy = y0 - nodeGap - viewWidth;\n\n    if (dy > 0) {\n      nodeX = node.getLayout()[keyAttr] - dy;\n      orient === 'vertical' ? node.setLayout({\n        x: nodeX\n      }, true) : node.setLayout({\n        y: nodeX\n      }, true);\n      y0 = nodeX;\n\n      for (var i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;\n\n        if (dy > 0) {\n          nodeX = node.getLayout()[keyAttr] - dy;\n          orient === 'vertical' ? node.setLayout({\n            x: nodeX\n          }, true) : node.setLayout({\n            y: nodeX\n          }, true);\n        }\n\n        y0 = node.getLayout()[keyAttr];\n      }\n    }\n  });\n}\n/**\n * Change the y-position of the nodes, except most the right side nodes\n * @param nodesByBreadth\n * @param alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxRightToLeft(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);\n\n        if (isNaN(y)) {\n          var len = node.outEdges.length;\n          y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;\n        }\n\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n\nfunction weightedTarget(edge, orient) {\n  return center(edge.node2, orient) * edge.getValue();\n}\n\nfunction centerTarget(edge, orient) {\n  return center(edge.node2, orient);\n}\n\nfunction weightedSource(edge, orient) {\n  return center(edge.node1, orient) * edge.getValue();\n}\n\nfunction centerSource(edge, orient) {\n  return center(edge.node1, orient);\n}\n\nfunction center(node, orient) {\n  return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;\n}\n\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\n\nfunction sum(array, cb, orient) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n\n  while (++i < len) {\n    var value = +cb(array[i], orient);\n\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n\n  return sum;\n}\n/**\n * Change the y-position of the nodes, except most the left side nodes\n */\n\n\nfunction relaxLeftToRight(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);\n\n        if (isNaN(y)) {\n          var len = node.inEdges.length;\n          y = len ? sum(node.inEdges, centerSource, orient) / len : 0;\n        }\n\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n/**\n * Compute the depth(y-position) of each edge\n */\n\n\nfunction computeEdgeDepths(nodes, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodes, function (node) {\n    node.outEdges.sort(function (a, b) {\n      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];\n    });\n    node.inEdges.sort(function (a, b) {\n      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];\n    });\n  });\n  zrUtil.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    zrUtil.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    zrUtil.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}","map":{"version":3,"names":["sankeyLayout","ecModel","api","eachSeriesByType","seriesModel","nodeWidth","get","nodeGap","layoutInfo","getViewRect","width","height","graph","getGraph","nodes","edges","computeNodeValues","filteredNodes","zrUtil","filter","node","getLayout","value","iterations","length","orient","nodeAlign","layoutSankey","layout","getLayoutRect","getBoxLayoutParams","getWidth","getHeight","computeNodeBreadths","computeNodeDepths","computeEdgeDepths","each","value1","sum","outEdges","getEdgeValue","value2","inEdges","nodeRawValue","getValue","Math","max","setLayout","remainEdges","indegreeArr","zeroIndegrees","nextTargetNode","x","i","push","maxNodeDepth","idx","item","hostGraph","data","getRawDataItem","dataIndex","isItemDepth","depth","dy","dx","edgeIdx","edge","indexEdge","indexOf","targetNode","node2","nodeIndex","Error","maxDepth","adjustNodeWithNodeAlign","kx","scaleNodeBreadths","isNodeDepth","nextSourceNode","remainNodes","nodeHeight","skNodeHeight","j","node1","moveSinksRight","nodeDepth","y","nodesByBreadth","prepareNodesByBreadth","initializeNodeDepth","resolveCollisions","alpha","relaxRightToLeft","relaxLeftToRight","keyAttr","groupResult","groupData","keys","sort","a","b","key","buckets","minKy","Infinity","n","ky","nodeDy","edgeDy","nodeX","y0","nodeDyAttr","viewWidth","slice","reverse","weightedTarget","isNaN","len","centerTarget","center","nodeY","weightedSource","centerSource","array","cb","sy","ty"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/chart/sankey/sankeyLayout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as layout from '../../util/layout.js';\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport { groupData } from '../../util/model.js';\nexport default function sankeyLayout(ecModel, api) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = zrUtil.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    var orient = seriesModel.get('orient');\n    var nodeAlign = seriesModel.get('nodeAlign');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);\n  });\n}\n/**\n * Get the layout position of the whole view\n */\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {\n  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);\n  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);\n  computeEdgeDepths(nodes, orient);\n}\n/**\n * Compute the value of each node by summing the associated edge's value\n */\n\n\nfunction computeNodeValues(nodes) {\n  zrUtil.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var nodeRawValue = node.getValue() || 0;\n    var value = Math.max(value1, value2, nodeRawValue);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\n * Compute the x-position for each node.\n *\n * Here we use Kahn algorithm to detect cycle when we traverse\n * the node to computer the initial x position.\n */\n\n\nfunction computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {\n  // Used to mark whether the edge is deleted. if it is deleted,\n  // the value is 0, otherwise it is 1.\n  var remainEdges = []; // Storage each node's indegree.\n\n  var indegreeArr = []; //Used to storage the node with indegree is equal to 0.\n\n  var zeroIndegrees = [];\n  var nextTargetNode = [];\n  var x = 0; // let kx = 0;\n\n  for (var i = 0; i < edges.length; i++) {\n    remainEdges[i] = 1;\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    indegreeArr[i] = nodes[i].inEdges.length;\n\n    if (indegreeArr[i] === 0) {\n      zeroIndegrees.push(nodes[i]);\n    }\n  }\n\n  var maxNodeDepth = -1; // Traversing nodes using topological sorting to calculate the\n  // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')\n  // position of the nodes.\n\n  while (zeroIndegrees.length) {\n    for (var idx = 0; idx < zeroIndegrees.length; idx++) {\n      var node = zeroIndegrees[idx];\n      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n      var isItemDepth = item.depth != null && item.depth >= 0;\n\n      if (isItemDepth && item.depth > maxNodeDepth) {\n        maxNodeDepth = item.depth;\n      }\n\n      node.setLayout({\n        depth: isItemDepth ? item.depth : x\n      }, true);\n      orient === 'vertical' ? node.setLayout({\n        dy: nodeWidth\n      }, true) : node.setLayout({\n        dx: nodeWidth\n      }, true);\n\n      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {\n        var edge = node.outEdges[edgeIdx];\n        var indexEdge = edges.indexOf(edge);\n        remainEdges[indexEdge] = 0;\n        var targetNode = edge.node2;\n        var nodeIndex = nodes.indexOf(targetNode);\n\n        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {\n          nextTargetNode.push(targetNode);\n        }\n      }\n    }\n\n    ++x;\n    zeroIndegrees = nextTargetNode;\n    nextTargetNode = [];\n  }\n\n  for (var i = 0; i < remainEdges.length; i++) {\n    if (remainEdges[i] === 1) {\n      throw new Error('Sankey is a DAG, the original data has cycle!');\n    }\n  }\n\n  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;\n\n  if (nodeAlign && nodeAlign !== 'left') {\n    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);\n  }\n\n  var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;\n  scaleNodeBreadths(nodes, kx, orient);\n}\n\nfunction isNodeDepth(node) {\n  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n  return item.depth != null && item.depth >= 0;\n}\n\nfunction adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {\n  if (nodeAlign === 'right') {\n    var nextSourceNode = [];\n    var remainNodes = nodes;\n    var nodeHeight = 0;\n\n    while (remainNodes.length) {\n      for (var i = 0; i < remainNodes.length; i++) {\n        var node = remainNodes[i];\n        node.setLayout({\n          skNodeHeight: nodeHeight\n        }, true);\n\n        for (var j = 0; j < node.inEdges.length; j++) {\n          var edge = node.inEdges[j];\n\n          if (nextSourceNode.indexOf(edge.node1) < 0) {\n            nextSourceNode.push(edge.node1);\n          }\n        }\n      }\n\n      remainNodes = nextSourceNode;\n      nextSourceNode = [];\n      ++nodeHeight;\n    }\n\n    zrUtil.each(nodes, function (node) {\n      if (!isNodeDepth(node)) {\n        node.setLayout({\n          depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)\n        }, true);\n      }\n    });\n  } else if (nodeAlign === 'justify') {\n    moveSinksRight(nodes, maxDepth);\n  }\n}\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param nodes.  node of sankey view.\n * @param maxDepth.  use to assign to node without outEdges as x-position.\n */\n\n\nfunction moveSinksRight(nodes, maxDepth) {\n  zrUtil.each(nodes, function (node) {\n    if (!isNodeDepth(node) && !node.outEdges.length) {\n      node.setLayout({\n        depth: maxDepth\n      }, true);\n    }\n  });\n}\n/**\n * Scale node x-position to the width\n *\n * @param nodes  node of sankey view\n * @param kx   multiple used to scale nodes\n */\n\n\nfunction scaleNodeBreadths(nodes, kx, orient) {\n  zrUtil.each(nodes, function (node) {\n    var nodeDepth = node.getLayout().depth * kx;\n    orient === 'vertical' ? node.setLayout({\n      y: nodeDepth\n    }, true) : node.setLayout({\n      x: nodeDepth\n    }, true);\n  });\n}\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param nodes  node of sankey view\n * @param edges  edge of sankey view\n * @param height  the whole height of the area to draw the view\n * @param nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param iterations  the number of iterations for the algorithm\n */\n\n\nfunction computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {\n  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);\n  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);\n  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n    relaxLeftToRight(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  }\n}\n\nfunction prepareNodesByBreadth(nodes, orient) {\n  var nodesByBreadth = [];\n  var keyAttr = orient === 'vertical' ? 'y' : 'x';\n  var groupResult = groupData(nodes, function (node) {\n    return node.getLayout()[keyAttr];\n  });\n  groupResult.keys.sort(function (a, b) {\n    return a - b;\n  });\n  zrUtil.each(groupResult.keys, function (key) {\n    nodesByBreadth.push(groupResult.buckets.get(key));\n  });\n  return nodesByBreadth;\n}\n/**\n * Compute the original y-position for each node\n */\n\n\nfunction initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {\n  var minKy = Infinity;\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    zrUtil.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;\n\n    if (ky < minKy) {\n      minKy = ky;\n    }\n  });\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node, i) {\n      var nodeDy = node.getLayout().value * minKy;\n\n      if (orient === 'vertical') {\n        node.setLayout({\n          x: i\n        }, true);\n        node.setLayout({\n          dx: nodeDy\n        }, true);\n      } else {\n        node.setLayout({\n          y: i\n        }, true);\n        node.setLayout({\n          dy: nodeDy\n        }, true);\n      }\n    });\n  });\n  zrUtil.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * minKy;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\n * Resolve the collision of initialized depth (y-position)\n */\n\n\nfunction resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    nodes.sort(function (a, b) {\n      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];\n    });\n    var nodeX;\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';\n\n    for (var i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout()[keyAttr];\n\n      if (dy > 0) {\n        nodeX = node.getLayout()[keyAttr] + dy;\n        orient === 'vertical' ? node.setLayout({\n          x: nodeX\n        }, true) : node.setLayout({\n          y: nodeX\n        }, true);\n      }\n\n      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;\n    }\n\n    var viewWidth = orient === 'vertical' ? width : height; // If the bottommost node goes outside the bounds, push it back up\n\n    dy = y0 - nodeGap - viewWidth;\n\n    if (dy > 0) {\n      nodeX = node.getLayout()[keyAttr] - dy;\n      orient === 'vertical' ? node.setLayout({\n        x: nodeX\n      }, true) : node.setLayout({\n        y: nodeX\n      }, true);\n      y0 = nodeX;\n\n      for (var i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;\n\n        if (dy > 0) {\n          nodeX = node.getLayout()[keyAttr] - dy;\n          orient === 'vertical' ? node.setLayout({\n            x: nodeX\n          }, true) : node.setLayout({\n            y: nodeX\n          }, true);\n        }\n\n        y0 = node.getLayout()[keyAttr];\n      }\n    }\n  });\n}\n/**\n * Change the y-position of the nodes, except most the right side nodes\n * @param nodesByBreadth\n * @param alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxRightToLeft(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);\n\n        if (isNaN(y)) {\n          var len = node.outEdges.length;\n          y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;\n        }\n\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n\nfunction weightedTarget(edge, orient) {\n  return center(edge.node2, orient) * edge.getValue();\n}\n\nfunction centerTarget(edge, orient) {\n  return center(edge.node2, orient);\n}\n\nfunction weightedSource(edge, orient) {\n  return center(edge.node1, orient) * edge.getValue();\n}\n\nfunction centerSource(edge, orient) {\n  return center(edge.node1, orient);\n}\n\nfunction center(node, orient) {\n  return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;\n}\n\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\n\nfunction sum(array, cb, orient) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n\n  while (++i < len) {\n    var value = +cb(array[i], orient);\n\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n\n  return sum;\n}\n/**\n * Change the y-position of the nodes, except most the left side nodes\n */\n\n\nfunction relaxLeftToRight(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);\n\n        if (isNaN(y)) {\n          var len = node.inEdges.length;\n          y = len ? sum(node.inEdges, centerSource, orient) / len : 0;\n        }\n\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n/**\n * Compute the depth(y-position) of each edge\n */\n\n\nfunction computeEdgeDepths(nodes, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodes, function (node) {\n    node.outEdges.sort(function (a, b) {\n      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];\n    });\n    node.inEdges.sort(function (a, b) {\n      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];\n    });\n  });\n  zrUtil.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    zrUtil.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    zrUtil.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}