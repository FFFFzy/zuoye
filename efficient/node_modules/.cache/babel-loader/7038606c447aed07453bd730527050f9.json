{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _BoundingRect = _interopRequireDefault(require(\"zrender/lib/core/BoundingRect.js\"));\n\nvar matrix = _interopRequireWildcard(require(\"zrender/lib/core/matrix.js\"));\n\nvar graphic = _interopRequireWildcard(require(\"../../util/graphic.js\"));\n\nvar _labelStyle = require(\"../../label/labelStyle.js\");\n\nvar layout = _interopRequireWildcard(require(\"../../util/layout.js\"));\n\nvar _TimelineView = _interopRequireDefault(require(\"./TimelineView.js\"));\n\nvar _TimelineAxis = _interopRequireDefault(require(\"./TimelineAxis.js\"));\n\nvar _symbol = require(\"../../util/symbol.js\");\n\nvar numberUtil = _interopRequireWildcard(require(\"../../util/number.js\"));\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _Ordinal = _interopRequireDefault(require(\"../../scale/Ordinal.js\"));\n\nvar _Time = _interopRequireDefault(require(\"../../scale/Time.js\"));\n\nvar _Interval = _interopRequireDefault(require(\"../../scale/Interval.js\"));\n\nvar _text = require(\"zrender/lib/contain/text.js\");\n\nvar _model = require(\"../../util/model.js\");\n\nvar _innerStore = require(\"../../util/innerStore.js\");\n\nvar _states = require(\"../../util/states.js\");\n\nvar _tooltipMarkup = require(\"../tooltip/tooltipMarkup.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\nvar labelDataIndexStore = (0, _model.makeInner)();\n\nvar SliderTimelineView =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(SliderTimelineView, _super);\n\n  function SliderTimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SliderTimelineView.type;\n    return _this;\n  }\n\n  SliderTimelineView.prototype.init = function (ecModel, api) {\n    this.api = api;\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {\n    this.model = timelineModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    this.group.removeAll();\n\n    if (timelineModel.get('show', true)) {\n      var layoutInfo_1 = this._layout(timelineModel, api);\n\n      var mainGroup_1 = this._createGroup('_mainGroup');\n\n      var labelGroup = this._createGroup('_labelGroup');\n\n      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);\n\n      timelineModel.formatTooltip = function (dataIndex) {\n        var name = axis_1.scale.getLabel({\n          value: dataIndex\n        });\n        return (0, _tooltipMarkup.createTooltipMarkup)('nameValue', {\n          noName: true,\n          value: name\n        });\n      };\n\n      (0, _util.each)(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {\n        this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);\n      }, this);\n\n      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);\n\n      this._position(layoutInfo_1, timelineModel);\n    }\n\n    this._doPlayStop();\n\n    this._updateTicksStatus();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.remove = function () {\n    this._clearTimer();\n\n    this.group.removeAll();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.dispose = function () {\n    this._clearTimer();\n  };\n\n  SliderTimelineView.prototype._layout = function (timelineModel, api) {\n    var labelPosOpt = timelineModel.get(['label', 'position']);\n    var orient = timelineModel.get('orient');\n    var viewRect = getViewRect(timelineModel, api);\n    var parsedLabelPos; // Auto label offset.\n\n    if (labelPosOpt == null || labelPosOpt === 'auto') {\n      parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';\n    } else if ((0, _util.isString)(labelPosOpt)) {\n      parsedLabelPos = {\n        horizontal: {\n          top: '-',\n          bottom: '+'\n        },\n        vertical: {\n          left: '-',\n          right: '+'\n        }\n      }[orient][labelPosOpt];\n    } else {\n      // is number\n      parsedLabelPos = labelPosOpt;\n    }\n\n    var labelAlignMap = {\n      horizontal: 'center',\n      vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'\n    };\n    var labelBaselineMap = {\n      horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',\n      vertical: 'middle'\n    };\n    var rotationMap = {\n      horizontal: 0,\n      vertical: PI / 2\n    }; // Position\n\n    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n    var controlModel = timelineModel.getModel('controlStyle');\n    var showControl = controlModel.get('show', true);\n    var controlSize = showControl ? controlModel.get('itemSize') : 0;\n    var controlGap = showControl ? controlModel.get('itemGap') : 0;\n    var sizePlusGap = controlSize + controlGap; // Special label rotate.\n\n    var labelRotation = timelineModel.get(['label', 'rotate']) || 0;\n    labelRotation = labelRotation * PI / 180; // To radian.\n\n    var playPosition;\n    var prevBtnPosition;\n    var nextBtnPosition;\n    var controlPosition = controlModel.get('position', true);\n    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n    var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n    var xLeft = 0;\n    var xRight = mainLength; // position[0] means left, position[1] means middle.\n\n    if (controlPosition === 'left' || controlPosition === 'bottom') {\n      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    } else {\n      // 'top' 'right'\n      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    }\n\n    var axisExtent = [xLeft, xRight];\n\n    if (timelineModel.get('inverse')) {\n      axisExtent.reverse();\n    }\n\n    return {\n      viewRect: viewRect,\n      mainLength: mainLength,\n      orient: orient,\n      rotation: rotationMap[orient],\n      labelRotation: labelRotation,\n      labelPosOpt: parsedLabelPos,\n      labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],\n      labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],\n      // Based on mainGroup.\n      playPosition: playPosition,\n      prevBtnPosition: prevBtnPosition,\n      nextBtnPosition: nextBtnPosition,\n      axisExtent: axisExtent,\n      controlSize: controlSize,\n      controlGap: controlGap\n    };\n  };\n\n  SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {\n    // Position is be called finally, because bounding rect is needed for\n    // adapt content to fill viewRect (auto adapt offset).\n    // Timeline may be not all in the viewRect when 'offset' is specified\n    // as a number, because it is more appropriate that label aligns at\n    // 'offset' but not the other edge defined by viewRect.\n    var mainGroup = this._mainGroup;\n    var labelGroup = this._labelGroup;\n    var viewRect = layoutInfo.viewRect;\n\n    if (layoutInfo.orient === 'vertical') {\n      // transform to horizontal, inverse rotate by left-top point.\n      var m = matrix.create();\n      var rotateOriginX = viewRect.x;\n      var rotateOriginY = viewRect.y + viewRect.height;\n      matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);\n      matrix.rotate(m, m, -PI / 2);\n      matrix.translate(m, m, [rotateOriginX, rotateOriginY]);\n      viewRect = viewRect.clone();\n      viewRect.applyTransform(m);\n    }\n\n    var viewBound = getBound(viewRect);\n    var mainBound = getBound(mainGroup.getBoundingRect());\n    var labelBound = getBound(labelGroup.getBoundingRect());\n    var mainPosition = [mainGroup.x, mainGroup.y];\n    var labelsPosition = [labelGroup.x, labelGroup.y];\n    labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n    var labelPosOpt = layoutInfo.labelPosOpt;\n\n    if (labelPosOpt == null || (0, _util.isString)(labelPosOpt)) {\n      // '+' or '-'\n      var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n    } else {\n      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      labelsPosition[1] = mainPosition[1] + labelPosOpt;\n    }\n\n    mainGroup.setPosition(mainPosition);\n    labelGroup.setPosition(labelsPosition);\n    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n    setOrigin(mainGroup);\n    setOrigin(labelGroup);\n\n    function setOrigin(targetGroup) {\n      targetGroup.originX = viewBound[0][0] - targetGroup.x;\n      targetGroup.originY = viewBound[1][0] - targetGroup.y;\n    }\n\n    function getBound(rect) {\n      // [[xmin, xmax], [ymin, ymax]]\n      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];\n    }\n\n    function toBound(fromPos, from, to, dimIdx, boundIdx) {\n      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n    }\n  };\n\n  SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {\n    var data = timelineModel.getData();\n    var axisType = timelineModel.get('axisType');\n    var scale = createScaleByModel(timelineModel, axisType); // Customize scale. The `tickValue` is `dataIndex`.\n\n    scale.getTicks = function () {\n      return data.mapArray(['value'], function (value) {\n        return {\n          value: value\n        };\n      });\n    };\n\n    var dataExtent = data.getDataExtent('value');\n    scale.setExtent(dataExtent[0], dataExtent[1]);\n    scale.calcNiceTicks();\n    var axis = new _TimelineAxis.default('value', scale, layoutInfo.axisExtent, axisType);\n    axis.model = timelineModel;\n    return axis;\n  };\n\n  SliderTimelineView.prototype._createGroup = function (key) {\n    var newGroup = this[key] = new graphic.Group();\n    this.group.add(newGroup);\n    return newGroup;\n  };\n\n  SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {\n    var axisExtent = axis.getExtent();\n\n    if (!timelineModel.get(['lineStyle', 'show'])) {\n      return;\n    }\n\n    var line = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        y1: 0,\n        x2: axisExtent[1],\n        y2: 0\n      },\n      style: (0, _util.extend)({\n        lineCap: 'round'\n      }, timelineModel.getModel('lineStyle').getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(line);\n    var progressLine = this._progressLine = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],\n        y1: 0,\n        y2: 0\n      },\n      style: (0, _util.defaults)({\n        lineCap: 'round',\n        lineWidth: line.style.lineWidth\n      }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(progressLine);\n  };\n\n  SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var data = timelineModel.getData(); // Show all ticks, despite ignoring strategy.\n\n    var ticks = axis.scale.getTicks();\n    this._tickSymbols = []; // The value is dataIndex, see the costomized scale.\n\n    (0, _util.each)(ticks, function (tick) {\n      var tickCoord = axis.dataToCoord(tick.value);\n      var itemModel = data.getItemModel(tick.value);\n      var itemStyleModel = itemModel.getModel('itemStyle');\n      var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);\n      var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);\n      var symbolOpt = {\n        x: tickCoord,\n        y: 0,\n        onclick: (0, _util.bind)(_this._changeTimeline, _this, tick.value)\n      };\n      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n      el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();\n      el.ensureState('progress').style = progressStyleModel.getItemStyle();\n      (0, _states.enableHoverEmphasis)(el);\n      var ecData = (0, _innerStore.getECData)(el);\n\n      if (itemModel.get('tooltip')) {\n        ecData.dataIndex = tick.value;\n        ecData.dataModel = timelineModel;\n      } else {\n        ecData.dataIndex = ecData.dataModel = null;\n      }\n\n      _this._tickSymbols.push(el);\n    });\n  };\n\n  SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var labelModel = axis.getLabelModel();\n\n    if (!labelModel.get('show')) {\n      return;\n    }\n\n    var data = timelineModel.getData();\n    var labels = axis.getViewLabels();\n    this._tickLabels = [];\n    (0, _util.each)(labels, function (labelItem) {\n      // The tickValue is dataIndex, see the costomized scale.\n      var dataIndex = labelItem.tickValue;\n      var itemModel = data.getItemModel(dataIndex);\n      var normalLabelModel = itemModel.getModel('label');\n      var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);\n      var progressLabelModel = itemModel.getModel(['progress', 'label']);\n      var tickCoord = axis.dataToCoord(labelItem.tickValue);\n      var textEl = new graphic.Text({\n        x: tickCoord,\n        y: 0,\n        rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n        onclick: (0, _util.bind)(_this._changeTimeline, _this, dataIndex),\n        silent: false,\n        style: (0, _labelStyle.createTextStyle)(normalLabelModel, {\n          text: labelItem.formattedLabel,\n          align: layoutInfo.labelAlign,\n          verticalAlign: layoutInfo.labelBaseline\n        })\n      });\n      textEl.ensureState('emphasis').style = (0, _labelStyle.createTextStyle)(hoverLabelModel);\n      textEl.ensureState('progress').style = (0, _labelStyle.createTextStyle)(progressLabelModel);\n      group.add(textEl);\n      (0, _states.enableHoverEmphasis)(textEl);\n      labelDataIndexStore(textEl).dataIndex = dataIndex;\n\n      _this._tickLabels.push(textEl);\n    });\n  };\n\n  SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {\n    var controlSize = layoutInfo.controlSize;\n    var rotation = layoutInfo.rotation;\n    var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();\n    var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();\n    var playState = timelineModel.getPlayState();\n    var inverse = timelineModel.get('inverse', true);\n    makeBtn(layoutInfo.nextBtnPosition, 'next', (0, _util.bind)(this._changeTimeline, this, inverse ? '-' : '+'));\n    makeBtn(layoutInfo.prevBtnPosition, 'prev', (0, _util.bind)(this._changeTimeline, this, inverse ? '+' : '-'));\n    makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', (0, _util.bind)(this._handlePlayClick, this, !playState), true);\n\n    function makeBtn(position, iconName, onclick, willRotate) {\n      if (!position) {\n        return;\n      }\n\n      var iconSize = (0, _text.parsePercent)((0, _util.retrieve2)(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);\n      var rect = [0, -iconSize / 2, iconSize, iconSize];\n      var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, {\n        x: position[0],\n        y: position[1],\n        originX: controlSize / 2,\n        originY: 0,\n        rotation: willRotate ? -rotation : 0,\n        rectHover: true,\n        style: itemStyle,\n        onclick: onclick\n      });\n      btn.ensureState('emphasis').style = hoverStyle;\n      group.add(btn);\n      (0, _states.enableHoverEmphasis)(btn);\n    }\n  };\n\n  SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {\n    var data = timelineModel.getData();\n    var currentIndex = timelineModel.getCurrentIndex();\n    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n    var me = this;\n    var callback = {\n      onCreate: function (pointer) {\n        pointer.draggable = true;\n        pointer.drift = (0, _util.bind)(me._handlePointerDrag, me);\n        pointer.ondragend = (0, _util.bind)(me._handlePointerDragend, me);\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);\n      },\n      onUpdate: function (pointer) {\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);\n      }\n    }; // Reuse when exists, for animation and drag.\n\n    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);\n  };\n\n  SliderTimelineView.prototype._handlePlayClick = function (nextState) {\n    this._clearTimer();\n\n    this.api.dispatchAction({\n      type: 'timelinePlayChange',\n      playState: nextState,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {\n    this._clearTimer();\n\n    this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n  };\n\n  SliderTimelineView.prototype._handlePointerDragend = function (e) {\n    this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n  };\n\n  SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {\n    var toCoord = this._toAxisCoord(mousePos)[0];\n\n    var axis = this._axis;\n    var axisExtent = numberUtil.asc(axis.getExtent().slice());\n    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n    this._currentPointer.x = toCoord;\n\n    this._currentPointer.markRedraw();\n\n    this._progressLine.shape.x2 = toCoord;\n\n    this._progressLine.dirty();\n\n    var targetDataIndex = this._findNearestTick(toCoord);\n\n    var timelineModel = this.model;\n\n    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {\n      this._changeTimeline(targetDataIndex);\n    }\n  };\n\n  SliderTimelineView.prototype._doPlayStop = function () {\n    var _this = this;\n\n    this._clearTimer();\n\n    if (this.model.getPlayState()) {\n      this._timer = setTimeout(function () {\n        // Do not cache\n        var timelineModel = _this.model;\n\n        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));\n      }, this.model.get('playInterval'));\n    }\n  };\n\n  SliderTimelineView.prototype._toAxisCoord = function (vertex) {\n    var trans = this._mainGroup.getLocalTransform();\n\n    return graphic.applyTransform(vertex, trans, true);\n  };\n\n  SliderTimelineView.prototype._findNearestTick = function (axisCoord) {\n    var data = this.model.getData();\n    var dist = Infinity;\n    var targetDataIndex;\n    var axis = this._axis;\n    data.each(['value'], function (value, dataIndex) {\n      var coord = axis.dataToCoord(value);\n      var d = Math.abs(coord - axisCoord);\n\n      if (d < dist) {\n        dist = d;\n        targetDataIndex = dataIndex;\n      }\n    });\n    return targetDataIndex;\n  };\n\n  SliderTimelineView.prototype._clearTimer = function () {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  };\n\n  SliderTimelineView.prototype._changeTimeline = function (nextIndex) {\n    var currentIndex = this.model.getCurrentIndex();\n\n    if (nextIndex === '+') {\n      nextIndex = currentIndex + 1;\n    } else if (nextIndex === '-') {\n      nextIndex = currentIndex - 1;\n    }\n\n    this.api.dispatchAction({\n      type: 'timelineChange',\n      currentIndex: nextIndex,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._updateTicksStatus = function () {\n    var currentIndex = this.model.getCurrentIndex();\n    var tickSymbols = this._tickSymbols;\n    var tickLabels = this._tickLabels;\n\n    if (tickSymbols) {\n      for (var i = 0; i < tickSymbols.length; i++) {\n        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);\n      }\n    }\n\n    if (tickLabels) {\n      for (var i = 0; i < tickLabels.length; i++) {\n        tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);\n      }\n    }\n  };\n\n  SliderTimelineView.type = 'timeline.slider';\n  return SliderTimelineView;\n}(_TimelineView.default);\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new _Ordinal.default({\n          ordinalMeta: model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new _Time.default({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // default to be value\n        return new _Interval.default();\n    }\n  }\n}\n\nfunction getViewRect(model, api) {\n  return layout.getLayoutRect(model.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  }, model.get('padding'));\n}\n\nfunction makeControlIcon(timelineModel, objPath, rect, opts) {\n  var style = opts.style;\n  var icon = graphic.createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new _BoundingRect.default(rect[0], rect[1], rect[2], rect[3])); // TODO createIcon won't use style in opt.\n\n  if (style) {\n    icon.setStyle(style);\n  }\n\n  return icon;\n}\n/**\n * Create symbol or update symbol\n * opt: basic position and event handlers\n */\n\n\nfunction giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n  var color = itemStyleModel.get('color');\n\n  if (!symbol) {\n    var symbolType = hostModel.get('symbol');\n    symbol = (0, _symbol.createSymbol)(symbolType, -1, -1, 2, 2, color);\n    symbol.setStyle('strokeNoScale', true);\n    group.add(symbol);\n    callback && callback.onCreate(symbol);\n  } else {\n    symbol.setColor(color);\n    group.add(symbol); // Group may be new, also need to add.\n\n    callback && callback.onUpdate(symbol);\n  } // Style\n\n\n  var itemStyle = itemStyleModel.getItemStyle(['color']);\n  symbol.setStyle(itemStyle); // Transform and events.\n\n  opt = (0, _util.merge)({\n    rectHover: true,\n    z2: 100\n  }, opt, true);\n  var symbolSize = (0, _symbol.normalizeSymbolSize)(hostModel.get('symbolSize'));\n  opt.scaleX = symbolSize[0] / 2;\n  opt.scaleY = symbolSize[1] / 2;\n  var symbolOffset = (0, _symbol.normalizeSymbolOffset)(hostModel.get('symbolOffset'), symbolSize);\n\n  if (symbolOffset) {\n    opt.x = (opt.x || 0) + symbolOffset[0];\n    opt.y = (opt.y || 0) + symbolOffset[1];\n  }\n\n  var symbolRotate = hostModel.get('symbolRotate');\n  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  symbol.attr(opt); // FIXME\n  // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,\n  // getBoundingRect will return wrong result.\n  // (This is supposed to be resolved in zrender, but it is a little difficult to\n  // leverage performance and auto updateTransform)\n  // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.\n\n  symbol.updateTransform();\n  return symbol;\n}\n\nfunction pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {\n  if (pointer.dragging) {\n    return;\n  }\n\n  var pointerModel = timelineModel.getModel('checkpointStyle');\n  var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));\n\n  if (noAnimation || !pointerModel.get('animation', true)) {\n    pointer.attr({\n      x: toCoord,\n      y: 0\n    });\n    progressLine && progressLine.attr({\n      shape: {\n        x2: toCoord\n      }\n    });\n  } else {\n    var animationCfg = {\n      duration: pointerModel.get('animationDuration', true),\n      easing: pointerModel.get('animationEasing', true)\n    };\n    pointer.stopAnimation(null, true);\n    pointer.animateTo({\n      x: toCoord,\n      y: 0\n    }, animationCfg);\n    progressLine && progressLine.animateTo({\n      shape: {\n        x2: toCoord\n      }\n    }, animationCfg);\n  }\n}\n\nvar _default = SliderTimelineView;\nexports.default = _default;","map":{"version":3,"names":["PI","Math","labelDataIndexStore","makeInner","SliderTimelineView","_super","__extends","_this","apply","arguments","type","prototype","init","ecModel","api","render","timelineModel","model","group","removeAll","get","layoutInfo_1","_layout","mainGroup_1","_createGroup","labelGroup","axis_1","_axis","_createAxis","formatTooltip","dataIndex","name","scale","getLabel","value","createTooltipMarkup","noName","each","_renderAxisLabel","_position","_doPlayStop","_updateTicksStatus","remove","_clearTimer","dispose","labelPosOpt","orient","viewRect","getViewRect","parsedLabelPos","y","height","getHeight","x","width","getWidth","isString","horizontal","top","bottom","vertical","left","right","labelAlignMap","labelBaselineMap","rotationMap","mainLength","controlModel","getModel","showControl","controlSize","controlGap","sizePlusGap","labelRotation","playPosition","prevBtnPosition","nextBtnPosition","controlPosition","showPlayBtn","showPrevBtn","showNextBtn","xLeft","xRight","axisExtent","reverse","rotation","labelAlign","labelBaseline","layoutInfo","mainGroup","_mainGroup","_labelGroup","m","matrix","create","rotateOriginX","rotateOriginY","translate","rotate","clone","applyTransform","viewBound","getBound","mainBound","getBoundingRect","labelBound","mainPosition","labelsPosition","mainBoundIdx","toBound","setPosition","setOrigin","targetGroup","originX","originY","rect","fromPos","from","to","dimIdx","boundIdx","data","getData","axisType","createScaleByModel","getTicks","mapArray","dataExtent","getDataExtent","setExtent","calcNiceTicks","axis","TimelineAxis","key","newGroup","graphic","Group","add","_renderAxisLine","getExtent","line","Line","shape","x1","y1","x2","y2","style","extend","lineCap","getLineStyle","silent","z2","progressLine","_progressLine","_currentPointer","defaults","lineWidth","_renderAxisTick","ticks","_tickSymbols","tick","tickCoord","dataToCoord","itemModel","getItemModel","itemStyleModel","hoverStyleModel","progressStyleModel","symbolOpt","onclick","bind","_changeTimeline","el","giveSymbol","ensureState","getItemStyle","enableHoverEmphasis","ecData","getECData","dataModel","push","labelModel","getLabelModel","labels","getViewLabels","_tickLabels","labelItem","tickValue","normalLabelModel","hoverLabelModel","progressLabelModel","textEl","Text","createTextStyle","text","formattedLabel","align","verticalAlign","_renderControl","itemStyle","hoverStyle","playState","getPlayState","inverse","makeBtn","_handlePlayClick","position","iconName","willRotate","iconSize","parsePercent","retrieve2","btn","makeControlIcon","rectHover","_renderCurrentPointer","currentIndex","getCurrentIndex","pointerModel","me","callback","onCreate","pointer","draggable","drift","_handlePointerDrag","ondragend","_handlePointerDragend","pointerMoveTo","onUpdate","nextState","dispatchAction","uid","dx","dy","e","_pointerChangeTimeline","offsetX","offsetY","mousePos","trigger","toCoord","_toAxisCoord","numberUtil","asc","slice","markRedraw","dirty","targetDataIndex","_findNearestTick","_timer","setTimeout","vertex","trans","getLocalTransform","axisCoord","dist","Infinity","coord","d","abs","clearTimeout","nextIndex","tickSymbols","tickLabels","i","length","toggleState","TimelineView","OrdinalScale","ordinalMeta","getCategories","extent","TimeScale","locale","getLocaleModel","useUTC","IntervalScale","layout","getLayoutRect","getBoxLayoutParams","objPath","opts","icon","createIcon","BoundingRect","setStyle","hostModel","opt","symbol","color","symbolType","createSymbol","setColor","merge","symbolSize","normalizeSymbolSize","scaleX","scaleY","symbolOffset","normalizeSymbolOffset","symbolRotate","attr","updateTransform","noAnimation","dragging","animationCfg","duration","easing","stopAnimation","animateTo"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/component/timeline/SliderTimelineView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport * as graphic from '../../util/graphic.js';\nimport { createTextStyle } from '../../label/labelStyle.js';\nimport * as layout from '../../util/layout.js';\nimport TimelineView from './TimelineView.js';\nimport TimelineAxis from './TimelineAxis.js';\nimport { createSymbol, normalizeSymbolOffset, normalizeSymbolSize } from '../../util/symbol.js';\nimport * as numberUtil from '../../util/number.js';\nimport { merge, each, extend, isString, bind, defaults, retrieve2 } from 'zrender/lib/core/util.js';\nimport OrdinalScale from '../../scale/Ordinal.js';\nimport TimeScale from '../../scale/Time.js';\nimport IntervalScale from '../../scale/Interval.js';\nimport { parsePercent } from 'zrender/lib/contain/text.js';\nimport { makeInner } from '../../util/model.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { enableHoverEmphasis } from '../../util/states.js';\nimport { createTooltipMarkup } from '../tooltip/tooltipMarkup.js';\nvar PI = Math.PI;\nvar labelDataIndexStore = makeInner();\n\nvar SliderTimelineView =\n/** @class */\nfunction (_super) {\n  __extends(SliderTimelineView, _super);\n\n  function SliderTimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SliderTimelineView.type;\n    return _this;\n  }\n\n  SliderTimelineView.prototype.init = function (ecModel, api) {\n    this.api = api;\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {\n    this.model = timelineModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    this.group.removeAll();\n\n    if (timelineModel.get('show', true)) {\n      var layoutInfo_1 = this._layout(timelineModel, api);\n\n      var mainGroup_1 = this._createGroup('_mainGroup');\n\n      var labelGroup = this._createGroup('_labelGroup');\n\n      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);\n\n      timelineModel.formatTooltip = function (dataIndex) {\n        var name = axis_1.scale.getLabel({\n          value: dataIndex\n        });\n        return createTooltipMarkup('nameValue', {\n          noName: true,\n          value: name\n        });\n      };\n\n      each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {\n        this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);\n      }, this);\n\n      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);\n\n      this._position(layoutInfo_1, timelineModel);\n    }\n\n    this._doPlayStop();\n\n    this._updateTicksStatus();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.remove = function () {\n    this._clearTimer();\n\n    this.group.removeAll();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.dispose = function () {\n    this._clearTimer();\n  };\n\n  SliderTimelineView.prototype._layout = function (timelineModel, api) {\n    var labelPosOpt = timelineModel.get(['label', 'position']);\n    var orient = timelineModel.get('orient');\n    var viewRect = getViewRect(timelineModel, api);\n    var parsedLabelPos; // Auto label offset.\n\n    if (labelPosOpt == null || labelPosOpt === 'auto') {\n      parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';\n    } else if (isString(labelPosOpt)) {\n      parsedLabelPos = {\n        horizontal: {\n          top: '-',\n          bottom: '+'\n        },\n        vertical: {\n          left: '-',\n          right: '+'\n        }\n      }[orient][labelPosOpt];\n    } else {\n      // is number\n      parsedLabelPos = labelPosOpt;\n    }\n\n    var labelAlignMap = {\n      horizontal: 'center',\n      vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'\n    };\n    var labelBaselineMap = {\n      horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',\n      vertical: 'middle'\n    };\n    var rotationMap = {\n      horizontal: 0,\n      vertical: PI / 2\n    }; // Position\n\n    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n    var controlModel = timelineModel.getModel('controlStyle');\n    var showControl = controlModel.get('show', true);\n    var controlSize = showControl ? controlModel.get('itemSize') : 0;\n    var controlGap = showControl ? controlModel.get('itemGap') : 0;\n    var sizePlusGap = controlSize + controlGap; // Special label rotate.\n\n    var labelRotation = timelineModel.get(['label', 'rotate']) || 0;\n    labelRotation = labelRotation * PI / 180; // To radian.\n\n    var playPosition;\n    var prevBtnPosition;\n    var nextBtnPosition;\n    var controlPosition = controlModel.get('position', true);\n    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n    var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n    var xLeft = 0;\n    var xRight = mainLength; // position[0] means left, position[1] means middle.\n\n    if (controlPosition === 'left' || controlPosition === 'bottom') {\n      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    } else {\n      // 'top' 'right'\n      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    }\n\n    var axisExtent = [xLeft, xRight];\n\n    if (timelineModel.get('inverse')) {\n      axisExtent.reverse();\n    }\n\n    return {\n      viewRect: viewRect,\n      mainLength: mainLength,\n      orient: orient,\n      rotation: rotationMap[orient],\n      labelRotation: labelRotation,\n      labelPosOpt: parsedLabelPos,\n      labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],\n      labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],\n      // Based on mainGroup.\n      playPosition: playPosition,\n      prevBtnPosition: prevBtnPosition,\n      nextBtnPosition: nextBtnPosition,\n      axisExtent: axisExtent,\n      controlSize: controlSize,\n      controlGap: controlGap\n    };\n  };\n\n  SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {\n    // Position is be called finally, because bounding rect is needed for\n    // adapt content to fill viewRect (auto adapt offset).\n    // Timeline may be not all in the viewRect when 'offset' is specified\n    // as a number, because it is more appropriate that label aligns at\n    // 'offset' but not the other edge defined by viewRect.\n    var mainGroup = this._mainGroup;\n    var labelGroup = this._labelGroup;\n    var viewRect = layoutInfo.viewRect;\n\n    if (layoutInfo.orient === 'vertical') {\n      // transform to horizontal, inverse rotate by left-top point.\n      var m = matrix.create();\n      var rotateOriginX = viewRect.x;\n      var rotateOriginY = viewRect.y + viewRect.height;\n      matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);\n      matrix.rotate(m, m, -PI / 2);\n      matrix.translate(m, m, [rotateOriginX, rotateOriginY]);\n      viewRect = viewRect.clone();\n      viewRect.applyTransform(m);\n    }\n\n    var viewBound = getBound(viewRect);\n    var mainBound = getBound(mainGroup.getBoundingRect());\n    var labelBound = getBound(labelGroup.getBoundingRect());\n    var mainPosition = [mainGroup.x, mainGroup.y];\n    var labelsPosition = [labelGroup.x, labelGroup.y];\n    labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n    var labelPosOpt = layoutInfo.labelPosOpt;\n\n    if (labelPosOpt == null || isString(labelPosOpt)) {\n      // '+' or '-'\n      var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n    } else {\n      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      labelsPosition[1] = mainPosition[1] + labelPosOpt;\n    }\n\n    mainGroup.setPosition(mainPosition);\n    labelGroup.setPosition(labelsPosition);\n    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n    setOrigin(mainGroup);\n    setOrigin(labelGroup);\n\n    function setOrigin(targetGroup) {\n      targetGroup.originX = viewBound[0][0] - targetGroup.x;\n      targetGroup.originY = viewBound[1][0] - targetGroup.y;\n    }\n\n    function getBound(rect) {\n      // [[xmin, xmax], [ymin, ymax]]\n      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];\n    }\n\n    function toBound(fromPos, from, to, dimIdx, boundIdx) {\n      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n    }\n  };\n\n  SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {\n    var data = timelineModel.getData();\n    var axisType = timelineModel.get('axisType');\n    var scale = createScaleByModel(timelineModel, axisType); // Customize scale. The `tickValue` is `dataIndex`.\n\n    scale.getTicks = function () {\n      return data.mapArray(['value'], function (value) {\n        return {\n          value: value\n        };\n      });\n    };\n\n    var dataExtent = data.getDataExtent('value');\n    scale.setExtent(dataExtent[0], dataExtent[1]);\n    scale.calcNiceTicks();\n    var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);\n    axis.model = timelineModel;\n    return axis;\n  };\n\n  SliderTimelineView.prototype._createGroup = function (key) {\n    var newGroup = this[key] = new graphic.Group();\n    this.group.add(newGroup);\n    return newGroup;\n  };\n\n  SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {\n    var axisExtent = axis.getExtent();\n\n    if (!timelineModel.get(['lineStyle', 'show'])) {\n      return;\n    }\n\n    var line = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        y1: 0,\n        x2: axisExtent[1],\n        y2: 0\n      },\n      style: extend({\n        lineCap: 'round'\n      }, timelineModel.getModel('lineStyle').getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(line);\n    var progressLine = this._progressLine = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],\n        y1: 0,\n        y2: 0\n      },\n      style: defaults({\n        lineCap: 'round',\n        lineWidth: line.style.lineWidth\n      }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(progressLine);\n  };\n\n  SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var data = timelineModel.getData(); // Show all ticks, despite ignoring strategy.\n\n    var ticks = axis.scale.getTicks();\n    this._tickSymbols = []; // The value is dataIndex, see the costomized scale.\n\n    each(ticks, function (tick) {\n      var tickCoord = axis.dataToCoord(tick.value);\n      var itemModel = data.getItemModel(tick.value);\n      var itemStyleModel = itemModel.getModel('itemStyle');\n      var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);\n      var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);\n      var symbolOpt = {\n        x: tickCoord,\n        y: 0,\n        onclick: bind(_this._changeTimeline, _this, tick.value)\n      };\n      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n      el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();\n      el.ensureState('progress').style = progressStyleModel.getItemStyle();\n      enableHoverEmphasis(el);\n      var ecData = getECData(el);\n\n      if (itemModel.get('tooltip')) {\n        ecData.dataIndex = tick.value;\n        ecData.dataModel = timelineModel;\n      } else {\n        ecData.dataIndex = ecData.dataModel = null;\n      }\n\n      _this._tickSymbols.push(el);\n    });\n  };\n\n  SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var labelModel = axis.getLabelModel();\n\n    if (!labelModel.get('show')) {\n      return;\n    }\n\n    var data = timelineModel.getData();\n    var labels = axis.getViewLabels();\n    this._tickLabels = [];\n    each(labels, function (labelItem) {\n      // The tickValue is dataIndex, see the costomized scale.\n      var dataIndex = labelItem.tickValue;\n      var itemModel = data.getItemModel(dataIndex);\n      var normalLabelModel = itemModel.getModel('label');\n      var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);\n      var progressLabelModel = itemModel.getModel(['progress', 'label']);\n      var tickCoord = axis.dataToCoord(labelItem.tickValue);\n      var textEl = new graphic.Text({\n        x: tickCoord,\n        y: 0,\n        rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n        onclick: bind(_this._changeTimeline, _this, dataIndex),\n        silent: false,\n        style: createTextStyle(normalLabelModel, {\n          text: labelItem.formattedLabel,\n          align: layoutInfo.labelAlign,\n          verticalAlign: layoutInfo.labelBaseline\n        })\n      });\n      textEl.ensureState('emphasis').style = createTextStyle(hoverLabelModel);\n      textEl.ensureState('progress').style = createTextStyle(progressLabelModel);\n      group.add(textEl);\n      enableHoverEmphasis(textEl);\n      labelDataIndexStore(textEl).dataIndex = dataIndex;\n\n      _this._tickLabels.push(textEl);\n    });\n  };\n\n  SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {\n    var controlSize = layoutInfo.controlSize;\n    var rotation = layoutInfo.rotation;\n    var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();\n    var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();\n    var playState = timelineModel.getPlayState();\n    var inverse = timelineModel.get('inverse', true);\n    makeBtn(layoutInfo.nextBtnPosition, 'next', bind(this._changeTimeline, this, inverse ? '-' : '+'));\n    makeBtn(layoutInfo.prevBtnPosition, 'prev', bind(this._changeTimeline, this, inverse ? '+' : '-'));\n    makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', bind(this._handlePlayClick, this, !playState), true);\n\n    function makeBtn(position, iconName, onclick, willRotate) {\n      if (!position) {\n        return;\n      }\n\n      var iconSize = parsePercent(retrieve2(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);\n      var rect = [0, -iconSize / 2, iconSize, iconSize];\n      var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, {\n        x: position[0],\n        y: position[1],\n        originX: controlSize / 2,\n        originY: 0,\n        rotation: willRotate ? -rotation : 0,\n        rectHover: true,\n        style: itemStyle,\n        onclick: onclick\n      });\n      btn.ensureState('emphasis').style = hoverStyle;\n      group.add(btn);\n      enableHoverEmphasis(btn);\n    }\n  };\n\n  SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {\n    var data = timelineModel.getData();\n    var currentIndex = timelineModel.getCurrentIndex();\n    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n    var me = this;\n    var callback = {\n      onCreate: function (pointer) {\n        pointer.draggable = true;\n        pointer.drift = bind(me._handlePointerDrag, me);\n        pointer.ondragend = bind(me._handlePointerDragend, me);\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);\n      },\n      onUpdate: function (pointer) {\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);\n      }\n    }; // Reuse when exists, for animation and drag.\n\n    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);\n  };\n\n  SliderTimelineView.prototype._handlePlayClick = function (nextState) {\n    this._clearTimer();\n\n    this.api.dispatchAction({\n      type: 'timelinePlayChange',\n      playState: nextState,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {\n    this._clearTimer();\n\n    this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n  };\n\n  SliderTimelineView.prototype._handlePointerDragend = function (e) {\n    this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n  };\n\n  SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {\n    var toCoord = this._toAxisCoord(mousePos)[0];\n\n    var axis = this._axis;\n    var axisExtent = numberUtil.asc(axis.getExtent().slice());\n    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n    this._currentPointer.x = toCoord;\n\n    this._currentPointer.markRedraw();\n\n    this._progressLine.shape.x2 = toCoord;\n\n    this._progressLine.dirty();\n\n    var targetDataIndex = this._findNearestTick(toCoord);\n\n    var timelineModel = this.model;\n\n    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {\n      this._changeTimeline(targetDataIndex);\n    }\n  };\n\n  SliderTimelineView.prototype._doPlayStop = function () {\n    var _this = this;\n\n    this._clearTimer();\n\n    if (this.model.getPlayState()) {\n      this._timer = setTimeout(function () {\n        // Do not cache\n        var timelineModel = _this.model;\n\n        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));\n      }, this.model.get('playInterval'));\n    }\n  };\n\n  SliderTimelineView.prototype._toAxisCoord = function (vertex) {\n    var trans = this._mainGroup.getLocalTransform();\n\n    return graphic.applyTransform(vertex, trans, true);\n  };\n\n  SliderTimelineView.prototype._findNearestTick = function (axisCoord) {\n    var data = this.model.getData();\n    var dist = Infinity;\n    var targetDataIndex;\n    var axis = this._axis;\n    data.each(['value'], function (value, dataIndex) {\n      var coord = axis.dataToCoord(value);\n      var d = Math.abs(coord - axisCoord);\n\n      if (d < dist) {\n        dist = d;\n        targetDataIndex = dataIndex;\n      }\n    });\n    return targetDataIndex;\n  };\n\n  SliderTimelineView.prototype._clearTimer = function () {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  };\n\n  SliderTimelineView.prototype._changeTimeline = function (nextIndex) {\n    var currentIndex = this.model.getCurrentIndex();\n\n    if (nextIndex === '+') {\n      nextIndex = currentIndex + 1;\n    } else if (nextIndex === '-') {\n      nextIndex = currentIndex - 1;\n    }\n\n    this.api.dispatchAction({\n      type: 'timelineChange',\n      currentIndex: nextIndex,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._updateTicksStatus = function () {\n    var currentIndex = this.model.getCurrentIndex();\n    var tickSymbols = this._tickSymbols;\n    var tickLabels = this._tickLabels;\n\n    if (tickSymbols) {\n      for (var i = 0; i < tickSymbols.length; i++) {\n        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);\n      }\n    }\n\n    if (tickLabels) {\n      for (var i = 0; i < tickLabels.length; i++) {\n        tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);\n      }\n    }\n  };\n\n  SliderTimelineView.type = 'timeline.slider';\n  return SliderTimelineView;\n}(TimelineView);\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale({\n          ordinalMeta: model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new TimeScale({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // default to be value\n        return new IntervalScale();\n    }\n  }\n}\n\nfunction getViewRect(model, api) {\n  return layout.getLayoutRect(model.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  }, model.get('padding'));\n}\n\nfunction makeControlIcon(timelineModel, objPath, rect, opts) {\n  var style = opts.style;\n  var icon = graphic.createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3])); // TODO createIcon won't use style in opt.\n\n  if (style) {\n    icon.setStyle(style);\n  }\n\n  return icon;\n}\n/**\n * Create symbol or update symbol\n * opt: basic position and event handlers\n */\n\n\nfunction giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n  var color = itemStyleModel.get('color');\n\n  if (!symbol) {\n    var symbolType = hostModel.get('symbol');\n    symbol = createSymbol(symbolType, -1, -1, 2, 2, color);\n    symbol.setStyle('strokeNoScale', true);\n    group.add(symbol);\n    callback && callback.onCreate(symbol);\n  } else {\n    symbol.setColor(color);\n    group.add(symbol); // Group may be new, also need to add.\n\n    callback && callback.onUpdate(symbol);\n  } // Style\n\n\n  var itemStyle = itemStyleModel.getItemStyle(['color']);\n  symbol.setStyle(itemStyle); // Transform and events.\n\n  opt = merge({\n    rectHover: true,\n    z2: 100\n  }, opt, true);\n  var symbolSize = normalizeSymbolSize(hostModel.get('symbolSize'));\n  opt.scaleX = symbolSize[0] / 2;\n  opt.scaleY = symbolSize[1] / 2;\n  var symbolOffset = normalizeSymbolOffset(hostModel.get('symbolOffset'), symbolSize);\n\n  if (symbolOffset) {\n    opt.x = (opt.x || 0) + symbolOffset[0];\n    opt.y = (opt.y || 0) + symbolOffset[1];\n  }\n\n  var symbolRotate = hostModel.get('symbolRotate');\n  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  symbol.attr(opt); // FIXME\n  // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,\n  // getBoundingRect will return wrong result.\n  // (This is supposed to be resolved in zrender, but it is a little difficult to\n  // leverage performance and auto updateTransform)\n  // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.\n\n  symbol.updateTransform();\n  return symbol;\n}\n\nfunction pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {\n  if (pointer.dragging) {\n    return;\n  }\n\n  var pointerModel = timelineModel.getModel('checkpointStyle');\n  var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));\n\n  if (noAnimation || !pointerModel.get('animation', true)) {\n    pointer.attr({\n      x: toCoord,\n      y: 0\n    });\n    progressLine && progressLine.attr({\n      shape: {\n        x2: toCoord\n      }\n    });\n  } else {\n    var animationCfg = {\n      duration: pointerModel.get('animationDuration', true),\n      easing: pointerModel.get('animationEasing', true)\n    };\n    pointer.stopAnimation(null, true);\n    pointer.animateTo({\n      x: toCoord,\n      y: 0\n    }, animationCfg);\n    progressLine && progressLine.animateTo({\n      shape: {\n        x2: toCoord\n      }\n    }, animationCfg);\n  }\n}\n\nexport default SliderTimelineView;"],"mappings":"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"},"metadata":{},"sourceType":"script"}