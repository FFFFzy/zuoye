{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseConditionalExpression = parseConditionalExpression;\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _log = require(\"./log.js\");\n\nvar _dataValueHelper = require(\"../data/helper/dataValueHelper.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n;\nvar RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {\n  value: 'eq',\n  // PENDING: not good for literal semantic?\n  '<': 'lt',\n  '<=': 'lte',\n  '>': 'gt',\n  '>=': 'gte',\n  '=': 'eq',\n  '!=': 'ne',\n  '<>': 'ne' // Might mileading for sake of the different between '==' and '===',\n  // So dont support them.\n  // '==': 'eq',\n  // '===': 'seq',\n  // '!==': 'sne'\n  // PENDING: Whether support some common alias \"ge\", \"le\", \"neq\"?\n  // ge: 'gte',\n  // le: 'lte',\n  // neq: 'ne',\n\n}; // type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;\n\nvar RegExpEvaluator =\n/** @class */\nfunction () {\n  function RegExpEvaluator(rVal) {\n    // Support condVal: RegExp | string\n    var condValue = this._condVal = (0, _util.isString)(rVal) ? new RegExp(rVal) : (0, _util.isRegExp)(rVal) ? rVal : null;\n\n    if (condValue == null) {\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = (0, _log.makePrintable)('Illegal regexp', rVal, 'in');\n      }\n\n      (0, _log.throwError)(errMsg);\n    }\n  }\n\n  RegExpEvaluator.prototype.evaluate = function (lVal) {\n    var type = typeof lVal;\n    return (0, _util.isString)(type) ? this._condVal.test(lVal) : (0, _util.isNumber)(type) ? this._condVal.test(lVal + '') : false;\n  };\n\n  return RegExpEvaluator;\n}();\n\nvar ConstConditionInternal =\n/** @class */\nfunction () {\n  function ConstConditionInternal() {}\n\n  ConstConditionInternal.prototype.evaluate = function () {\n    return this.value;\n  };\n\n  return ConstConditionInternal;\n}();\n\nvar AndConditionInternal =\n/** @class */\nfunction () {\n  function AndConditionInternal() {}\n\n  AndConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (!children[i].evaluate()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return AndConditionInternal;\n}();\n\nvar OrConditionInternal =\n/** @class */\nfunction () {\n  function OrConditionInternal() {}\n\n  OrConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].evaluate()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return OrConditionInternal;\n}();\n\nvar NotConditionInternal =\n/** @class */\nfunction () {\n  function NotConditionInternal() {}\n\n  NotConditionInternal.prototype.evaluate = function () {\n    return !this.child.evaluate();\n  };\n\n  return NotConditionInternal;\n}();\n\nvar RelationalConditionInternal =\n/** @class */\nfunction () {\n  function RelationalConditionInternal() {}\n\n  RelationalConditionInternal.prototype.evaluate = function () {\n    var needParse = !!this.valueParser; // Call getValue with no `this`.\n\n    var getValue = this.getValue;\n    var tarValRaw = getValue(this.valueGetterParam);\n    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null; // Relational cond follow \"and\" logic internally.\n\n    for (var i = 0; i < this.subCondList.length; i++) {\n      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return RelationalConditionInternal;\n}();\n\nfunction parseOption(exprOption, getters) {\n  if (exprOption === true || exprOption === false) {\n    var cond = new ConstConditionInternal();\n    cond.value = exprOption;\n    return cond;\n  }\n\n  var errMsg = '';\n\n  if (!isObjectNotArray(exprOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = (0, _log.makePrintable)('Illegal config. Expect a plain object but actually', exprOption);\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  if (exprOption.and) {\n    return parseAndOrOption('and', exprOption, getters);\n  } else if (exprOption.or) {\n    return parseAndOrOption('or', exprOption, getters);\n  } else if (exprOption.not) {\n    return parseNotOption(exprOption, getters);\n  }\n\n  return parseRelationalOption(exprOption, getters);\n}\n\nfunction parseAndOrOption(op, exprOption, getters) {\n  var subOptionArr = exprOption[op];\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = (0, _log.makePrintable)('\"and\"/\"or\" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption);\n  }\n\n  if (!(0, _util.isArray)(subOptionArr)) {\n    (0, _log.throwError)(errMsg);\n  }\n\n  if (!subOptionArr.length) {\n    (0, _log.throwError)(errMsg);\n  }\n\n  var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();\n  cond.children = (0, _util.map)(subOptionArr, function (subOption) {\n    return parseOption(subOption, getters);\n  });\n\n  if (!cond.children.length) {\n    (0, _log.throwError)(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseNotOption(exprOption, getters) {\n  var subOption = exprOption.not;\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = (0, _log.makePrintable)('\"not\" condition should only be `not: {}`.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isObjectNotArray(subOption)) {\n    (0, _log.throwError)(errMsg);\n  }\n\n  var cond = new NotConditionInternal();\n  cond.child = parseOption(subOption, getters);\n\n  if (!cond.child) {\n    (0, _log.throwError)(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseRelationalOption(exprOption, getters) {\n  var errMsg = '';\n  var valueGetterParam = getters.prepareGetValue(exprOption);\n  var subCondList = [];\n  var exprKeys = (0, _util.keys)(exprOption);\n  var parserName = exprOption.parser;\n  var valueParser = parserName ? (0, _dataValueHelper.getRawValueParser)(parserName) : null;\n\n  for (var i = 0; i < exprKeys.length; i++) {\n    var keyRaw = exprKeys[i];\n\n    if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {\n      continue;\n    }\n\n    var op = (0, _util.hasOwn)(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;\n    var condValueRaw = exprOption[keyRaw];\n    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;\n    var evaluator = (0, _dataValueHelper.createFilterComparator)(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);\n\n    if (!evaluator) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = (0, _log.makePrintable)('Illegal relational operation: \"' + keyRaw + '\" in condition:', exprOption);\n      }\n\n      (0, _log.throwError)(errMsg);\n    }\n\n    subCondList.push(evaluator);\n  }\n\n  if (!subCondList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = (0, _log.makePrintable)('Relational condition must have at least one operator.', 'Illegal condition:', exprOption);\n    } // No relational operator always disabled in case of dangers result.\n\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  var cond = new RelationalConditionInternal();\n  cond.valueGetterParam = valueGetterParam;\n  cond.valueParser = valueParser;\n  cond.getValue = getters.getValue;\n  cond.subCondList = subCondList;\n  return cond;\n}\n\nfunction isObjectNotArray(val) {\n  return (0, _util.isObject)(val) && !(0, _util.isArrayLike)(val);\n}\n\nvar ConditionalExpressionParsed =\n/** @class */\nfunction () {\n  function ConditionalExpressionParsed(exprOption, getters) {\n    this._cond = parseOption(exprOption, getters);\n  }\n\n  ConditionalExpressionParsed.prototype.evaluate = function () {\n    return this._cond.evaluate();\n  };\n\n  return ConditionalExpressionParsed;\n}();\n\n;\n\nfunction parseConditionalExpression(exprOption, getters) {\n  return new ConditionalExpressionParsed(exprOption, getters);\n}","map":{"version":3,"names":["RELATIONAL_EXPRESSION_OP_ALIAS_MAP","value","RegExpEvaluator","rVal","condValue","_condVal","isString","RegExp","isRegExp","errMsg","process","env","NODE_ENV","makePrintable","throwError","prototype","evaluate","lVal","type","test","isNumber","ConstConditionInternal","AndConditionInternal","children","i","length","OrConditionInternal","NotConditionInternal","child","RelationalConditionInternal","needParse","valueParser","getValue","tarValRaw","valueGetterParam","tarValParsed","subCondList","parseOption","exprOption","getters","cond","isObjectNotArray","and","parseAndOrOption","or","not","parseNotOption","parseRelationalOption","op","subOptionArr","isArray","map","subOption","prepareGetValue","exprKeys","keys","parserName","parser","getRawValueParser","keyRaw","valueGetterAttrMap","get","hasOwn","condValueRaw","condValueParsed","evaluator","createFilterComparator","push","val","isObject","isArrayLike","ConditionalExpressionParsed","_cond","parseConditionalExpression"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/util/conditionalExpression.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { keys, isArray, map, isObject, isString, isRegExp, isArrayLike, hasOwn, isNumber } from 'zrender/lib/core/util.js';\nimport { throwError, makePrintable } from './log.js';\nimport { getRawValueParser, createFilterComparator } from '../data/helper/dataValueHelper.js';\n;\nvar RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {\n  value: 'eq',\n  // PENDING: not good for literal semantic?\n  '<': 'lt',\n  '<=': 'lte',\n  '>': 'gt',\n  '>=': 'gte',\n  '=': 'eq',\n  '!=': 'ne',\n  '<>': 'ne' // Might mileading for sake of the different between '==' and '===',\n  // So dont support them.\n  // '==': 'eq',\n  // '===': 'seq',\n  // '!==': 'sne'\n  // PENDING: Whether support some common alias \"ge\", \"le\", \"neq\"?\n  // ge: 'gte',\n  // le: 'lte',\n  // neq: 'ne',\n\n}; // type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;\n\nvar RegExpEvaluator =\n/** @class */\nfunction () {\n  function RegExpEvaluator(rVal) {\n    // Support condVal: RegExp | string\n    var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;\n\n    if (condValue == null) {\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = makePrintable('Illegal regexp', rVal, 'in');\n      }\n\n      throwError(errMsg);\n    }\n  }\n\n  RegExpEvaluator.prototype.evaluate = function (lVal) {\n    var type = typeof lVal;\n    return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + '') : false;\n  };\n\n  return RegExpEvaluator;\n}();\n\nvar ConstConditionInternal =\n/** @class */\nfunction () {\n  function ConstConditionInternal() {}\n\n  ConstConditionInternal.prototype.evaluate = function () {\n    return this.value;\n  };\n\n  return ConstConditionInternal;\n}();\n\nvar AndConditionInternal =\n/** @class */\nfunction () {\n  function AndConditionInternal() {}\n\n  AndConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (!children[i].evaluate()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return AndConditionInternal;\n}();\n\nvar OrConditionInternal =\n/** @class */\nfunction () {\n  function OrConditionInternal() {}\n\n  OrConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].evaluate()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return OrConditionInternal;\n}();\n\nvar NotConditionInternal =\n/** @class */\nfunction () {\n  function NotConditionInternal() {}\n\n  NotConditionInternal.prototype.evaluate = function () {\n    return !this.child.evaluate();\n  };\n\n  return NotConditionInternal;\n}();\n\nvar RelationalConditionInternal =\n/** @class */\nfunction () {\n  function RelationalConditionInternal() {}\n\n  RelationalConditionInternal.prototype.evaluate = function () {\n    var needParse = !!this.valueParser; // Call getValue with no `this`.\n\n    var getValue = this.getValue;\n    var tarValRaw = getValue(this.valueGetterParam);\n    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null; // Relational cond follow \"and\" logic internally.\n\n    for (var i = 0; i < this.subCondList.length; i++) {\n      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return RelationalConditionInternal;\n}();\n\nfunction parseOption(exprOption, getters) {\n  if (exprOption === true || exprOption === false) {\n    var cond = new ConstConditionInternal();\n    cond.value = exprOption;\n    return cond;\n  }\n\n  var errMsg = '';\n\n  if (!isObjectNotArray(exprOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = makePrintable('Illegal config. Expect a plain object but actually', exprOption);\n    }\n\n    throwError(errMsg);\n  }\n\n  if (exprOption.and) {\n    return parseAndOrOption('and', exprOption, getters);\n  } else if (exprOption.or) {\n    return parseAndOrOption('or', exprOption, getters);\n  } else if (exprOption.not) {\n    return parseNotOption(exprOption, getters);\n  }\n\n  return parseRelationalOption(exprOption, getters);\n}\n\nfunction parseAndOrOption(op, exprOption, getters) {\n  var subOptionArr = exprOption[op];\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = makePrintable('\"and\"/\"or\" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isArray(subOptionArr)) {\n    throwError(errMsg);\n  }\n\n  if (!subOptionArr.length) {\n    throwError(errMsg);\n  }\n\n  var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();\n  cond.children = map(subOptionArr, function (subOption) {\n    return parseOption(subOption, getters);\n  });\n\n  if (!cond.children.length) {\n    throwError(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseNotOption(exprOption, getters) {\n  var subOption = exprOption.not;\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = makePrintable('\"not\" condition should only be `not: {}`.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isObjectNotArray(subOption)) {\n    throwError(errMsg);\n  }\n\n  var cond = new NotConditionInternal();\n  cond.child = parseOption(subOption, getters);\n\n  if (!cond.child) {\n    throwError(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseRelationalOption(exprOption, getters) {\n  var errMsg = '';\n  var valueGetterParam = getters.prepareGetValue(exprOption);\n  var subCondList = [];\n  var exprKeys = keys(exprOption);\n  var parserName = exprOption.parser;\n  var valueParser = parserName ? getRawValueParser(parserName) : null;\n\n  for (var i = 0; i < exprKeys.length; i++) {\n    var keyRaw = exprKeys[i];\n\n    if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {\n      continue;\n    }\n\n    var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;\n    var condValueRaw = exprOption[keyRaw];\n    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;\n    var evaluator = createFilterComparator(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);\n\n    if (!evaluator) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = makePrintable('Illegal relational operation: \"' + keyRaw + '\" in condition:', exprOption);\n      }\n\n      throwError(errMsg);\n    }\n\n    subCondList.push(evaluator);\n  }\n\n  if (!subCondList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = makePrintable('Relational condition must have at least one operator.', 'Illegal condition:', exprOption);\n    } // No relational operator always disabled in case of dangers result.\n\n\n    throwError(errMsg);\n  }\n\n  var cond = new RelationalConditionInternal();\n  cond.valueGetterParam = valueGetterParam;\n  cond.valueParser = valueParser;\n  cond.getValue = getters.getValue;\n  cond.subCondList = subCondList;\n  return cond;\n}\n\nfunction isObjectNotArray(val) {\n  return isObject(val) && !isArrayLike(val);\n}\n\nvar ConditionalExpressionParsed =\n/** @class */\nfunction () {\n  function ConditionalExpressionParsed(exprOption, getters) {\n    this._cond = parseOption(exprOption, getters);\n  }\n\n  ConditionalExpressionParsed.prototype.evaluate = function () {\n    return this._cond.evaluate();\n  };\n\n  return ConditionalExpressionParsed;\n}();\n\n;\nexport function parseConditionalExpression(exprOption, getters) {\n  return new ConditionalExpressionParsed(exprOption, getters);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}