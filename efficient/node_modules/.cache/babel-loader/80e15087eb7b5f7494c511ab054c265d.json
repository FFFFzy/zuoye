{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDimensions = createDimensions;\nexports.default = prepareSeriesDataSchema;\n\nvar _types = require(\"../../util/types.js\");\n\nvar _SeriesDimensionDefine = _interopRequireDefault(require(\"../SeriesDimensionDefine.js\"));\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _Source = require(\"../Source.js\");\n\nvar _DataStore = require(\"../DataStore.js\");\n\nvar _model = require(\"../../util/model.js\");\n\nvar _sourceHelper = require(\"./sourceHelper.js\");\n\nvar _SeriesDataSchema = require(\"./SeriesDataSchema.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\nfunction createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\n\nfunction prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!(0, _Source.isSourceInstance)(source)) {\n    source = (0, _Source.createSourceFromSeriesDataOption)(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = (0, _util.createHashMap)();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && (0, _SeriesDataSchema.shouldOmitUnusedDimensions)(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? (0, _SeriesDataSchema.ensureSourceDimNameMap)(source) : (0, _SeriesDataSchema.createDimNameMap)(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = (0, _util.createHashMap)(encodeDef);\n  var indicesMap = new _DataStore.CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = (0, _util.isObject)(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new _SeriesDimensionDefine.default();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = (0, _model.normalizeToArray)(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !(0, _util.isString)(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    (0, _util.each)(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = (0, _util.isString)(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  (0, _util.each)(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if ((0, _util.isString)(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = (0, _util.extend)({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = (0, _model.normalizeToArray)(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    (0, _util.each)(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim((0, _util.defaults)(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !(0, _util.isObject)(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && (0, _util.defaults)(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (_types.VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && ((0, _sourceHelper.guessOrdinal)(source, resultDimIdx) === _sourceHelper.BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    (0, _util.each)(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new _SeriesDataSchema.SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = (0, _util.createHashMap)();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  (0, _util.each)(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if ((0, _util.isObject)(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}","map":{"version":3,"names":["createDimensions","source","opt","prepareSeriesDataSchema","dimensions","isSourceInstance","createSourceFromSeriesDataOption","sysDims","coordDimensions","dimsDef","dimensionsDefine","coordDimNameMap","createHashMap","resultList","dimCount","getDimCount","dimensionsCount","omitUnusedDimensions","canOmitUnusedDimensions","shouldOmitUnusedDimensions","isUsingSourceDimensionsDef","dataDimNameMap","ensureSourceDimNameMap","createDimNameMap","encodeDef","encodeDefine","encodeDefaulter","encodeDefMap","indicesMap","CtorInt32Array","i","length","getResultItem","dimIdx","idx","dimDefItemRaw","dimDefItem","isObject","name","resultItem","SeriesDimensionDefine","userDimName","get","displayName","type","newIdx","storeDimIndex","push","each","dataDimsRaw","coordDim","dataDims","normalizeToArray","slice","isString","set","validDataDims","resultDimIdxOrName","resultDimIdx","applyDim","availDimIdx","sysDimItemRaw","sysDimItemDimsDef","sysDimItemOtherDims","sysDimItem","ordinalMeta","extend","otherDims","coordDimIndex","defaults","sysDimItemDimsDefItem","defaultTooltip","VISUAL_DIMENSIONS","generateCoord","generateCoordCount","fromZero","extra","ifNoNameFillWithCoordName","genCoordDimName","isExtraCoord","guessOrdinal","BE_ORDINAL","Must","itemName","seriesName","sort","item0","item1","removeDuplication","SeriesDataSchema","fullDimensionCount","dimensionOmitted","result","duplicationMap","dim","dimOriginalName","count","optDimCount","Math","max","dimensionsDetectedCount","map","mapData","data","hasOwnProperty"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/helper/createDimensions.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine.js';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { CtorInt32Array } from '../DataStore.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper.js';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema.js';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\n\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\nexport default function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}