{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.installUniversalTransition = installUniversalTransition;\n\nvar _Series = require(\"../model/Series.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _morphTransitionHelper = require(\"./morphTransitionHelper.js\");\n\nvar _Path = _interopRequireDefault(require(\"zrender/lib/graphic/Path.js\"));\n\nvar _graphic = require(\"../util/graphic.js\");\n\nvar _DataDiffer = _interopRequireDefault(require(\"../data/DataDiffer.js\"));\n\nvar _model = require(\"../util/model.js\");\n\nvar _log = require(\"../util/log.js\");\n\nvar _basicTrasition = require(\"./basicTrasition.js\");\n\nvar _Displayable = _interopRequireDefault(require(\"zrender/lib/graphic/Displayable.js\"));\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = (0, _model.makeInner)();\n\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  (0, _util.each)(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _log.warn)('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof _Path.default) {\n      // TODO use fade in animation for target element.\n      (0, _graphic.initProps)(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = (0, _basicTrasition.getAnimationConfig)('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof _Displayable.default) {\n      var oldStyle = (0, _basicTrasition.getOldStyle)(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        (0, _util.extend)((0, _util.extend)({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n\n      var dataGroupId = data.hostModel && data.hostModel.get('dataGroupId'); // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n\n      var itemVal = data.getRawDataItem(dataIndex);\n\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        (0, _morphTransitionHelper.applyMorphAnimation)((0, _morphTransitionHelper.getPathList)(oldEl), (0, _morphTransitionHelper.getPathList)(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new _DataDiffer.default(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = (0, _util.filter)((0, _util.map)(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        (0, _util.each)(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        (0, _morphTransitionHelper.applyMorphAnimation)((0, _morphTransitionHelper.getPathList)(oldElsList), (0, _morphTransitionHelper.getPathList)(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = (0, _util.filter)((0, _util.map)(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      (0, _util.each)(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        (0, _morphTransitionHelper.applyMorphAnimation)((0, _morphTransitionHelper.getPathList)(oldEl), (0, _morphTransitionHelper.getPathList)(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        (0, _util.each)(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new _DataDiffer.default(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    (0, _util.each)(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = (0, _basicTrasition.getAnimationConfig)('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof _Path.default && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if ((0, _util.isArray)(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = (0, _util.createHashMap)();\n  var oldDataMap = (0, _util.createHashMap)(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = (0, _util.createHashMap)();\n  (0, _util.each)(globalStore.oldSeries, function (series, idx) {\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, oldData);\n\n    if ((0, _util.isArray)(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      (0, _util.each)(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          data: oldData,\n          key: transitionKeyStr\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      (0, _log.warn)(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  (0, _util.each)(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            divide: getDivideShapeFromData(oldData),\n            data: oldData\n          }],\n          newSeries: [{\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if ((0, _util.isArray)(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          (0, _util.each)(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData) {\n              oldSeries_1.push({\n                divide: getDivideShapeFromData(oldData),\n                data: oldData\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  (0, _util.each)((0, _model.normalizeToArray)(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  (0, _util.each)((0, _model.normalizeToArray)(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nfunction installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    (0, _util.each)((0, _model.normalizeToArray)(params.seriesTransition), function (transOpt) {\n      (0, _util.each)((0, _model.normalizeToArray)(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][_Series.SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        (0, _util.each)((0, _model.normalizeToArray)(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        (0, _util.each)(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      (0, _util.each)(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[_Series.SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[_Series.SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedData.push(data);\n      }\n    }\n  });\n}","map":{"version":3,"names":["DATA_COUNT_THRESHOLD","getUniversalTransitionGlobalStore","makeInner","getGroupIdDimension","data","dimensions","i","length","dimInfo","getDimensionInfo","otherDims","itemGroupId","flattenDataDiffItems","list","items","each","seriesInfo","count","process","env","NODE_ENV","warn","indices","getIndices","groupDim","dataIndex","push","dim","divide","fadeInElement","newEl","newSeries","newIndex","traverse","el","Path","initProps","style","opacity","isFrom","removeEl","parent","computedTransform","getComputedTransform","setLocalTransform","remove","stopAnimation","isGroup","child","animateElementStyles","seriesModel","animationConfig","getAnimationConfig","Displayable","oldStyle","getOldStyle","animateFrom","isAllIdSame","oldDiffItems","newDiffItems","len","oldItem","newItem","getId","transitionBetween","oldList","newList","api","updateMorphingPathProps","from","to","rawFrom","rawTo","animationCfg","extend","findKeyDim","oldKeyDim","newKeyDim","hasMorphAnimation","createKeyGetter","isOld","onlyGetId","diffItem","dataGroupId","hostModel","get","keyDim","dimOrdinalMeta","ordinalMeta","key","name","categories","itemVal","getRawDataItem","groupId","useId","isElementStillInChart","getItemGraphicEl","id","updateOneToOne","oldIndex","oldEl","applyMorphAnimation","getPathList","DataDiffer","update","updateManyToOne","oldIndices","newData","oldElsList","filter","map","idx","updateOneToMany","newIndices","newElsList","newSeris","updateManyToMany","rawIdx","execute","_a","view","getViewOfSeriesModel","isAnimationEnabled","duration","group","animators","getSeriesTransitionKey","series","seriesKey","getModel","convertArraySeriesKeyToString","isArray","sort","join","getDivideShapeFromData","findTransitionSeriesBatches","globalStore","params","updateBatches","createHashMap","oldDataMap","oldDataMapForSplit","oldSeries","oldData","transitionKey","transitionKeyStr","set","checkTransitionSeriesKeyDuplicated","updatedSeries","isUniversalTransitionEnabled","getData","oldSeries_1","oldData_1","batch","querySeries","finder","found","seriesIndex","seriesId","transitionSeriesFromOpt","transitionOpt","normalizeToArray","dimension","installUniversalTransition","registers","registerUpdateLifecycle","ecMOdel","seriesTransition","transOpt","SERIES_UNIVERSAL_TRANSITION_PROP","ecModel","optionChanged","opt","updateBatches_1","keys","allSeries","getSeries","savedSeries","savedData"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/animation/universalTransition.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTrasition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\n\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n\n      var dataGroupId = data.hostModel && data.hostModel.get('dataGroupId'); // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n\n      var itemVal = data.getRawDataItem(dataIndex);\n\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, oldData);\n\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          data: oldData,\n          key: transitionKeyStr\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            divide: getDivideShapeFromData(oldData),\n            data: oldData\n          }],\n          newSeries: [{\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData) {\n              oldSeries_1.push({\n                divide: getDivideShapeFromData(oldData),\n                data: oldData\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedData.push(data);\n      }\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}