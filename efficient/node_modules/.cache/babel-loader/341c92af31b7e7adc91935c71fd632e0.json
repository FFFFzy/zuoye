{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BE_ORDINAL = void 0;\nexports.guessOrdinal = guessOrdinal;\nexports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;\nexports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;\nexports.queryDatasetUpstreamDatasetModels = queryDatasetUpstreamDatasetModels;\nexports.querySeriesUpstreamDatasetModel = querySeriesUpstreamDatasetModel;\nexports.resetSourceDefaulter = resetSourceDefaulter;\n\nvar _model = require(\"../../util/model.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _types = require(\"../../util/types.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// The result of `guessOrdinal`.\nvar BE_ORDINAL = {\n  Must: 1,\n  Might: 2,\n  Not: 3 // Other cases\n\n};\nexports.BE_ORDINAL = BE_ORDINAL;\nvar innerGlobalModel = (0, _model.makeInner)();\n/**\n * MUST be called before mergeOption of all series.\n */\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  innerGlobalModel(ecModel).datasetMap = (0, _util.createHashMap)();\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @return encode Never be `null/undefined`.\n */\n\n\nfunction makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = innerGlobalModel(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  (0, _util.each)(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {\n    var coordDimInfo = (0, _util.isObject)(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {\n      name: coordDimInfoLoose\n    };\n\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);\n    }\n\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  }); // TODO\n  // Auto detect first time axis and do arrangement.\n\n  (0, _util.each)(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.\n\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when mutiple series share one dimension\n      // category axis, series name should better use\n      // the other dimsion name. On the other hand, use\n      // both dimensions name.\n    } // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n      pushDim(encode[coordDimName], 0, count);\n      pushDim(encodeItemName, 0, count);\n    } // In category way, the other axis.\n    else {\n      var start = datasetRecord.categoryWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.categoryWayDim += count;\n    }\n  });\n\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @return encode Never be `null/undefined`.\n */\n\n\nfunction makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel) {\n    return encode;\n  }\n\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n\n  if (sourceFormat === _types.SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === _types.SOURCE_FORMAT_KEYED_COLUMNS) {\n    (0, _util.each)(dimensionsDefine, function (dim, idx) {\n      if (((0, _util.isObject)(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = []; // 5 is an experience value.\n\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n\n\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n\n  if (idxResult) {\n    encode.value = [idxResult.v]; // `potentialNameDimIndex` has highest priority.\n\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.\n    // So we dont set encodeLabel here.\n\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n\n  return encode;\n}\n/**\n * @return If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction querySeriesUpstreamDatasetModel(seriesModel) {\n  // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n  var thisData = seriesModel.get('data', true);\n\n  if (!thisData) {\n    return (0, _model.queryReferringComponents)(seriesModel.ecModel, 'dataset', {\n      index: seriesModel.get('datasetIndex', true),\n      id: seriesModel.get('datasetId', true)\n    }, _model.SINGLE_REFERRING).models[0];\n  }\n}\n/**\n * @return Always return an array event empty.\n */\n\n\nfunction queryDatasetUpstreamDatasetModels(datasetModel) {\n  // Only these attributes declared, we by defualt reference to `datasetIndex: 0`.\n  // Otherwise, no reference.\n  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {\n    return [];\n  }\n\n  return (0, _model.queryReferringComponents)(datasetModel.ecModel, 'dataset', {\n    index: datasetModel.get('fromDatasetIndex', true),\n    id: datasetModel.get('fromDatasetId', true)\n  }, _model.SINGLE_REFERRING).models;\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n// return {BE_ORDINAL}\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if ((0, _util.isTypedArray)(data)) {\n    return BE_ORDINAL.Not;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n  var dimType;\n\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n\n    if ((0, _util.isObject)(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if ((0, _util.isString)(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n\n  if (sourceFormat === _types.SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data;\n\n    if (seriesLayoutBy === _types.SERIES_LAYOUT_BY_ROW) {\n      var sample = dataArrayRows[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {\n        var row = dataArrayRows[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === _types.SOURCE_FORMAT_OBJECT_ROWS) {\n    var dataObjectRows = data;\n\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {\n      var item = dataObjectRows[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === _types.SOURCE_FORMAT_KEYED_COLUMNS) {\n    var dataKeyedColumns = data;\n\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    var sample = dataKeyedColumns[dimName];\n\n    if (!sample || (0, _util.isTypedArray)(sample)) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === _types.SOURCE_FORMAT_ORIGINAL) {\n    var dataOriginal = data;\n\n    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {\n      var item = dataOriginal[i];\n      var val = (0, _model.getDataItemValue)(item);\n\n      if (!(0, _util.isArray)(val)) {\n        return BE_ORDINAL.Not;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    var beStr = (0, _util.isString)(val); // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (val != null && isFinite(val) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n\n  return BE_ORDINAL.Not;\n}","map":{"version":3,"names":["BE_ORDINAL","Must","Might","Not","innerGlobalModel","makeInner","resetSourceDefaulter","ecModel","datasetMap","createHashMap","makeSeriesEncodeForAxisCoordSys","coordDimensions","seriesModel","source","encode","datasetModel","querySeriesUpstreamDatasetModel","encodeItemName","encodeSeriesName","key","uid","seriesLayoutBy","baseCategoryDimIndex","categoryWayValueDimStart","slice","each","coordDimInfoLoose","coordDimIdx","coordDimInfo","isObject","name","type","getDataDimCountOnCoordDim","datasetRecord","get","set","categoryWayDim","valueWayDim","coordDimName","count","start","pushDim","dimIdxArr","idxFrom","idxCount","i","push","dimsDef","length","itemName","seriesName","makeSeriesEncodeForNameBased","dimCount","sourceFormat","dimensionsDefine","potentialNameDimIndex","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","dim","idx","idxResult","idxRes0","idxRes1","guessRecords","len","Math","min","guessResult","doGuessOrdinal","data","startIndex","isPureNumber","v","n","fulfilled","value","nameDimIndex","thisData","queryReferringComponents","index","id","SINGLE_REFERRING","models","queryDatasetUpstreamDatasetModels","guessOrdinal","dimIndex","result","maxLoop","isTypedArray","dimName","dimType","dimDefItem","isString","SOURCE_FORMAT_ARRAY_ROWS","dataArrayRows","SERIES_LAYOUT_BY_ROW","sample","detectValue","row","dataObjectRows","item","dataKeyedColumns","SOURCE_FORMAT_ORIGINAL","dataOriginal","val","getDataItemValue","isArray","beStr","isFinite"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/helper/sourceHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner, getDataItemValue, queryReferringComponents, SINGLE_REFERRING } from '../../util/model.js';\nimport { createHashMap, each, isArray, isString, isObject, isTypedArray } from 'zrender/lib/core/util.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS, SERIES_LAYOUT_BY_ROW, SOURCE_FORMAT_KEYED_COLUMNS } from '../../util/types.js'; // The result of `guessOrdinal`.\n\nexport var BE_ORDINAL = {\n  Must: 1,\n  Might: 2,\n  Not: 3 // Other cases\n\n};\nvar innerGlobalModel = makeInner();\n/**\n * MUST be called before mergeOption of all series.\n */\n\nexport function resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  innerGlobalModel(ecModel).datasetMap = createHashMap();\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @return encode Never be `null/undefined`.\n */\n\nexport function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = innerGlobalModel(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  each(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {\n    var coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {\n      name: coordDimInfoLoose\n    };\n\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);\n    }\n\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  }); // TODO\n  // Auto detect first time axis and do arrangement.\n\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.\n\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when mutiple series share one dimension\n      // category axis, series name should better use\n      // the other dimsion name. On the other hand, use\n      // both dimensions name.\n    } // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n        pushDim(encode[coordDimName], 0, count);\n        pushDim(encodeItemName, 0, count);\n      } // In category way, the other axis.\n      else {\n          var start = datasetRecord.categoryWayDim;\n          pushDim(encode[coordDimName], start, count);\n          pushDim(encodeSeriesName, start, count);\n          datasetRecord.categoryWayDim += count;\n        }\n  });\n\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @return encode Never be `null/undefined`.\n */\n\nexport function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.\n\n  if (!datasetModel) {\n    return encode;\n  }\n\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n\n  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = []; // 5 is an experience value.\n\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n\n\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n\n  if (idxResult) {\n    encode.value = [idxResult.v]; // `potentialNameDimIndex` has highest priority.\n\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.\n    // So we dont set encodeLabel here.\n\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n\n  return encode;\n}\n/**\n * @return If return null/undefined, indicate that should not use datasetModel.\n */\n\nexport function querySeriesUpstreamDatasetModel(seriesModel) {\n  // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n  var thisData = seriesModel.get('data', true);\n\n  if (!thisData) {\n    return queryReferringComponents(seriesModel.ecModel, 'dataset', {\n      index: seriesModel.get('datasetIndex', true),\n      id: seriesModel.get('datasetId', true)\n    }, SINGLE_REFERRING).models[0];\n  }\n}\n/**\n * @return Always return an array event empty.\n */\n\nexport function queryDatasetUpstreamDatasetModels(datasetModel) {\n  // Only these attributes declared, we by defualt reference to `datasetIndex: 0`.\n  // Otherwise, no reference.\n  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {\n    return [];\n  }\n\n  return queryReferringComponents(datasetModel.ecModel, 'dataset', {\n    index: datasetModel.get('fromDatasetIndex', true),\n    id: datasetModel.get('fromDatasetId', true)\n  }, SINGLE_REFERRING).models;\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n */\n\nexport function guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n// return {BE_ORDINAL}\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return BE_ORDINAL.Not;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n  var dimType;\n\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n\n    if (isObject(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if (isString(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data;\n\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = dataArrayRows[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {\n        var row = dataArrayRows[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var dataObjectRows = data;\n\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {\n      var item = dataObjectRows[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    var dataKeyedColumns = data;\n\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n\n    var sample = dataKeyedColumns[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return BE_ORDINAL.Not;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var dataOriginal = data;\n\n    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {\n      var item = dataOriginal[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return BE_ORDINAL.Not;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    var beStr = isString(val); // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (val != null && isFinite(val) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n\n  return BE_ORDINAL.Not;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}