{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultDataProvider = void 0;\nexports.getRawSourceDataCounter = getRawSourceDataCounter;\nexports.getRawSourceItemGetter = getRawSourceItemGetter;\nexports.getRawSourceValueGetter = getRawSourceValueGetter;\nexports.retrieveRawAttr = retrieveRawAttr;\nexports.retrieveRawValue = retrieveRawValue;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _model = require(\"../../util/model.js\");\n\nvar _Source = require(\"../Source.js\");\n\nvar _types = require(\"../../util/types.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !(0, _Source.isSourceInstance)(sourceParam) ? (0, _Source.createSourceFromSeriesDataOption)(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === _types.SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _util.assert)(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      (0, _util.extend)(provider, methods);\n\n      if (sourceFormat === _types.SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = (0, _util.bind)(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = (0, _util.bind)(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[_types.SOURCE_FORMAT_ARRAY_ROWS + '_' + _types.SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[_types.SOURCE_FORMAT_ARRAY_ROWS + '_' + _types.SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[_types.SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[_types.SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        (0, _util.each)(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[_types.SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[_types.SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          (0, _util.assert)((0, _util.isTypedArray)(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexports.DefaultDataProvider = DefaultDataProvider;\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[_types.SOURCE_FORMAT_ARRAY_ROWS + '_' + _types.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[_types.SOURCE_FORMAT_ARRAY_ROWS + '_' + _types.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[_types.SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[_types.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[_types.SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\n\nfunction getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _util.assert)(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[_types.SOURCE_FORMAT_ARRAY_ROWS + '_' + _types.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[_types.SOURCE_FORMAT_ARRAY_ROWS + '_' + _types.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[_types.SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[_types.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[_types.SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\n\nfunction getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _util.assert)(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[_types.SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[_types.SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[_types.SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[_types.SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = (0, _model.getDataItemValue)(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[_types.SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\n\nfunction getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _util.assert)(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === _types.SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nfunction retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === _types.SOURCE_FORMAT_ORIGINAL) {\n      result = (0, _model.getDataItemValue)(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\n\nfunction retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== _types.SOURCE_FORMAT_ORIGINAL && sourceFormat !== _types.SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === _types.SOURCE_FORMAT_ORIGINAL && !(0, _util.isObject)(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}","map":{"version":3,"names":["_a","_b","_c","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","source","isSourceInstance","createSourceFromSeriesDataOption","_source","data","_data","sourceFormat","SOURCE_FORMAT_TYPED_ARRAY","process","env","NODE_ENV","Error","_offset","_dimSize","prototype","getSource","count","getItem","idx","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","seriesLayoutBy","startIndex","dimsDef","dimensionsDefine","methods","getMethodMapKey","assert","extend","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","bind","rawCounter","getRawSourceDataCounter","offset","i","start","end","storage","extent","dim","dimExtent","min","Infinity","max","arr","val","length","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","appendDataSimply","SERIES_LAYOUT_BY_ROW","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","each","newCol","key","oldCol","push","SOURCE_FORMAT_ORIGINAL","isTypedArray","getItemSimply","rawData","rawSourceItemGetterMap","item","row","dimName","name","col","method","countSimply","rawSourceDataCounterMap","Math","getRawValueSimply","dataItem","dimIndex","property","rawSourceValueGetterMap","value","getDataItemValue","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","store","getStore","getDimensionIndex","getDimensionProperty","result","retrieveRawAttr","attr","isObject"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/helper/dataProvider.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      extend(provider, methods);\n\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexport { DefaultDataProvider };\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nexport function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}