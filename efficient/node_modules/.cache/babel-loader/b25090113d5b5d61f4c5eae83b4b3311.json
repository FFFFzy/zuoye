{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar matrix = _interopRequireWildcard(require(\"zrender/lib/core/matrix.js\"));\n\nvar layoutUtil = _interopRequireWildcard(require(\"../../util/layout.js\"));\n\nvar axisHelper = _interopRequireWildcard(require(\"../../coord/axisHelper.js\"));\n\nvar _ParallelAxis = _interopRequireDefault(require(\"./ParallelAxis.js\"));\n\nvar graphic = _interopRequireWildcard(require(\"../../util/graphic.js\"));\n\nvar numberUtil = _interopRequireWildcard(require(\"../../util/number.js\"));\n\nvar _sliderMove = _interopRequireDefault(require(\"../../component/helper/sliderMove.js\"));\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Parallel Coordinates\n * <https://en.wikipedia.org/wiki/Parallel_coordinates>\n */\nvar each = zrUtil.each;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar round = numberUtil.round;\nvar PI = Math.PI;\n\nvar Parallel =\n/** @class */\nfunction () {\n  function Parallel(parallelModel, ecModel, api) {\n    this.type = 'parallel';\n    /**\n     * key: dimension\n     */\n\n    this._axesMap = zrUtil.createHashMap();\n    /**\n     * key: dimension\n     * value: {position: [], rotation, }\n     */\n\n    this._axesLayout = {};\n    this.dimensions = parallelModel.dimensions;\n    this._model = parallelModel;\n\n    this._init(parallelModel, ecModel, api);\n  }\n\n  Parallel.prototype._init = function (parallelModel, ecModel, api) {\n    var dimensions = parallelModel.dimensions;\n    var parallelAxisIndex = parallelModel.parallelAxisIndex;\n    each(dimensions, function (dim, idx) {\n      var axisIndex = parallelAxisIndex[idx];\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n\n      var axis = this._axesMap.set(dim, new _ParallelAxis.default(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));\n\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Injection\n\n      axisModel.axis = axis;\n      axis.model = axisModel;\n      axis.coordinateSystem = axisModel.coordinateSystem = this;\n    }, this);\n  };\n  /**\n   * Update axis scale after data processed\n   */\n\n\n  Parallel.prototype.update = function (ecModel, api) {\n    this._updateAxesFromSeries(this._model, ecModel);\n  };\n\n  Parallel.prototype.containPoint = function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n\n    var axisBase = layoutInfo.axisBase;\n    var layoutBase = layoutInfo.layoutBase;\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var pAxis = point[1 - pixelDimIndex];\n    var pLayout = point[pixelDimIndex];\n    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;\n  };\n\n  Parallel.prototype.getModel = function () {\n    return this._model;\n  };\n  /**\n   * Update properties from series\n   */\n\n\n  Parallel.prototype._updateAxesFromSeries = function (parallelModel, ecModel) {\n    ecModel.eachSeries(function (seriesModel) {\n      if (!parallelModel.contains(seriesModel, ecModel)) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      each(this.dimensions, function (dim) {\n        var axis = this._axesMap.get(dim);\n\n        axis.scale.unionExtentFromData(data, data.mapDimension(dim));\n        axisHelper.niceScaleExtent(axis.scale, axis.model);\n      }, this);\n    }, this);\n  };\n  /**\n   * Resize the parallel coordinate system.\n   */\n\n\n  Parallel.prototype.resize = function (parallelModel, api) {\n    this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n\n    this._layoutAxes();\n  };\n\n  Parallel.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Parallel.prototype._makeLayoutInfo = function () {\n    var parallelModel = this._model;\n    var rect = this._rect;\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n    var layout = parallelModel.get('layout');\n    var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n    var layoutLength = rect[wh[pixelDimIndex]];\n    var layoutExtent = [0, layoutLength];\n    var axisCount = this.dimensions.length;\n    var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);\n    var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n    var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],\n    // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),\n    // where collapsed axes should be overlapped.\n\n    var axisExpandWindow = parallelModel.get('axisExpandWindow');\n    var winSize;\n\n    if (!axisExpandWindow) {\n      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n      var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);\n      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    } else {\n      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    }\n\n    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small.\n\n    axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1].\n\n    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1]; // Pos in ec coordinates.\n\n    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n    return {\n      layout: layout,\n      pixelDimIndex: pixelDimIndex,\n      layoutBase: rect[xy[pixelDimIndex]],\n      layoutLength: layoutLength,\n      axisBase: rect[xy[1 - pixelDimIndex]],\n      axisLength: rect[wh[1 - pixelDimIndex]],\n      axisExpandable: axisExpandable,\n      axisExpandWidth: axisExpandWidth,\n      axisCollapseWidth: axisCollapseWidth,\n      axisExpandWindow: axisExpandWindow,\n      axisCount: axisCount,\n      winInnerIndices: winInnerIndices,\n      axisExpandWindow0Pos: axisExpandWindow0Pos\n    };\n  };\n\n  Parallel.prototype._layoutAxes = function () {\n    var rect = this._rect;\n    var axes = this._axesMap;\n    var dimensions = this.dimensions;\n\n    var layoutInfo = this._makeLayoutInfo();\n\n    var layout = layoutInfo.layout;\n    axes.each(function (axis) {\n      var axisExtent = [0, layoutInfo.axisLength];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n    });\n    each(dimensions, function (dim, idx) {\n      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);\n      var positionTable = {\n        horizontal: {\n          x: posInfo.position,\n          y: layoutInfo.axisLength\n        },\n        vertical: {\n          x: 0,\n          y: posInfo.position\n        }\n      };\n      var rotationTable = {\n        horizontal: PI / 2,\n        vertical: 0\n      };\n      var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];\n      var rotation = rotationTable[layout];\n      var transform = matrix.create();\n      matrix.rotate(transform, transform, rotation);\n      matrix.translate(transform, transform, position); // TODO\n      // tick layout info\n      // TODO\n      // update dimensions info based on axis order.\n\n      this._axesLayout[dim] = {\n        position: position,\n        rotation: rotation,\n        transform: transform,\n        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n        axisLabelShow: posInfo.axisLabelShow,\n        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n        tickDirection: 1,\n        labelDirection: 1\n      };\n    }, this);\n  };\n  /**\n   * Get axis by dim.\n   */\n\n\n  Parallel.prototype.getAxis = function (dim) {\n    return this._axesMap.get(dim);\n  };\n  /**\n   * Convert a dim value of a single item of series data to Point.\n   */\n\n\n  Parallel.prototype.dataToPoint = function (value, dim) {\n    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);\n  };\n  /**\n   * Travel data for one time, get activeState of each data item.\n   * @param start the start dataIndex that travel from.\n   * @param end the next dataIndex of the last dataIndex will be travel.\n   */\n\n\n  Parallel.prototype.eachActiveState = function (data, callback, start, end) {\n    start == null && (start = 0);\n    end == null && (end = data.count());\n    var axesMap = this._axesMap;\n    var dimensions = this.dimensions;\n    var dataDimensions = [];\n    var axisModels = [];\n    zrUtil.each(dimensions, function (axisDim) {\n      dataDimensions.push(data.mapDimension(axisDim));\n      axisModels.push(axesMap.get(axisDim).model);\n    });\n    var hasActiveSet = this.hasAxisBrushed();\n\n    for (var dataIndex = start; dataIndex < end; dataIndex++) {\n      var activeState = void 0;\n\n      if (!hasActiveSet) {\n        activeState = 'normal';\n      } else {\n        activeState = 'active';\n        var values = data.getValues(dataDimensions, dataIndex);\n\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n          var state = axisModels[j].getActiveState(values[j]);\n\n          if (state === 'inactive') {\n            activeState = 'inactive';\n            break;\n          }\n        }\n      }\n\n      callback(activeState, dataIndex);\n    }\n  };\n  /**\n   * Whether has any activeSet.\n   */\n\n\n  Parallel.prototype.hasAxisBrushed = function () {\n    var dimensions = this.dimensions;\n    var axesMap = this._axesMap;\n    var hasActiveSet = false;\n\n    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n      if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n        hasActiveSet = true;\n      }\n    }\n\n    return hasActiveSet;\n  };\n  /**\n   * Convert coords of each axis to Point.\n   *  Return point. For example: [10, 20]\n   */\n\n\n  Parallel.prototype.axisCoordToPoint = function (coord, dim) {\n    var axisLayout = this._axesLayout[dim];\n    return graphic.applyTransform([coord, 0], axisLayout.transform);\n  };\n  /**\n   * Get axis layout.\n   */\n\n\n  Parallel.prototype.getAxisLayout = function (dim) {\n    return zrUtil.clone(this._axesLayout[dim]);\n  };\n  /**\n   * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.\n   */\n\n\n  Parallel.prototype.getSlidedAxisExpandWindow = function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n    var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n    var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system.\n\n    if (!this.containPoint(point)) {\n      return {\n        behavior: 'none',\n        axisExpandWindow: axisExpandWindow\n      };\n    } // Conver the point from global to expand coordinates.\n\n\n    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be\n    // slided when mouse is the center area of the window.\n\n    var delta;\n    var behavior = 'slide';\n    var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n\n    var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary.\n\n\n    var useJump = triggerArea[0] != null;\n\n    if (axisCollapseWidth) {\n      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * triggerArea[2];\n      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * (1 - triggerArea[2]);\n      } else {\n        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);\n      }\n\n      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n      delta ? (0, _sliderMove.default)(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.\n      : behavior = 'none';\n    } // When screen is too narrow, make it visible and slidable, although it is hard to interact.\n    else {\n      var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];\n      var pos = extent[1] * pointCoord / winSize2;\n      axisExpandWindow = [mathMax(0, pos - winSize2 / 2)];\n      axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize2);\n      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;\n    }\n\n    return {\n      axisExpandWindow: axisExpandWindow,\n      behavior: behavior\n    };\n  };\n\n  return Parallel;\n}();\n\nfunction restrict(len, extent) {\n  return mathMin(mathMax(len, extent[0]), extent[1]);\n}\n\nfunction layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n  return {\n    position: step * axisIndex,\n    axisNameAvailableWidth: step,\n    axisLabelShow: true\n  };\n}\n\nfunction layoutAxisWithExpand(axisIndex, layoutInfo) {\n  var layoutLength = layoutInfo.layoutLength;\n  var axisExpandWidth = layoutInfo.axisExpandWidth;\n  var axisCount = layoutInfo.axisCount;\n  var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n  var winInnerIndices = layoutInfo.winInnerIndices;\n  var position;\n  var axisNameAvailableWidth = axisCollapseWidth;\n  var axisLabelShow = false;\n  var nameTruncateMaxWidth;\n\n  if (axisIndex < winInnerIndices[0]) {\n    position = axisIndex * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  } else if (axisIndex <= winInnerIndices[1]) {\n    position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n    axisNameAvailableWidth = axisExpandWidth;\n    axisLabelShow = true;\n  } else {\n    position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  }\n\n  return {\n    position: position,\n    axisNameAvailableWidth: axisNameAvailableWidth,\n    axisLabelShow: axisLabelShow,\n    nameTruncateMaxWidth: nameTruncateMaxWidth\n  };\n}\n\nvar _default = Parallel;\nexports.default = _default;","map":{"version":3,"names":["each","zrUtil","mathMin","Math","min","mathMax","max","mathFloor","floor","mathCeil","ceil","round","numberUtil","PI","Parallel","parallelModel","ecModel","api","type","_axesMap","createHashMap","_axesLayout","dimensions","_model","_init","prototype","parallelAxisIndex","dim","idx","axisIndex","axisModel","getComponent","axis","set","ParallelAxis","axisHelper","createScaleByModel","get","isCategory","onBand","inverse","model","coordinateSystem","update","_updateAxesFromSeries","containPoint","point","layoutInfo","_makeLayoutInfo","axisBase","layoutBase","pixelDimIndex","pAxis","pLayout","axisLength","layoutLength","getModel","eachSeries","seriesModel","contains","data","getData","scale","unionExtentFromData","mapDimension","niceScaleExtent","resize","_rect","layoutUtil","getLayoutRect","getBoxLayoutParams","width","getWidth","height","getHeight","_layoutAxes","getRect","rect","xy","wh","layout","layoutExtent","axisCount","length","axisExpandWidth","restrict","axisExpandCount","axisExpandable","axisExpandWindow","winSize","axisExpandCenter","axisCollapseWidth","winInnerIndices","axisExpandWindow0Pos","axes","axisExtent","setExtent","posInfo","layoutAxisWithExpand","layoutAxisWithoutExpand","positionTable","horizontal","x","position","y","vertical","rotationTable","rotation","transform","matrix","create","rotate","translate","axisNameAvailableWidth","axisLabelShow","nameTruncateMaxWidth","tickDirection","labelDirection","getAxis","dataToPoint","value","axisCoordToPoint","dataToCoord","eachActiveState","callback","start","end","count","axesMap","dataDimensions","axisModels","axisDim","push","hasActiveSet","hasAxisBrushed","dataIndex","activeState","values","getValues","j","lenj","state","getActiveState","coord","axisLayout","graphic","applyTransform","getAxisLayout","clone","getSlidedAxisExpandWindow","slice","extent","behavior","pointCoord","delta","triggerArea","useJump","sliderMove","winSize2","pos","len","step"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/coord/parallel/Parallel.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Parallel Coordinates\n * <https://en.wikipedia.org/wiki/Parallel_coordinates>\n */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport * as layoutUtil from '../../util/layout.js';\nimport * as axisHelper from '../../coord/axisHelper.js';\nimport ParallelAxis from './ParallelAxis.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as numberUtil from '../../util/number.js';\nimport sliderMove from '../../component/helper/sliderMove.js';\nvar each = zrUtil.each;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar round = numberUtil.round;\nvar PI = Math.PI;\n\nvar Parallel =\n/** @class */\nfunction () {\n  function Parallel(parallelModel, ecModel, api) {\n    this.type = 'parallel';\n    /**\n     * key: dimension\n     */\n\n    this._axesMap = zrUtil.createHashMap();\n    /**\n     * key: dimension\n     * value: {position: [], rotation, }\n     */\n\n    this._axesLayout = {};\n    this.dimensions = parallelModel.dimensions;\n    this._model = parallelModel;\n\n    this._init(parallelModel, ecModel, api);\n  }\n\n  Parallel.prototype._init = function (parallelModel, ecModel, api) {\n    var dimensions = parallelModel.dimensions;\n    var parallelAxisIndex = parallelModel.parallelAxisIndex;\n    each(dimensions, function (dim, idx) {\n      var axisIndex = parallelAxisIndex[idx];\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n\n      var axis = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));\n\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Injection\n\n      axisModel.axis = axis;\n      axis.model = axisModel;\n      axis.coordinateSystem = axisModel.coordinateSystem = this;\n    }, this);\n  };\n  /**\n   * Update axis scale after data processed\n   */\n\n\n  Parallel.prototype.update = function (ecModel, api) {\n    this._updateAxesFromSeries(this._model, ecModel);\n  };\n\n  Parallel.prototype.containPoint = function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n\n    var axisBase = layoutInfo.axisBase;\n    var layoutBase = layoutInfo.layoutBase;\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var pAxis = point[1 - pixelDimIndex];\n    var pLayout = point[pixelDimIndex];\n    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;\n  };\n\n  Parallel.prototype.getModel = function () {\n    return this._model;\n  };\n  /**\n   * Update properties from series\n   */\n\n\n  Parallel.prototype._updateAxesFromSeries = function (parallelModel, ecModel) {\n    ecModel.eachSeries(function (seriesModel) {\n      if (!parallelModel.contains(seriesModel, ecModel)) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      each(this.dimensions, function (dim) {\n        var axis = this._axesMap.get(dim);\n\n        axis.scale.unionExtentFromData(data, data.mapDimension(dim));\n        axisHelper.niceScaleExtent(axis.scale, axis.model);\n      }, this);\n    }, this);\n  };\n  /**\n   * Resize the parallel coordinate system.\n   */\n\n\n  Parallel.prototype.resize = function (parallelModel, api) {\n    this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n\n    this._layoutAxes();\n  };\n\n  Parallel.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Parallel.prototype._makeLayoutInfo = function () {\n    var parallelModel = this._model;\n    var rect = this._rect;\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n    var layout = parallelModel.get('layout');\n    var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n    var layoutLength = rect[wh[pixelDimIndex]];\n    var layoutExtent = [0, layoutLength];\n    var axisCount = this.dimensions.length;\n    var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);\n    var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n    var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],\n    // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),\n    // where collapsed axes should be overlapped.\n\n    var axisExpandWindow = parallelModel.get('axisExpandWindow');\n    var winSize;\n\n    if (!axisExpandWindow) {\n      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n      var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);\n      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    } else {\n      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    }\n\n    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small.\n\n    axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1].\n\n    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1]; // Pos in ec coordinates.\n\n    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n    return {\n      layout: layout,\n      pixelDimIndex: pixelDimIndex,\n      layoutBase: rect[xy[pixelDimIndex]],\n      layoutLength: layoutLength,\n      axisBase: rect[xy[1 - pixelDimIndex]],\n      axisLength: rect[wh[1 - pixelDimIndex]],\n      axisExpandable: axisExpandable,\n      axisExpandWidth: axisExpandWidth,\n      axisCollapseWidth: axisCollapseWidth,\n      axisExpandWindow: axisExpandWindow,\n      axisCount: axisCount,\n      winInnerIndices: winInnerIndices,\n      axisExpandWindow0Pos: axisExpandWindow0Pos\n    };\n  };\n\n  Parallel.prototype._layoutAxes = function () {\n    var rect = this._rect;\n    var axes = this._axesMap;\n    var dimensions = this.dimensions;\n\n    var layoutInfo = this._makeLayoutInfo();\n\n    var layout = layoutInfo.layout;\n    axes.each(function (axis) {\n      var axisExtent = [0, layoutInfo.axisLength];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n    });\n    each(dimensions, function (dim, idx) {\n      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);\n      var positionTable = {\n        horizontal: {\n          x: posInfo.position,\n          y: layoutInfo.axisLength\n        },\n        vertical: {\n          x: 0,\n          y: posInfo.position\n        }\n      };\n      var rotationTable = {\n        horizontal: PI / 2,\n        vertical: 0\n      };\n      var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];\n      var rotation = rotationTable[layout];\n      var transform = matrix.create();\n      matrix.rotate(transform, transform, rotation);\n      matrix.translate(transform, transform, position); // TODO\n      // tick layout info\n      // TODO\n      // update dimensions info based on axis order.\n\n      this._axesLayout[dim] = {\n        position: position,\n        rotation: rotation,\n        transform: transform,\n        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n        axisLabelShow: posInfo.axisLabelShow,\n        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n        tickDirection: 1,\n        labelDirection: 1\n      };\n    }, this);\n  };\n  /**\n   * Get axis by dim.\n   */\n\n\n  Parallel.prototype.getAxis = function (dim) {\n    return this._axesMap.get(dim);\n  };\n  /**\n   * Convert a dim value of a single item of series data to Point.\n   */\n\n\n  Parallel.prototype.dataToPoint = function (value, dim) {\n    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);\n  };\n  /**\n   * Travel data for one time, get activeState of each data item.\n   * @param start the start dataIndex that travel from.\n   * @param end the next dataIndex of the last dataIndex will be travel.\n   */\n\n\n  Parallel.prototype.eachActiveState = function (data, callback, start, end) {\n    start == null && (start = 0);\n    end == null && (end = data.count());\n    var axesMap = this._axesMap;\n    var dimensions = this.dimensions;\n    var dataDimensions = [];\n    var axisModels = [];\n    zrUtil.each(dimensions, function (axisDim) {\n      dataDimensions.push(data.mapDimension(axisDim));\n      axisModels.push(axesMap.get(axisDim).model);\n    });\n    var hasActiveSet = this.hasAxisBrushed();\n\n    for (var dataIndex = start; dataIndex < end; dataIndex++) {\n      var activeState = void 0;\n\n      if (!hasActiveSet) {\n        activeState = 'normal';\n      } else {\n        activeState = 'active';\n        var values = data.getValues(dataDimensions, dataIndex);\n\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n          var state = axisModels[j].getActiveState(values[j]);\n\n          if (state === 'inactive') {\n            activeState = 'inactive';\n            break;\n          }\n        }\n      }\n\n      callback(activeState, dataIndex);\n    }\n  };\n  /**\n   * Whether has any activeSet.\n   */\n\n\n  Parallel.prototype.hasAxisBrushed = function () {\n    var dimensions = this.dimensions;\n    var axesMap = this._axesMap;\n    var hasActiveSet = false;\n\n    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n      if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n        hasActiveSet = true;\n      }\n    }\n\n    return hasActiveSet;\n  };\n  /**\n   * Convert coords of each axis to Point.\n   *  Return point. For example: [10, 20]\n   */\n\n\n  Parallel.prototype.axisCoordToPoint = function (coord, dim) {\n    var axisLayout = this._axesLayout[dim];\n    return graphic.applyTransform([coord, 0], axisLayout.transform);\n  };\n  /**\n   * Get axis layout.\n   */\n\n\n  Parallel.prototype.getAxisLayout = function (dim) {\n    return zrUtil.clone(this._axesLayout[dim]);\n  };\n  /**\n   * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.\n   */\n\n\n  Parallel.prototype.getSlidedAxisExpandWindow = function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n    var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n    var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system.\n\n    if (!this.containPoint(point)) {\n      return {\n        behavior: 'none',\n        axisExpandWindow: axisExpandWindow\n      };\n    } // Conver the point from global to expand coordinates.\n\n\n    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be\n    // slided when mouse is the center area of the window.\n\n    var delta;\n    var behavior = 'slide';\n    var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n\n    var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary.\n\n\n    var useJump = triggerArea[0] != null;\n\n    if (axisCollapseWidth) {\n      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * triggerArea[2];\n      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * (1 - triggerArea[2]);\n      } else {\n        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);\n      }\n\n      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n      delta ? sliderMove(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.\n      : behavior = 'none';\n    } // When screen is too narrow, make it visible and slidable, although it is hard to interact.\n    else {\n        var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];\n        var pos = extent[1] * pointCoord / winSize2;\n        axisExpandWindow = [mathMax(0, pos - winSize2 / 2)];\n        axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize2);\n        axisExpandWindow[0] = axisExpandWindow[1] - winSize2;\n      }\n\n    return {\n      axisExpandWindow: axisExpandWindow,\n      behavior: behavior\n    };\n  };\n\n  return Parallel;\n}();\n\nfunction restrict(len, extent) {\n  return mathMin(mathMax(len, extent[0]), extent[1]);\n}\n\nfunction layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n  return {\n    position: step * axisIndex,\n    axisNameAvailableWidth: step,\n    axisLabelShow: true\n  };\n}\n\nfunction layoutAxisWithExpand(axisIndex, layoutInfo) {\n  var layoutLength = layoutInfo.layoutLength;\n  var axisExpandWidth = layoutInfo.axisExpandWidth;\n  var axisCount = layoutInfo.axisCount;\n  var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n  var winInnerIndices = layoutInfo.winInnerIndices;\n  var position;\n  var axisNameAvailableWidth = axisCollapseWidth;\n  var axisLabelShow = false;\n  var nameTruncateMaxWidth;\n\n  if (axisIndex < winInnerIndices[0]) {\n    position = axisIndex * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  } else if (axisIndex <= winInnerIndices[1]) {\n    position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n    axisNameAvailableWidth = axisExpandWidth;\n    axisLabelShow = true;\n  } else {\n    position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  }\n\n  return {\n    position: position,\n    axisNameAvailableWidth: axisNameAvailableWidth,\n    axisLabelShow: axisLabelShow,\n    nameTruncateMaxWidth: nameTruncateMaxWidth\n  };\n}\n\nexport default Parallel;"],"mappings":"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"},"metadata":{},"sourceType":"script"}