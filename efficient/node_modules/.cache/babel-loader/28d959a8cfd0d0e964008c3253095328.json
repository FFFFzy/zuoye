{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CtorUint32Array = exports.CtorUint16Array = exports.CtorInt32Array = exports.CtorFloat64Array = void 0;\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last-index.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _dataValueHelper = require(\"./helper/dataValueHelper.js\");\n\nvar _Source = require(\"./Source.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexports.CtorUint32Array = CtorUint32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexports.CtorUint16Array = CtorUint16Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexports.CtorInt32Array = CtorInt32Array;\nvar CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nexports.CtorFloat64Array = CtorFloat64Array;\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated util needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = (0, _util.createHashMap)();\n  }\n  /**\n   * Initialize from data\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)((0, _util.isFunction)(provider.getItem) && (0, _util.isFunction)(provider.count), 'Invalid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = (0, _Source.shouldRetrieveDataByName)(source);\n    this._dimensions = (0, _util.map)(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          (0, _util.assert)(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = (0, _util.map)(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = (0, _util.keys)(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          countNaN++;\n\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && (0, _util.reduce)(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = (0, _util.clone)(this._extent);\n    target._rawExtent = (0, _util.clone)(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return (0, _dataValueHelper.parseDataValue)(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return (0, _dataValueHelper.parseDataValue)(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return (0, _dataValueHelper.parseDataValue)(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nvar _default = DataStore;\nexports.default = _default;","map":{"version":3,"names":["UNDEFINED","CtorUint32Array","Uint32Array","Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","defaultDimValueGetters","getIndicesCtor","rawCount","getInitialExtent","Infinity","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","length","newStore","j","DataStore","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","createHashMap","prototype","initData","provider","inputDimensions","dimValueGetter","process","env","NODE_ENV","assert","isFunction","getItem","count","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","willRetrieveDataByName","shouldRetrieveDataByName","_dimensions","map","dim","property","type","_initDataFromProvider","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","i","val","parseAndCollect","isNaN","Math","min","max","getOrdinalMeta","dimInfo","getDimensionProperty","dimIndex","item","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","push","getByRawIndex","rawIdx","getSum","dimData","sum","value","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","clone","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","keys","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","targetStorage","sampledIndex","frameSize","floor","currentRawIndex","maxArea","area","nextRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","firstNaNIndex","countNaN","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","currEnd","useRaw","dimExtent","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","reduce","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","parseDataValue","objectRows","keyedColumns","original","typedArray"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/DataStore.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated util needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = keys(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          countNaN++;\n\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nexport default DataStore;"],"mappings":"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"},"metadata":{},"sourceType":"script"}