{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.split = split;\n\nvar _bbox = require(\"../core/bbox.js\");\n\nvar _BoundingRect = _interopRequireDefault(require(\"../core/BoundingRect.js\"));\n\nvar _Point = _interopRequireDefault(require(\"../core/Point.js\"));\n\nvar _util = require(\"../core/util.js\");\n\nvar _Polygon = _interopRequireDefault(require(\"../graphic/shape/Polygon.js\"));\n\nvar _Rect = _interopRequireDefault(require(\"../graphic/shape/Rect.js\"));\n\nvar _Sector = _interopRequireDefault(require(\"../graphic/shape/Sector.js\"));\n\nvar _convertPath = require(\"./convertPath.js\");\n\nvar _path = require(\"./path.js\");\n\nfunction getDividingGrids(dimSize, rowDim, count) {\n  var rowSize = dimSize[rowDim];\n  var columnSize = dimSize[1 - rowDim];\n  var ratio = Math.abs(rowSize / columnSize);\n  var rowCount = Math.ceil(Math.sqrt(ratio * count));\n  var columnCount = Math.floor(count / rowCount);\n\n  if (columnCount === 0) {\n    columnCount = 1;\n    rowCount = count;\n  }\n\n  var grids = [];\n\n  for (var i = 0; i < rowCount; i++) {\n    grids.push(columnCount);\n  }\n\n  var currentCount = rowCount * columnCount;\n  var remained = count - currentCount;\n\n  if (remained > 0) {\n    for (var i = 0; i < remained; i++) {\n      grids[i % rowCount] += 1;\n    }\n  }\n\n  return grids;\n}\n\nfunction divideSector(sectorShape, count, outShapes) {\n  var r0 = sectorShape.r0;\n  var r = sectorShape.r;\n  var startAngle = sectorShape.startAngle;\n  var endAngle = sectorShape.endAngle;\n  var angle = Math.abs(endAngle - startAngle);\n  var arcLen = angle * r;\n  var deltaR = r - r0;\n  var isAngleRow = arcLen > Math.abs(deltaR);\n  var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n  var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n\n  for (var row = 0; row < grids.length; row++) {\n    var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n\n    for (var column = 0; column < grids[row]; column++) {\n      var newShape = {};\n\n      if (isAngleRow) {\n        newShape.startAngle = startAngle + rowSize * row;\n        newShape.endAngle = startAngle + rowSize * (row + 1);\n        newShape.r0 = r0 + columnSize * column;\n        newShape.r = r0 + columnSize * (column + 1);\n      } else {\n        newShape.startAngle = startAngle + columnSize * column;\n        newShape.endAngle = startAngle + columnSize * (column + 1);\n        newShape.r0 = r0 + rowSize * row;\n        newShape.r = r0 + rowSize * (row + 1);\n      }\n\n      newShape.clockwise = sectorShape.clockwise;\n      newShape.cx = sectorShape.cx;\n      newShape.cy = sectorShape.cy;\n      outShapes.push(newShape);\n    }\n  }\n}\n\nfunction divideRect(rectShape, count, outShapes) {\n  var width = rectShape.width;\n  var height = rectShape.height;\n  var isHorizontalRow = width > height;\n  var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n  var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n  var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n  var rowDim = isHorizontalRow ? 'x' : 'y';\n  var columnDim = isHorizontalRow ? 'y' : 'x';\n  var rowSize = rectShape[rowSizeDim] / grids.length;\n\n  for (var row = 0; row < grids.length; row++) {\n    var columnSize = rectShape[columnSizeDim] / grids[row];\n\n    for (var column = 0; column < grids[row]; column++) {\n      var newShape = {};\n      newShape[rowDim] = row * rowSize;\n      newShape[columnDim] = column * columnSize;\n      newShape[rowSizeDim] = rowSize;\n      newShape[columnSizeDim] = columnSize;\n      newShape.x += rectShape.x;\n      newShape.y += rectShape.y;\n      outShapes.push(newShape);\n    }\n  }\n}\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y;\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (Math.abs(nmCrossProduct) < 1e-6) {\n    return null;\n  }\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return null;\n  }\n\n  return new _Point.default(p * mx + a1x, p * my + a1y);\n}\n\nfunction projPtOnLine(pt, lineA, lineB) {\n  var dir = new _Point.default();\n\n  _Point.default.sub(dir, lineB, lineA);\n\n  dir.normalize();\n  var dir2 = new _Point.default();\n\n  _Point.default.sub(dir2, pt, lineA);\n\n  var len = dir2.dot(dir);\n  return len;\n}\n\nfunction addToPoly(poly, pt) {\n  var last = poly[poly.length - 1];\n\n  if (last && last[0] === pt[0] && last[1] === pt[1]) {\n    return;\n  }\n\n  poly.push(pt);\n}\n\nfunction splitPolygonByLine(points, lineA, lineB) {\n  var len = points.length;\n  var intersections = [];\n\n  for (var i = 0; i < len; i++) {\n    var p0 = points[i];\n    var p1 = points[(i + 1) % len];\n    var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n\n    if (intersectionPt) {\n      intersections.push({\n        projPt: projPtOnLine(intersectionPt, lineA, lineB),\n        pt: intersectionPt,\n        idx: i\n      });\n    }\n  }\n\n  if (intersections.length < 2) {\n    return [{\n      points: points\n    }, {\n      points: points\n    }];\n  }\n\n  intersections.sort(function (a, b) {\n    return a.projPt - b.projPt;\n  });\n  var splitPt0 = intersections[0];\n  var splitPt1 = intersections[intersections.length - 1];\n\n  if (splitPt1.idx < splitPt0.idx) {\n    var tmp = splitPt0;\n    splitPt0 = splitPt1;\n    splitPt1 = tmp;\n  }\n\n  var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n  var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n  var newPolyA = [splitPt0Arr];\n  var newPolyB = [splitPt1Arr];\n\n  for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n    addToPoly(newPolyA, points[i].slice());\n  }\n\n  addToPoly(newPolyA, splitPt1Arr);\n  addToPoly(newPolyA, splitPt0Arr);\n\n  for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n    addToPoly(newPolyB, points[i % len].slice());\n  }\n\n  addToPoly(newPolyB, splitPt0Arr);\n  addToPoly(newPolyB, splitPt1Arr);\n  return [{\n    points: newPolyA\n  }, {\n    points: newPolyB\n  }];\n}\n\nfunction binaryDividePolygon(polygonShape) {\n  var points = polygonShape.points;\n  var min = [];\n  var max = [];\n  (0, _bbox.fromPoints)(points, min, max);\n  var boundingRect = new _BoundingRect.default(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  var width = boundingRect.width;\n  var height = boundingRect.height;\n  var x = boundingRect.x;\n  var y = boundingRect.y;\n  var pt0 = new _Point.default();\n  var pt1 = new _Point.default();\n\n  if (width > height) {\n    pt0.x = pt1.x = x + width / 2;\n    pt0.y = y;\n    pt1.y = y + height;\n  } else {\n    pt0.y = pt1.y = y + height / 2;\n    pt0.x = x;\n    pt1.x = x + width;\n  }\n\n  return splitPolygonByLine(points, pt0, pt1);\n}\n\nfunction binaryDivideRecursive(divider, shape, count, out) {\n  if (count === 1) {\n    out.push(shape);\n  } else {\n    var mid = Math.floor(count / 2);\n    var sub = divider(shape);\n    binaryDivideRecursive(divider, sub[0], mid, out);\n    binaryDivideRecursive(divider, sub[1], count - mid, out);\n  }\n\n  return out;\n}\n\nfunction clone(path, count) {\n  var paths = [];\n\n  for (var i = 0; i < count; i++) {\n    paths.push((0, _path.clonePath)(path));\n  }\n\n  return paths;\n}\n\nfunction copyPathProps(source, target) {\n  target.setStyle(source.style);\n  target.z = source.z;\n  target.z2 = source.z2;\n  target.zlevel = source.zlevel;\n}\n\nfunction polygonConvert(points) {\n  var out = [];\n\n  for (var i = 0; i < points.length;) {\n    out.push([points[i++], points[i++]]);\n  }\n\n  return out;\n}\n\nfunction split(path, count) {\n  var outShapes = [];\n  var shape = path.shape;\n  var OutShapeCtor;\n\n  switch (path.type) {\n    case 'rect':\n      divideRect(shape, count, outShapes);\n      OutShapeCtor = _Rect.default;\n      break;\n\n    case 'sector':\n      divideSector(shape, count, outShapes);\n      OutShapeCtor = _Sector.default;\n      break;\n\n    case 'circle':\n      divideSector({\n        r0: 0,\n        r: shape.r,\n        startAngle: 0,\n        endAngle: Math.PI * 2,\n        cx: shape.cx,\n        cy: shape.cy\n      }, count, outShapes);\n      OutShapeCtor = _Sector.default;\n      break;\n\n    default:\n      var m = path.getComputedTransform();\n      var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n      var polygons = (0, _util.map)((0, _convertPath.pathToPolygons)(path.getUpdatedPathProxy(), scale), function (poly) {\n        return polygonConvert(poly);\n      });\n      var polygonCount = polygons.length;\n\n      if (polygonCount === 0) {\n        binaryDivideRecursive(binaryDividePolygon, {\n          points: polygons[0]\n        }, count, outShapes);\n      } else if (polygonCount === count) {\n        for (var i = 0; i < polygonCount; i++) {\n          outShapes.push({\n            points: polygons[i]\n          });\n        }\n      } else {\n        var totalArea_1 = 0;\n        var items = (0, _util.map)(polygons, function (poly) {\n          var min = [];\n          var max = [];\n          (0, _bbox.fromPoints)(poly, min, max);\n          var area = (max[1] - min[1]) * (max[0] - min[0]);\n          totalArea_1 += area;\n          return {\n            poly: poly,\n            area: area\n          };\n        });\n        items.sort(function (a, b) {\n          return b.area - a.area;\n        });\n        var left = count;\n\n        for (var i = 0; i < polygonCount; i++) {\n          var item = items[i];\n\n          if (left <= 0) {\n            break;\n          }\n\n          var selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count);\n\n          if (selfCount < 0) {\n            continue;\n          }\n\n          binaryDivideRecursive(binaryDividePolygon, {\n            points: item.poly\n          }, selfCount, outShapes);\n          left -= selfCount;\n        }\n\n        ;\n      }\n\n      OutShapeCtor = _Polygon.default;\n      break;\n  }\n\n  if (!OutShapeCtor) {\n    return clone(path, count);\n  }\n\n  var out = [];\n\n  for (var i = 0; i < outShapes.length; i++) {\n    var subPath = new OutShapeCtor();\n    subPath.setShape(outShapes[i]);\n    copyPathProps(path, subPath);\n    out.push(subPath);\n  }\n\n  return out;\n}","map":{"version":3,"names":["getDividingGrids","dimSize","rowDim","count","rowSize","columnSize","ratio","Math","abs","rowCount","ceil","sqrt","columnCount","floor","grids","i","push","currentCount","remained","divideSector","sectorShape","outShapes","r0","r","startAngle","endAngle","angle","arcLen","deltaR","isAngleRow","length","row","column","newShape","clockwise","cx","cy","divideRect","rectShape","width","height","isHorizontalRow","rowSizeDim","columnSizeDim","columnDim","x","y","crossProduct2d","x1","y1","x2","y2","lineLineIntersect","a1x","a1y","a2x","a2y","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","b1a1x","b1a1y","p","Point","projPtOnLine","pt","lineA","lineB","dir","sub","normalize","dir2","len","dot","addToPoly","poly","last","splitPolygonByLine","points","intersections","p0","p1","intersectionPt","projPt","idx","sort","a","b","splitPt0","splitPt1","tmp","splitPt0Arr","splitPt1Arr","newPolyA","newPolyB","slice","binaryDividePolygon","polygonShape","min","max","fromPoints","boundingRect","BoundingRect","pt0","pt1","binaryDivideRecursive","divider","shape","out","mid","clone","path","paths","clonePath","copyPathProps","source","target","setStyle","style","z","z2","zlevel","polygonConvert","split","OutShapeCtor","type","Rect","Sector","PI","m","getComputedTransform","scale","polygons","map","pathToPolygons","getUpdatedPathProxy","polygonCount","totalArea_1","items","area","left","item","selfCount","Polygon","subPath","setShape"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/zrender/lib/tool/dividePath.js"],"sourcesContent":["import { fromPoints } from '../core/bbox.js';\nimport BoundingRect from '../core/BoundingRect.js';\nimport Point from '../core/Point.js';\nimport { map } from '../core/util.js';\nimport Polygon from '../graphic/shape/Polygon.js';\nimport Rect from '../graphic/shape/Rect.js';\nimport Sector from '../graphic/shape/Sector.js';\nimport { pathToPolygons } from './convertPath.js';\nimport { clonePath } from './path.js';\nfunction getDividingGrids(dimSize, rowDim, count) {\n    var rowSize = dimSize[rowDim];\n    var columnSize = dimSize[1 - rowDim];\n    var ratio = Math.abs(rowSize / columnSize);\n    var rowCount = Math.ceil(Math.sqrt(ratio * count));\n    var columnCount = Math.floor(count / rowCount);\n    if (columnCount === 0) {\n        columnCount = 1;\n        rowCount = count;\n    }\n    var grids = [];\n    for (var i = 0; i < rowCount; i++) {\n        grids.push(columnCount);\n    }\n    var currentCount = rowCount * columnCount;\n    var remained = count - currentCount;\n    if (remained > 0) {\n        for (var i = 0; i < remained; i++) {\n            grids[i % rowCount] += 1;\n        }\n    }\n    return grids;\n}\nfunction divideSector(sectorShape, count, outShapes) {\n    var r0 = sectorShape.r0;\n    var r = sectorShape.r;\n    var startAngle = sectorShape.startAngle;\n    var endAngle = sectorShape.endAngle;\n    var angle = Math.abs(endAngle - startAngle);\n    var arcLen = angle * r;\n    var deltaR = r - r0;\n    var isAngleRow = arcLen > Math.abs(deltaR);\n    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            if (isAngleRow) {\n                newShape.startAngle = startAngle + rowSize * row;\n                newShape.endAngle = startAngle + rowSize * (row + 1);\n                newShape.r0 = r0 + columnSize * column;\n                newShape.r = r0 + columnSize * (column + 1);\n            }\n            else {\n                newShape.startAngle = startAngle + columnSize * column;\n                newShape.endAngle = startAngle + columnSize * (column + 1);\n                newShape.r0 = r0 + rowSize * row;\n                newShape.r = r0 + rowSize * (row + 1);\n            }\n            newShape.clockwise = sectorShape.clockwise;\n            newShape.cx = sectorShape.cx;\n            newShape.cy = sectorShape.cy;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction divideRect(rectShape, count, outShapes) {\n    var width = rectShape.width;\n    var height = rectShape.height;\n    var isHorizontalRow = width > height;\n    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n    var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n    var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n    var rowDim = isHorizontalRow ? 'x' : 'y';\n    var columnDim = isHorizontalRow ? 'y' : 'x';\n    var rowSize = rectShape[rowSizeDim] / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = rectShape[columnSizeDim] / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            newShape[rowDim] = row * rowSize;\n            newShape[columnDim] = column * columnSize;\n            newShape[rowSizeDim] = rowSize;\n            newShape[columnSizeDim] = columnSize;\n            newShape.x += rectShape.x;\n            newShape.y += rectShape.y;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction crossProduct2d(x1, y1, x2, y2) {\n    return x1 * y2 - x2 * y1;\n}\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var mx = a2x - a1x;\n    var my = a2y - a1y;\n    var nx = b2x - b1x;\n    var ny = b2y - b1y;\n    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n    if (Math.abs(nmCrossProduct) < 1e-6) {\n        return null;\n    }\n    var b1a1x = a1x - b1x;\n    var b1a1y = a1y - b1y;\n    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n    if (p < 0 || p > 1) {\n        return null;\n    }\n    return new Point(p * mx + a1x, p * my + a1y);\n}\nfunction projPtOnLine(pt, lineA, lineB) {\n    var dir = new Point();\n    Point.sub(dir, lineB, lineA);\n    dir.normalize();\n    var dir2 = new Point();\n    Point.sub(dir2, pt, lineA);\n    var len = dir2.dot(dir);\n    return len;\n}\nfunction addToPoly(poly, pt) {\n    var last = poly[poly.length - 1];\n    if (last && last[0] === pt[0] && last[1] === pt[1]) {\n        return;\n    }\n    poly.push(pt);\n}\nfunction splitPolygonByLine(points, lineA, lineB) {\n    var len = points.length;\n    var intersections = [];\n    for (var i = 0; i < len; i++) {\n        var p0 = points[i];\n        var p1 = points[(i + 1) % len];\n        var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n        if (intersectionPt) {\n            intersections.push({\n                projPt: projPtOnLine(intersectionPt, lineA, lineB),\n                pt: intersectionPt,\n                idx: i\n            });\n        }\n    }\n    if (intersections.length < 2) {\n        return [{ points: points }, { points: points }];\n    }\n    intersections.sort(function (a, b) {\n        return a.projPt - b.projPt;\n    });\n    var splitPt0 = intersections[0];\n    var splitPt1 = intersections[intersections.length - 1];\n    if (splitPt1.idx < splitPt0.idx) {\n        var tmp = splitPt0;\n        splitPt0 = splitPt1;\n        splitPt1 = tmp;\n    }\n    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n    var newPolyA = [splitPt0Arr];\n    var newPolyB = [splitPt1Arr];\n    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n        addToPoly(newPolyA, points[i].slice());\n    }\n    addToPoly(newPolyA, splitPt1Arr);\n    addToPoly(newPolyA, splitPt0Arr);\n    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n        addToPoly(newPolyB, points[i % len].slice());\n    }\n    addToPoly(newPolyB, splitPt0Arr);\n    addToPoly(newPolyB, splitPt1Arr);\n    return [{\n            points: newPolyA\n        }, {\n            points: newPolyB\n        }];\n}\nfunction binaryDividePolygon(polygonShape) {\n    var points = polygonShape.points;\n    var min = [];\n    var max = [];\n    fromPoints(points, min, max);\n    var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    var width = boundingRect.width;\n    var height = boundingRect.height;\n    var x = boundingRect.x;\n    var y = boundingRect.y;\n    var pt0 = new Point();\n    var pt1 = new Point();\n    if (width > height) {\n        pt0.x = pt1.x = x + width / 2;\n        pt0.y = y;\n        pt1.y = y + height;\n    }\n    else {\n        pt0.y = pt1.y = y + height / 2;\n        pt0.x = x;\n        pt1.x = x + width;\n    }\n    return splitPolygonByLine(points, pt0, pt1);\n}\nfunction binaryDivideRecursive(divider, shape, count, out) {\n    if (count === 1) {\n        out.push(shape);\n    }\n    else {\n        var mid = Math.floor(count / 2);\n        var sub = divider(shape);\n        binaryDivideRecursive(divider, sub[0], mid, out);\n        binaryDivideRecursive(divider, sub[1], count - mid, out);\n    }\n    return out;\n}\nexport function clone(path, count) {\n    var paths = [];\n    for (var i = 0; i < count; i++) {\n        paths.push(clonePath(path));\n    }\n    return paths;\n}\nfunction copyPathProps(source, target) {\n    target.setStyle(source.style);\n    target.z = source.z;\n    target.z2 = source.z2;\n    target.zlevel = source.zlevel;\n}\nfunction polygonConvert(points) {\n    var out = [];\n    for (var i = 0; i < points.length;) {\n        out.push([points[i++], points[i++]]);\n    }\n    return out;\n}\nexport function split(path, count) {\n    var outShapes = [];\n    var shape = path.shape;\n    var OutShapeCtor;\n    switch (path.type) {\n        case 'rect':\n            divideRect(shape, count, outShapes);\n            OutShapeCtor = Rect;\n            break;\n        case 'sector':\n            divideSector(shape, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        case 'circle':\n            divideSector({\n                r0: 0, r: shape.r, startAngle: 0, endAngle: Math.PI * 2,\n                cx: shape.cx, cy: shape.cy\n            }, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        default:\n            var m = path.getComputedTransform();\n            var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n            var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly); });\n            var polygonCount = polygons.length;\n            if (polygonCount === 0) {\n                binaryDivideRecursive(binaryDividePolygon, {\n                    points: polygons[0]\n                }, count, outShapes);\n            }\n            else if (polygonCount === count) {\n                for (var i = 0; i < polygonCount; i++) {\n                    outShapes.push({\n                        points: polygons[i]\n                    });\n                }\n            }\n            else {\n                var totalArea_1 = 0;\n                var items = map(polygons, function (poly) {\n                    var min = [];\n                    var max = [];\n                    fromPoints(poly, min, max);\n                    var area = (max[1] - min[1]) * (max[0] - min[0]);\n                    totalArea_1 += area;\n                    return { poly: poly, area: area };\n                });\n                items.sort(function (a, b) { return b.area - a.area; });\n                var left = count;\n                for (var i = 0; i < polygonCount; i++) {\n                    var item = items[i];\n                    if (left <= 0) {\n                        break;\n                    }\n                    var selfCount = i === polygonCount - 1\n                        ? left\n                        : Math.ceil(item.area / totalArea_1 * count);\n                    if (selfCount < 0) {\n                        continue;\n                    }\n                    binaryDivideRecursive(binaryDividePolygon, {\n                        points: item.poly\n                    }, selfCount, outShapes);\n                    left -= selfCount;\n                }\n                ;\n            }\n            OutShapeCtor = Polygon;\n            break;\n    }\n    if (!OutShapeCtor) {\n        return clone(path, count);\n    }\n    var out = [];\n    for (var i = 0; i < outShapes.length; i++) {\n        var subPath = new OutShapeCtor();\n        subPath.setShape(outShapes[i]);\n        copyPathProps(path, subPath);\n        out.push(subPath);\n    }\n    return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}