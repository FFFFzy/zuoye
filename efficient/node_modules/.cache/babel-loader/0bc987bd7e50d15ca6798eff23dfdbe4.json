{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateCategoryInterval = calculateCategoryInterval;\nexports.createAxisLabels = createAxisLabels;\nexports.createAxisTicks = createAxisTicks;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar textContain = _interopRequireWildcard(require(\"zrender/lib/contain/text.js\"));\n\nvar _model = require(\"../util/model.js\");\n\nvar _axisHelper = require(\"./axisHelper.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = (0, _model.makeInner)();\n\nfunction createAxisLabels(axis) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\n * @param {module:echats/coord/Axis} axis\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\n * @return {Object} {\n *     ticks: Array.<number>\n *     tickCategoryInterval: number\n * }\n */\n\n\nfunction createAxisTicks(axis, tickModel) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\n\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\n\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = (0, _axisHelper.getOptionCategoryInterval)(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var labels;\n  var numericLabelInterval;\n\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\n\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = (0, _axisHelper.getOptionCategoryInterval)(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var ticks;\n  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\n\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = (0, _axisHelper.makeLabelFormatter)(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        level: tick.level,\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\n\nfunction getListCache(axis, prop) {\n  // Because key can be funciton, and cache size always be small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\n\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\n\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\n\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\n\n\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = (0, _axisHelper.makeLabelFormatter)(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n\n  var tickCount = ordinalScale.count();\n\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n\n  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0; // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top'); // Magic number\n\n    width = rect.width * 1.3;\n    height = rect.height * 1.3; // Min size, void long loop.\n\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n\n  var dw = maxW / unitW;\n  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hiden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n\n  return interval;\n}\n\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\n\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = (0, _axisHelper.makeLabelFormatter)(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  } // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n\n\n  var showAllLabel = (0, _axisHelper.shouldShowAllLabels)(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n\n\n  var tickValue = startTick;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n\n  return result;\n}\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = (0, _axisHelper.makeLabelFormatter)(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["inner","makeInner","createAxisLabels","axis","type","makeCategoryLabels","makeRealNumberLabels","createAxisTicks","tickModel","makeCategoryTicks","ticks","zrUtil","map","scale","getTicks","tick","value","labelModel","getLabelModel","result","makeCategoryLabelsActually","get","isBlank","labels","labelCategoryInterval","labelsCache","getListCache","optionLabelInterval","getOptionCategoryInterval","listCacheGet","numericLabelInterval","isFunction","makeLabelsByCustomizedCategoryInterval","makeAutoCategoryInterval","makeLabelsByNumericCategoryInterval","listCacheSet","ticksCache","optionTickInterval","tickCategoryInterval","labelsResult","labelItem","tickValue","labelFormatter","makeLabelFormatter","idx","level","formattedLabel","rawLabel","getLabel","prop","cache","key","i","length","push","autoInterval","calculateCategoryInterval","params","fetchAutoCategoryIntervalCalculationParams","rotation","axisRotate","labelRotate","Math","PI","ordinalScale","ordinalExtent","getExtent","tickCount","count","step","max","floor","unitSpan","dataToCoord","unitW","abs","cos","unitH","sin","maxW","maxH","width","height","rect","textContain","getBoundingRect","font","dw","dh","isNaN","Infinity","interval","min","model","axisExtent","lastAutoInterval","lastTickCount","axisExtent0","axisExtent1","getRotate","isHorizontal","getFont","categoryInterval","onlyTick","startTick","round","ceil","showAllLabel","shouldShowAllLabels","includeMinLabel","includeMaxLabel","addItem","tickObj","each"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/coord/axisTickLabelBuilder.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as textContain from 'zrender/lib/contain/text.js';\nimport { makeInner } from '../util/model.js';\nimport { makeLabelFormatter, getOptionCategoryInterval, shouldShowAllLabels } from './axisHelper.js';\nvar inner = makeInner();\nexport function createAxisLabels(axis) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\n * @param {module:echats/coord/Axis} axis\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\n * @return {Object} {\n *     ticks: Array.<number>\n *     tickCategoryInterval: number\n * }\n */\n\nexport function createAxisTicks(axis, tickModel) {\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\n\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\n\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var labels;\n  var numericLabelInterval;\n\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\n\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var ticks;\n  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n      tickCategoryInterval = labelsResult.labelCategoryInterval;\n      ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n        return labelItem.tickValue;\n      });\n    } else {\n      tickCategoryInterval = optionTickInterval;\n      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n    } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\n\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        level: tick.level,\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\n\nfunction getListCache(axis, prop) {\n  // Because key can be funciton, and cache size always be small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\n\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\n\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\n\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\n\n\nexport function calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n\n  var tickCount = ordinalScale.count();\n\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n\n  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0; // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top'); // Magic number\n\n    width = rect.width * 1.3;\n    height = rect.height * 1.3; // Min size, void long loop.\n\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n\n  var dw = maxW / unitW;\n  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hiden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n      cache.lastTickCount = tickCount;\n      cache.lastAutoInterval = interval;\n      cache.axisExtent0 = axisExtent[0];\n      cache.axisExtent1 = axisExtent[1];\n    }\n\n  return interval;\n}\n\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\n\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  } // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n\n\n  var showAllLabel = shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n\n\n  var tickValue = startTick;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n\n  return result;\n}\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}"],"mappings":";;;;;;;;;;;AA2CA;;AACA;;AACA;;AACA;;AA7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,IAAIA,KAAK,GAAG,IAAAC,gBAAA,GAAZ;;AACO,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;EACrC;EACA,OAAOA,IAAI,CAACC,IAAL,KAAc,UAAd,GAA2BC,kBAAkB,CAACF,IAAD,CAA7C,GAAsDG,oBAAoB,CAACH,IAAD,CAAjF;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEO,SAASI,eAAT,CAAyBJ,IAAzB,EAA+BK,SAA/B,EAA0C;EAC/C;EACA,OAAOL,IAAI,CAACC,IAAL,KAAc,UAAd,GAA2BK,iBAAiB,CAACN,IAAD,EAAOK,SAAP,CAA5C,GAAgE;IACrEE,KAAK,EAAEC,MAAM,CAACC,GAAP,CAAWT,IAAI,CAACU,KAAL,CAAWC,QAAX,EAAX,EAAkC,UAAUC,IAAV,EAAgB;MACvD,OAAOA,IAAI,CAACC,KAAZ;IACD,CAFM;EAD8D,CAAvE;AAKD;;AAED,SAASX,kBAAT,CAA4BF,IAA5B,EAAkC;EAChC,IAAIc,UAAU,GAAGd,IAAI,CAACe,aAAL,EAAjB;EACA,IAAIC,MAAM,GAAGC,0BAA0B,CAACjB,IAAD,EAAOc,UAAP,CAAvC;EACA,OAAO,CAACA,UAAU,CAACI,GAAX,CAAe,MAAf,CAAD,IAA2BlB,IAAI,CAACU,KAAL,CAAWS,OAAX,EAA3B,GAAkD;IACvDC,MAAM,EAAE,EAD+C;IAEvDC,qBAAqB,EAAEL,MAAM,CAACK;EAFyB,CAAlD,GAGHL,MAHJ;AAID;;AAED,SAASC,0BAAT,CAAoCjB,IAApC,EAA0Cc,UAA1C,EAAsD;EACpD,IAAIQ,WAAW,GAAGC,YAAY,CAACvB,IAAD,EAAO,QAAP,CAA9B;EACA,IAAIwB,mBAAmB,GAAG,IAAAC,qCAAA,EAA0BX,UAA1B,CAA1B;EACA,IAAIE,MAAM,GAAGU,YAAY,CAACJ,WAAD,EAAcE,mBAAd,CAAzB;;EAEA,IAAIR,MAAJ,EAAY;IACV,OAAOA,MAAP;EACD;;EAED,IAAII,MAAJ;EACA,IAAIO,oBAAJ;;EAEA,IAAInB,MAAM,CAACoB,UAAP,CAAkBJ,mBAAlB,CAAJ,EAA4C;IAC1CJ,MAAM,GAAGS,sCAAsC,CAAC7B,IAAD,EAAOwB,mBAAP,CAA/C;EACD,CAFD,MAEO;IACLG,oBAAoB,GAAGH,mBAAmB,KAAK,MAAxB,GAAiCM,wBAAwB,CAAC9B,IAAD,CAAzD,GAAkEwB,mBAAzF;IACAJ,MAAM,GAAGW,mCAAmC,CAAC/B,IAAD,EAAO2B,oBAAP,CAA5C;EACD,CAjBmD,CAiBlD;;;EAGF,OAAOK,YAAY,CAACV,WAAD,EAAcE,mBAAd,EAAmC;IACpDJ,MAAM,EAAEA,MAD4C;IAEpDC,qBAAqB,EAAEM;EAF6B,CAAnC,CAAnB;AAID;;AAED,SAASrB,iBAAT,CAA2BN,IAA3B,EAAiCK,SAAjC,EAA4C;EAC1C,IAAI4B,UAAU,GAAGV,YAAY,CAACvB,IAAD,EAAO,OAAP,CAA7B;EACA,IAAIkC,kBAAkB,GAAG,IAAAT,qCAAA,EAA0BpB,SAA1B,CAAzB;EACA,IAAIW,MAAM,GAAGU,YAAY,CAACO,UAAD,EAAaC,kBAAb,CAAzB;;EAEA,IAAIlB,MAAJ,EAAY;IACV,OAAOA,MAAP;EACD;;EAED,IAAIT,KAAJ;EACA,IAAI4B,oBAAJ,CAV0C,CAUhB;EAC1B;;EAEA,IAAI,CAAC9B,SAAS,CAACa,GAAV,CAAc,MAAd,CAAD,IAA0BlB,IAAI,CAACU,KAAL,CAAWS,OAAX,EAA9B,EAAoD;IAClDZ,KAAK,GAAG,EAAR;EACD;;EAED,IAAIC,MAAM,CAACoB,UAAP,CAAkBM,kBAAlB,CAAJ,EAA2C;IACzC3B,KAAK,GAAGsB,sCAAsC,CAAC7B,IAAD,EAAOkC,kBAAP,EAA2B,IAA3B,CAA9C;EACD,CAFD,CAEE;EACF;EACA;EAJA,KAKK,IAAIA,kBAAkB,KAAK,MAA3B,EAAmC;IACpC,IAAIE,YAAY,GAAGnB,0BAA0B,CAACjB,IAAD,EAAOA,IAAI,CAACe,aAAL,EAAP,CAA7C;IACAoB,oBAAoB,GAAGC,YAAY,CAACf,qBAApC;IACAd,KAAK,GAAGC,MAAM,CAACC,GAAP,CAAW2B,YAAY,CAAChB,MAAxB,EAAgC,UAAUiB,SAAV,EAAqB;MAC3D,OAAOA,SAAS,CAACC,SAAjB;IACD,CAFO,CAAR;EAGD,CANE,MAMI;IACLH,oBAAoB,GAAGD,kBAAvB;IACA3B,KAAK,GAAGwB,mCAAmC,CAAC/B,IAAD,EAAOmC,oBAAP,EAA6B,IAA7B,CAA3C;EACD,CA/BuC,CA+BtC;;;EAGJ,OAAOH,YAAY,CAACC,UAAD,EAAaC,kBAAb,EAAiC;IAClD3B,KAAK,EAAEA,KAD2C;IAElD4B,oBAAoB,EAAEA;EAF4B,CAAjC,CAAnB;AAID;;AAED,SAAShC,oBAAT,CAA8BH,IAA9B,EAAoC;EAClC,IAAIO,KAAK,GAAGP,IAAI,CAACU,KAAL,CAAWC,QAAX,EAAZ;EACA,IAAI4B,cAAc,GAAG,IAAAC,8BAAA,EAAmBxC,IAAnB,CAArB;EACA,OAAO;IACLoB,MAAM,EAAEZ,MAAM,CAACC,GAAP,CAAWF,KAAX,EAAkB,UAAUK,IAAV,EAAgB6B,GAAhB,EAAqB;MAC7C,OAAO;QACLC,KAAK,EAAE9B,IAAI,CAAC8B,KADP;QAELC,cAAc,EAAEJ,cAAc,CAAC3B,IAAD,EAAO6B,GAAP,CAFzB;QAGLG,QAAQ,EAAE5C,IAAI,CAACU,KAAL,CAAWmC,QAAX,CAAoBjC,IAApB,CAHL;QAIL0B,SAAS,EAAE1B,IAAI,CAACC;MAJX,CAAP;IAMD,CAPO;EADH,CAAP;AAUD;;AAED,SAASU,YAAT,CAAsBvB,IAAtB,EAA4B8C,IAA5B,EAAkC;EAChC;EACA,OAAOjD,KAAK,CAACG,IAAD,CAAL,CAAY8C,IAAZ,MAAsBjD,KAAK,CAACG,IAAD,CAAL,CAAY8C,IAAZ,IAAoB,EAA1C,CAAP;AACD;;AAED,SAASpB,YAAT,CAAsBqB,KAAtB,EAA6BC,GAA7B,EAAkC;EAChC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACrC,IAAIF,KAAK,CAACE,CAAD,CAAL,CAASD,GAAT,KAAiBA,GAArB,EAA0B;MACxB,OAAOD,KAAK,CAACE,CAAD,CAAL,CAASpC,KAAhB;IACD;EACF;AACF;;AAED,SAASmB,YAAT,CAAsBe,KAAtB,EAA6BC,GAA7B,EAAkCnC,KAAlC,EAAyC;EACvCkC,KAAK,CAACI,IAAN,CAAW;IACTH,GAAG,EAAEA,GADI;IAETnC,KAAK,EAAEA;EAFE,CAAX;EAIA,OAAOA,KAAP;AACD;;AAED,SAASiB,wBAAT,CAAkC9B,IAAlC,EAAwC;EACtC,IAAIgB,MAAM,GAAGnB,KAAK,CAACG,IAAD,CAAL,CAAYoD,YAAzB;EACA,OAAOpC,MAAM,IAAI,IAAV,GAAiBA,MAAjB,GAA0BnB,KAAK,CAACG,IAAD,CAAL,CAAYoD,YAAZ,GAA2BpD,IAAI,CAACqD,yBAAL,EAA5D;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGO,SAASA,yBAAT,CAAmCrD,IAAnC,EAAyC;EAC9C,IAAIsD,MAAM,GAAGC,0CAA0C,CAACvD,IAAD,CAAvD;EACA,IAAIuC,cAAc,GAAG,IAAAC,8BAAA,EAAmBxC,IAAnB,CAArB;EACA,IAAIwD,QAAQ,GAAG,CAACF,MAAM,CAACG,UAAP,GAAoBH,MAAM,CAACI,WAA5B,IAA2C,GAA3C,GAAiDC,IAAI,CAACC,EAArE;EACA,IAAIC,YAAY,GAAG7D,IAAI,CAACU,KAAxB;EACA,IAAIoD,aAAa,GAAGD,YAAY,CAACE,SAAb,EAApB,CAL8C,CAKA;EAC9C;EACA;;EAEA,IAAIC,SAAS,GAAGH,YAAY,CAACI,KAAb,EAAhB;;EAEA,IAAIH,aAAa,CAAC,CAAD,CAAb,GAAmBA,aAAa,CAAC,CAAD,CAAhC,GAAsC,CAA1C,EAA6C;IAC3C,OAAO,CAAP;EACD;;EAED,IAAII,IAAI,GAAG,CAAX,CAf8C,CAehC;;EAEd,IAAIF,SAAS,GAAG,EAAhB,EAAoB;IAClBE,IAAI,GAAGP,IAAI,CAACQ,GAAL,CAAS,CAAT,EAAYR,IAAI,CAACS,KAAL,CAAWJ,SAAS,GAAG,EAAvB,CAAZ,CAAP;EACD;;EAED,IAAI1B,SAAS,GAAGwB,aAAa,CAAC,CAAD,CAA7B;EACA,IAAIO,QAAQ,GAAGrE,IAAI,CAACsE,WAAL,CAAiBhC,SAAS,GAAG,CAA7B,IAAkCtC,IAAI,CAACsE,WAAL,CAAiBhC,SAAjB,CAAjD;EACA,IAAIiC,KAAK,GAAGZ,IAAI,CAACa,GAAL,CAASH,QAAQ,GAAGV,IAAI,CAACc,GAAL,CAASjB,QAAT,CAApB,CAAZ;EACA,IAAIkB,KAAK,GAAGf,IAAI,CAACa,GAAL,CAASH,QAAQ,GAAGV,IAAI,CAACgB,GAAL,CAASnB,QAAT,CAApB,CAAZ;EACA,IAAIoB,IAAI,GAAG,CAAX;EACA,IAAIC,IAAI,GAAG,CAAX,CA1B8C,CA0BhC;EACd;;EAEA,OAAOvC,SAAS,IAAIwB,aAAa,CAAC,CAAD,CAAjC,EAAsCxB,SAAS,IAAI4B,IAAnD,EAAyD;IACvD,IAAIY,KAAK,GAAG,CAAZ;IACA,IAAIC,MAAM,GAAG,CAAb,CAFuD,CAEvC;IAChB;;IAEA,IAAIC,IAAI,GAAGC,WAAW,CAACC,eAAZ,CAA4B3C,cAAc,CAAC;MACpD1B,KAAK,EAAEyB;IAD6C,CAAD,CAA1C,EAEPgB,MAAM,CAAC6B,IAFA,EAEM,QAFN,EAEgB,KAFhB,CAAX,CALuD,CAOpB;;IAEnCL,KAAK,GAAGE,IAAI,CAACF,KAAL,GAAa,GAArB;IACAC,MAAM,GAAGC,IAAI,CAACD,MAAL,GAAc,GAAvB,CAVuD,CAU3B;;IAE5BH,IAAI,GAAGjB,IAAI,CAACQ,GAAL,CAASS,IAAT,EAAeE,KAAf,EAAsB,CAAtB,CAAP;IACAD,IAAI,GAAGlB,IAAI,CAACQ,GAAL,CAASU,IAAT,EAAeE,MAAf,EAAuB,CAAvB,CAAP;EACD;;EAED,IAAIK,EAAE,GAAGR,IAAI,GAAGL,KAAhB;EACA,IAAIc,EAAE,GAAGR,IAAI,GAAGH,KAAhB,CA9C8C,CA8CvB;;EAEvBY,KAAK,CAACF,EAAD,CAAL,KAAcA,EAAE,GAAGG,QAAnB;EACAD,KAAK,CAACD,EAAD,CAAL,KAAcA,EAAE,GAAGE,QAAnB;EACA,IAAIC,QAAQ,GAAG7B,IAAI,CAACQ,GAAL,CAAS,CAAT,EAAYR,IAAI,CAACS,KAAL,CAAWT,IAAI,CAAC8B,GAAL,CAASL,EAAT,EAAaC,EAAb,CAAX,CAAZ,CAAf;EACA,IAAItC,KAAK,GAAGlD,KAAK,CAACG,IAAI,CAAC0F,KAAN,CAAjB;EACA,IAAIC,UAAU,GAAG3F,IAAI,CAAC+D,SAAL,EAAjB;EACA,IAAI6B,gBAAgB,GAAG7C,KAAK,CAAC6C,gBAA7B;EACA,IAAIC,aAAa,GAAG9C,KAAK,CAAC8C,aAA1B,CAtD8C,CAsDL;EACzC;EACA;EACA;EACA;EACA;;EAEA,IAAID,gBAAgB,IAAI,IAApB,IAA4BC,aAAa,IAAI,IAA7C,IAAqDlC,IAAI,CAACa,GAAL,CAASoB,gBAAgB,GAAGJ,QAA5B,KAAyC,CAA9F,IAAmG7B,IAAI,CAACa,GAAL,CAASqB,aAAa,GAAG7B,SAAzB,KAAuC,CAA1I,CAA4I;EAChJ;EADI,GAED4B,gBAAgB,GAAGJ,QAFlB,CAE2B;EAC/B;EAHI,GAIDzC,KAAK,CAAC+C,WAAN,KAAsBH,UAAU,CAAC,CAAD,CAJ/B,IAIsC5C,KAAK,CAACgD,WAAN,KAAsBJ,UAAU,CAAC,CAAD,CAJ1E,EAI+E;IAC7EH,QAAQ,GAAGI,gBAAX;EACD,CAND,CAME;EACF;EAPA,KAQK;IACD7C,KAAK,CAAC8C,aAAN,GAAsB7B,SAAtB;IACAjB,KAAK,CAAC6C,gBAAN,GAAyBJ,QAAzB;IACAzC,KAAK,CAAC+C,WAAN,GAAoBH,UAAU,CAAC,CAAD,CAA9B;IACA5C,KAAK,CAACgD,WAAN,GAAoBJ,UAAU,CAAC,CAAD,CAA9B;EACD;;EAEH,OAAOH,QAAP;AACD;;AAED,SAASjC,0CAAT,CAAoDvD,IAApD,EAA0D;EACxD,IAAIc,UAAU,GAAGd,IAAI,CAACe,aAAL,EAAjB;EACA,OAAO;IACL0C,UAAU,EAAEzD,IAAI,CAACgG,SAAL,GAAiBhG,IAAI,CAACgG,SAAL,EAAjB,GAAoChG,IAAI,CAACiG,YAAL,IAAqB,CAACjG,IAAI,CAACiG,YAAL,EAAtB,GAA4C,EAA5C,GAAiD,CAD5F;IAELvC,WAAW,EAAE5C,UAAU,CAACI,GAAX,CAAe,QAAf,KAA4B,CAFpC;IAGLiE,IAAI,EAAErE,UAAU,CAACoF,OAAX;EAHD,CAAP;AAKD;;AAED,SAASnE,mCAAT,CAA6C/B,IAA7C,EAAmDmG,gBAAnD,EAAqEC,QAArE,EAA+E;EAC7E,IAAI7D,cAAc,GAAG,IAAAC,8BAAA,EAAmBxC,IAAnB,CAArB;EACA,IAAI6D,YAAY,GAAG7D,IAAI,CAACU,KAAxB;EACA,IAAIoD,aAAa,GAAGD,YAAY,CAACE,SAAb,EAApB;EACA,IAAIjD,UAAU,GAAGd,IAAI,CAACe,aAAL,EAAjB;EACA,IAAIC,MAAM,GAAG,EAAb,CAL6E,CAK5D;;EAEjB,IAAIkD,IAAI,GAAGP,IAAI,CAACQ,GAAL,CAAS,CAACgC,gBAAgB,IAAI,CAArB,IAA0B,CAAnC,EAAsC,CAAtC,CAAX;EACA,IAAIE,SAAS,GAAGvC,aAAa,CAAC,CAAD,CAA7B;EACA,IAAIE,SAAS,GAAGH,YAAY,CAACI,KAAb,EAAhB,CAT6E,CASvC;EACtC;EACA;EACA;;EAEA,IAAIoC,SAAS,KAAK,CAAd,IAAmBnC,IAAI,GAAG,CAA1B,IAA+BF,SAAS,GAAGE,IAAZ,GAAmB,CAAtD,EAAyD;IACvDmC,SAAS,GAAG1C,IAAI,CAAC2C,KAAL,CAAW3C,IAAI,CAAC4C,IAAL,CAAUF,SAAS,GAAGnC,IAAtB,IAA8BA,IAAzC,CAAZ;EACD,CAhB4E,CAgB3E;EACF;EACA;EACA;EACA;;;EAGA,IAAIsC,YAAY,GAAG,IAAAC,+BAAA,EAAoBzG,IAApB,CAAnB;EACA,IAAI0G,eAAe,GAAG5F,UAAU,CAACI,GAAX,CAAe,cAAf,KAAkCsF,YAAxD;EACA,IAAIG,eAAe,GAAG7F,UAAU,CAACI,GAAX,CAAe,cAAf,KAAkCsF,YAAxD;;EAEA,IAAIE,eAAe,IAAIL,SAAS,KAAKvC,aAAa,CAAC,CAAD,CAAlD,EAAuD;IACrD8C,OAAO,CAAC9C,aAAa,CAAC,CAAD,CAAd,CAAP;EACD,CA7B4E,CA6B3E;;;EAGF,IAAIxB,SAAS,GAAG+D,SAAhB;;EAEA,OAAO/D,SAAS,IAAIwB,aAAa,CAAC,CAAD,CAAjC,EAAsCxB,SAAS,IAAI4B,IAAnD,EAAyD;IACvD0C,OAAO,CAACtE,SAAD,CAAP;EACD;;EAED,IAAIqE,eAAe,IAAIrE,SAAS,GAAG4B,IAAZ,KAAqBJ,aAAa,CAAC,CAAD,CAAzD,EAA8D;IAC5D8C,OAAO,CAAC9C,aAAa,CAAC,CAAD,CAAd,CAAP;EACD;;EAED,SAAS8C,OAAT,CAAiBtE,SAAjB,EAA4B;IAC1B,IAAIuE,OAAO,GAAG;MACZhG,KAAK,EAAEyB;IADK,CAAd;IAGAtB,MAAM,CAACmC,IAAP,CAAYiD,QAAQ,GAAG9D,SAAH,GAAe;MACjCK,cAAc,EAAEJ,cAAc,CAACsE,OAAD,CADG;MAEjCjE,QAAQ,EAAEiB,YAAY,CAAChB,QAAb,CAAsBgE,OAAtB,CAFuB;MAGjCvE,SAAS,EAAEA;IAHsB,CAAnC;EAKD;;EAED,OAAOtB,MAAP;AACD;;AAED,SAASa,sCAAT,CAAgD7B,IAAhD,EAAsDmG,gBAAtD,EAAwEC,QAAxE,EAAkF;EAChF,IAAIvC,YAAY,GAAG7D,IAAI,CAACU,KAAxB;EACA,IAAI6B,cAAc,GAAG,IAAAC,8BAAA,EAAmBxC,IAAnB,CAArB;EACA,IAAIgB,MAAM,GAAG,EAAb;EACAR,MAAM,CAACsG,IAAP,CAAYjD,YAAY,CAAClD,QAAb,EAAZ,EAAqC,UAAUC,IAAV,EAAgB;IACnD,IAAIgC,QAAQ,GAAGiB,YAAY,CAAChB,QAAb,CAAsBjC,IAAtB,CAAf;IACA,IAAI0B,SAAS,GAAG1B,IAAI,CAACC,KAArB;;IAEA,IAAIsF,gBAAgB,CAACvF,IAAI,CAACC,KAAN,EAAa+B,QAAb,CAApB,EAA4C;MAC1C5B,MAAM,CAACmC,IAAP,CAAYiD,QAAQ,GAAG9D,SAAH,GAAe;QACjCK,cAAc,EAAEJ,cAAc,CAAC3B,IAAD,CADG;QAEjCgC,QAAQ,EAAEA,QAFuB;QAGjCN,SAAS,EAAEA;MAHsB,CAAnC;IAKD;EACF,CAXD;EAYA,OAAOtB,MAAP;AACD"},"metadata":{},"sourceType":"script"}