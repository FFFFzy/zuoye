{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar graphic = _interopRequireWildcard(require(\"../../util/graphic.js\"));\n\nvar brushHelper = _interopRequireWildcard(require(\"./brushHelper.js\"));\n\nvar _model = require(\"../../util/model.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME\n// how to genarialize to more coordinate systems.\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    (0, _util.each)(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || (0, _util.indexOf)(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    (0, _util.each)(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        (0, _util.each)(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    (0, _util.each)(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _util.assert)(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        (0, _util.assert)(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return (0, _util.map)(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && (0, _util.indexOf)(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return (0, _model.parseFinder)(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = (0, _util.createHashMap)();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    (0, _util.each)(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    (0, _util.each)(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    (0, _util.each)(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      (0, _util.each)(grid.getCartesians(), function (cartesian, index) {\n        if ((0, _util.indexOf)(xAxisModels, cartesian.getAxis('x').model) >= 0 || (0, _util.indexOf)(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    (0, _util.each)(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: (0, _util.curry)(axisConvert, 0),\n  lineY: (0, _util.curry)(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = (0, _util.map)(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _util.assert)(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax((0, _util.map)([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: (0, _util.curry)(axisDiffProcessor, 0),\n  lineY: (0, _util.curry)(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return (0, _util.map)(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nexports.default = _default;","map":{"version":3,"names":["INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","finder","ecModel","opt","_this","_targetInfoList","foundCpts","parseFinder","each","targetInfoBuilders","builder","type","include","indexOf","prototype","setOutputRanges","areas","matchOutputRanges","area","coordRange","coordSys","coordRanges","push","result","coordConvert","brushType","__rangeOffset","offset","diffProcessor","values","range","xyMinMax","cb","targetInfo","findTargetInfo","coordSyses","setInputRanges","process","env","NODE_ENV","assert","panelId","rangeOffset","getScales","makePanelOpts","api","getDefaultBrushType","map","rect","getPanelRect","defaultBrushType","clipPath","brushHelper","makeRectPanelClipPath","isTargetByCursor","makeRectIsTargetByCursor","coordSysModel","getLinearBrushOtherExtent","makeLinearBrushOtherExtent","controlSeries","seriesModel","coordinateSystem","targetInfoList","i","length","areaPanelId","j","targetInfoMatchers","formatMinMax","minMax","reverse","modelUtilParseFinder","includeMainTypes","grid","xAxisModels","yAxisModels","gridModels","gridModelMap","createHashMap","xAxesHas","yAxesHas","axisModel","gridModel","axis","model","set","id","cartesians","getCartesians","cartesian","index","getAxis","panelRectBuilders","xAxisDeclared","yAxisDeclared","geo","geoModels","geoModel","xAxisModel","yAxisModel","master","getRect","clone","getBoundingRect","applyTransform","graphic","getTransform","lineX","curry","axisConvert","lineY","to","rangeOrCoordRange","clamp","xminymin","pointToData","dataToPoint","xmaxymax","polygon","Infinity","item","p","Math","min","max","axisNameIndex","coordToData","toLocalCoord","toGlobalCoord","dataToCoord","NaN","axisDiffProcessor","refer","scales","idx","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","isNaN"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/component/helper/BrushTargetManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, indexOf, curry, assert, map, createHashMap } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as brushHelper from './brushHelper.js';\nimport { parseFinder as modelUtilParseFinder } from '../../util/model.js'; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    each(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        each(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return modelUtilParseFinder(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = map(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nexport default BrushTargetManager;"],"mappings":"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"},"metadata":{},"sourceType":"script"}