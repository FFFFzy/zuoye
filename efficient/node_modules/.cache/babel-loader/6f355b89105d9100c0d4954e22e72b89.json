{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.alignBezierCurves = alignBezierCurves;\nexports.centroid = centroid;\nexports.combineMorph = combineMorph;\nObject.defineProperty(exports, \"defaultDividePath\", {\n  enumerable: true,\n  get: function () {\n    return _dividePath.split;\n  }\n});\nexports.isCombineMorphing = isCombineMorphing;\nexports.isMorphing = isMorphing;\nexports.morphPath = morphPath;\nexports.separateMorph = separateMorph;\n\nvar _curve = require(\"../core/curve.js\");\n\nvar _Path = _interopRequireDefault(require(\"../graphic/Path.js\"));\n\nvar _util = require(\"../core/util.js\");\n\nvar _vector = require(\"../core/vector.js\");\n\nvar _path = require(\"./path.js\");\n\nvar _Transformable = _interopRequireDefault(require(\"../core/Transformable.js\"));\n\nvar _dividePath = require(\"./dividePath.js\");\n\nvar _convertPath = require(\"./convertPath.js\");\n\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n\n  var tmpSegX = [];\n  var tmpSegY = [];\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      (0, _curve.cubicSubdivide)(x0, x1, x2, x3, p, tmpSegX);\n      (0, _curve.cubicSubdivide)(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n\n  return newSubpath;\n}\n\nfunction alignBezierCurves(array1, array2) {\n  var _a;\n\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\n\nfunction centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n\n  return newArr;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr = [];\n    var len = fromSubpathBezier.length;\n\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr[k] = newX1;\n          tmpArr[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n\n          for (var m = 0; m < tmpArr.length; m++) {\n            newToSubpathBezier[m] = tmpArr[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n\n  return result;\n}\n\nfunction isCombineMorphing(path) {\n  return path.__isCombineMorphing;\n}\n\nfunction isMorphing(el) {\n  return el.__morphT >= 0;\n}\n\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\n\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n  var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n  var originalMethod = obj[savedMethodName] || obj[methodName];\n\n  if (!obj[savedMethodName]) {\n    obj[savedMethodName] = obj[methodName];\n  }\n\n  var replace = modifiers.replace;\n  var after = modifiers.after;\n  var before = modifiers.before;\n\n  obj[methodName] = function () {\n    var args = arguments;\n    var res;\n    before && before.apply(this, args);\n\n    if (replace) {\n      res = replace.apply(this, args);\n    } else {\n      res = originalMethod.apply(this, args);\n    }\n\n    after && after.apply(this, args);\n    return res;\n  };\n}\n\nfunction restoreMethod(obj, methodName) {\n  var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n\n  if (obj[savedMethodName]) {\n    obj[methodName] = obj[savedMethodName];\n    obj[savedMethodName] = null;\n  }\n}\n\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n  for (var i = 0; i < bezierCurves.length; i++) {\n    var subBeziers = bezierCurves[i];\n\n    for (var k = 0; k < subBeziers.length;) {\n      var x = subBeziers[k];\n      var y = subBeziers[k + 1];\n      subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n      subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n    }\n  }\n}\n\nfunction prepareMorphPath(fromPath, toPath) {\n  var fromPathProxy = fromPath.getUpdatedPathProxy();\n  var toPathProxy = toPath.getUpdatedPathProxy();\n\n  var _a = alignBezierCurves((0, _convertPath.pathToBezierCurves)(fromPathProxy), (0, _convertPath.pathToBezierCurves)(toPathProxy)),\n      fromBezierCurves = _a[0],\n      toBezierCurves = _a[1];\n\n  var fromPathTransform = fromPath.getComputedTransform();\n  var toPathTransform = toPath.getComputedTransform();\n\n  function updateIdentityTransform() {\n    this.transform = null;\n  }\n\n  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n  saveAndModifyMethod(toPath, 'updateTransform', {\n    replace: updateIdentityTransform\n  });\n  toPath.transform = null;\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  var tmpArr = [];\n  saveAndModifyMethod(toPath, 'buildPath', {\n    replace: function (path) {\n      var t = toPath.__morphT;\n      var onet = 1 - t;\n      var newCp = [];\n\n      for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        (0, _vector.lerp)(newCp, fromCp, toCp, t);\n\n        for (var m = 0; m < from.length; m += 2) {\n          var x0_1 = from[m];\n          var y0_1 = from[m + 1];\n          var x1 = to[m];\n          var y1 = to[m + 1];\n          var x = x0_1 * onet + x1 * t;\n          var y = y0_1 * onet + y1 * t;\n          tmpArr[m] = x * ca - y * sa + newCp[0];\n          tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n        }\n\n        var x0 = tmpArr[0];\n        var y0 = tmpArr[1];\n        path.moveTo(x0, y0);\n\n        for (var m = 2; m < from.length;) {\n          var x1 = tmpArr[m++];\n          var y1 = tmpArr[m++];\n          var x2 = tmpArr[m++];\n          var y2 = tmpArr[m++];\n          var x3 = tmpArr[m++];\n          var y3 = tmpArr[m++];\n\n          if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n            path.lineTo(x3, y3);\n          } else {\n            path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n          }\n\n          x0 = x3;\n          y0 = y3;\n        }\n      }\n    }\n  });\n}\n\nfunction morphPath(fromPath, toPath, animationOpts) {\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n\n  var oldDone = animationOpts.done;\n  var oldDuring = animationOpts.during;\n  prepareMorphPath(fromPath, toPath);\n  toPath.__morphT = 0;\n\n  function restoreToPath() {\n    restoreMethod(toPath, 'buildPath');\n    restoreMethod(toPath, 'updateTransform');\n    toPath.__morphT = -1;\n    toPath.createPathProxy();\n    toPath.dirtyShape();\n  }\n\n  toPath.animateTo({\n    __morphT: 1\n  }, (0, _util.defaults)({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreToPath();\n      oldDone && oldDone();\n    }\n  }, animationOpts));\n  return toPath;\n}\n\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n  var bits = 16;\n  x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n  y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n  var d = 0;\n  var tmp;\n\n  for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n    var rx = 0;\n    var ry = 0;\n\n    if ((x & s) > 0) {\n      rx = 1;\n    }\n\n    if ((y & s) > 0) {\n      ry = 1;\n    }\n\n    d += s * s * (3 * rx ^ ry);\n\n    if (ry === 0) {\n      if (rx === 1) {\n        x = s - 1 - x;\n        y = s - 1 - y;\n      }\n\n      tmp = x;\n      x = y;\n      y = tmp;\n    }\n  }\n\n  return d;\n}\n\nfunction sortPaths(pathList) {\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n  var cps = (0, _util.map)(pathList, function (path) {\n    var rect = path.getBoundingRect();\n    var m = path.getComputedTransform();\n    var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n    var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n    xMin = Math.min(x, xMin);\n    yMin = Math.min(y, yMin);\n    xMax = Math.max(x, xMax);\n    yMax = Math.max(y, yMax);\n    return [x, y];\n  });\n  var items = (0, _util.map)(cps, function (cp, idx) {\n    return {\n      cp: cp,\n      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n      path: pathList[idx]\n    };\n  });\n  return items.sort(function (a, b) {\n    return a.z - b.z;\n  }).map(function (item) {\n    return item.path;\n  });\n}\n\n;\n\nfunction defaultDividePath(param) {\n  return (0, _dividePath.split)(param.path, param.count);\n}\n\nfunction createEmptyReturn() {\n  return {\n    fromIndividuals: [],\n    toIndividuals: [],\n    count: 0\n  };\n}\n\nfunction combineMorph(fromList, toPath, animationOpts) {\n  var fromPathList = [];\n\n  function addFromPath(fromList) {\n    for (var i = 0; i < fromList.length; i++) {\n      var from = fromList[i];\n\n      if (isCombineMorphing(from)) {\n        addFromPath(from.childrenRef());\n      } else if (from instanceof _Path.default) {\n        fromPathList.push(from);\n      }\n    }\n  }\n\n  addFromPath(fromList);\n  var separateCount = fromPathList.length;\n\n  if (!separateCount) {\n    return createEmptyReturn();\n  }\n\n  var dividePath = animationOpts.dividePath || defaultDividePath;\n  var toSubPathList = dividePath({\n    path: toPath,\n    count: separateCount\n  });\n\n  if (toSubPathList.length !== separateCount) {\n    console.error('Invalid morphing: unmatched splitted path');\n    return createEmptyReturn();\n  }\n\n  fromPathList = sortPaths(fromPathList);\n  toSubPathList = sortPaths(toSubPathList);\n  var oldDone = animationOpts.done;\n  var oldDuring = animationOpts.during;\n  var individualDelay = animationOpts.individualDelay;\n  var identityTransform = new _Transformable.default();\n\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromPathList[i];\n    var to = toSubPathList[i];\n    to.parent = toPath;\n    to.copyTransform(identityTransform);\n\n    if (!individualDelay) {\n      prepareMorphPath(from, to);\n    }\n  }\n\n  toPath.__isCombineMorphing = true;\n\n  toPath.childrenRef = function () {\n    return toSubPathList;\n  };\n\n  function addToSubPathListToZr(zr) {\n    for (var i = 0; i < toSubPathList.length; i++) {\n      toSubPathList[i].addSelfToZr(zr);\n    }\n  }\n\n  saveAndModifyMethod(toPath, 'addSelfToZr', {\n    after: function (zr) {\n      addToSubPathListToZr(zr);\n    }\n  });\n  saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n    after: function (zr) {\n      for (var i = 0; i < toSubPathList.length; i++) {\n        toSubPathList[i].removeSelfFromZr(zr);\n      }\n    }\n  });\n\n  function restoreToPath() {\n    toPath.__isCombineMorphing = false;\n    toPath.__morphT = -1;\n    toPath.childrenRef = null;\n    restoreMethod(toPath, 'addSelfToZr');\n    restoreMethod(toPath, 'removeSelfFromZr');\n  }\n\n  var toLen = toSubPathList.length;\n\n  if (individualDelay) {\n    var animating_1 = toLen;\n\n    var eachDone = function () {\n      animating_1--;\n\n      if (animating_1 === 0) {\n        restoreToPath();\n        oldDone && oldDone();\n      }\n    };\n\n    for (var i = 0; i < toLen; i++) {\n      var indivdualAnimationOpts = individualDelay ? (0, _util.defaults)({\n        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n        done: eachDone\n      }, animationOpts) : animationOpts;\n      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n    }\n  } else {\n    toPath.__morphT = 0;\n    toPath.animateTo({\n      __morphT: 1\n    }, (0, _util.defaults)({\n      during: function (p) {\n        for (var i = 0; i < toLen; i++) {\n          var child = toSubPathList[i];\n          child.__morphT = toPath.__morphT;\n          child.dirtyShape();\n        }\n\n        oldDuring && oldDuring(p);\n      },\n      done: function () {\n        restoreToPath();\n\n        for (var i = 0; i < fromList.length; i++) {\n          restoreMethod(fromList[i], 'updateTransform');\n        }\n\n        oldDone && oldDone();\n      }\n    }, animationOpts));\n  }\n\n  if (toPath.__zr) {\n    addToSubPathListToZr(toPath.__zr);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toSubPathList,\n    count: toLen\n  };\n}\n\nfunction separateMorph(fromPath, toPathList, animationOpts) {\n  var toLen = toPathList.length;\n  var fromPathList = [];\n  var dividePath = animationOpts.dividePath || defaultDividePath;\n\n  function addFromPath(fromList) {\n    for (var i = 0; i < fromList.length; i++) {\n      var from = fromList[i];\n\n      if (isCombineMorphing(from)) {\n        addFromPath(from.childrenRef());\n      } else if (from instanceof _Path.default) {\n        fromPathList.push(from);\n      }\n    }\n  }\n\n  if (isCombineMorphing(fromPath)) {\n    addFromPath(fromPath.childrenRef());\n    var fromLen = fromPathList.length;\n\n    if (fromLen < toLen) {\n      var k = 0;\n\n      for (var i = fromLen; i < toLen; i++) {\n        fromPathList.push((0, _path.clonePath)(fromPathList[k++ % fromLen]));\n      }\n    }\n\n    fromPathList.length = toLen;\n  } else {\n    fromPathList = dividePath({\n      path: fromPath,\n      count: toLen\n    });\n    var fromPathTransform = fromPath.getComputedTransform();\n\n    for (var i = 0; i < fromPathList.length; i++) {\n      fromPathList[i].setLocalTransform(fromPathTransform);\n    }\n\n    if (fromPathList.length !== toLen) {\n      console.error('Invalid morphing: unmatched splitted path');\n      return createEmptyReturn();\n    }\n  }\n\n  fromPathList = sortPaths(fromPathList);\n  toPathList = sortPaths(toPathList);\n  var individualDelay = animationOpts.individualDelay;\n\n  for (var i = 0; i < toLen; i++) {\n    var indivdualAnimationOpts = individualDelay ? (0, _util.defaults)({\n      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n    }, animationOpts) : animationOpts;\n    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathList.length\n  };\n}","map":{"version":3,"names":["alignSubpath","subpath1","subpath2","len1","length","len2","tmpSegX","tmpSegY","shorterPath","shorterLen","Math","min","diff","abs","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","i","x0","y0","x1","y1","x2","y2","x3","y3","push","actualSubDivCount","k","p","cubicSubdivide","createSubpath","lastSubpathSubpath","otherSubpath","len","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","max","newSubpath1","newSubpath2","centroid","array","signedArea","cx","cy","j","a","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr","step","angle","sa","sin","ca","cos","newX1","newY1","m","i_1","from","to","rotation","isCombineMorphing","path","__isCombineMorphing","isMorphing","el","__morphT","SAVED_METHOD_PREFIX","saveAndModifyMethod","obj","methodName","modifiers","savedMethodName","originalMethod","replace","after","before","args","arguments","res","apply","restoreMethod","applyTransformOnBeziers","bezierCurves","mm","subBeziers","x","y","prepareMorphPath","fromPath","toPath","fromPathProxy","getUpdatedPathProxy","toPathProxy","pathToBezierCurves","fromBezierCurves","toBezierCurves","fromPathTransform","getComputedTransform","toPathTransform","updateIdentityTransform","transform","morphingData","PI","t","onet","newCp","item","lerp","x0_1","y0_1","moveTo","lineTo","bezierCurveTo","morphPath","animationOpts","oldDone","done","oldDuring","during","restoreToPath","createPathProxy","dirtyShape","animateTo","defaults","hilbert","minX","minY","maxX","maxY","bits","round","d","tmp","s","rx","ry","sortPaths","pathList","xMin","yMin","xMax","yMax","cps","map","rect","getBoundingRect","width","height","items","cp","z","sort","b","defaultDividePath","param","split","count","createEmptyReturn","fromIndividuals","toIndividuals","combineMorph","fromList","fromPathList","addFromPath","childrenRef","Path","separateCount","dividePath","toSubPathList","console","error","individualDelay","identityTransform","Transformable","parent","copyTransform","addToSubPathListToZr","zr","addSelfToZr","removeSelfFromZr","toLen","animating_1","eachDone","indivdualAnimationOpts","delay","child","__zr","separateMorph","toPathList","fromLen","clonePath","setLocalTransform"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/zrender/lib/tool/morphPath.js"],"sourcesContent":["import { cubicSubdivide } from '../core/curve.js';\nimport Path from '../graphic/Path.js';\nimport { defaults, map } from '../core/util.js';\nimport { lerp } from '../core/vector.js';\nimport { clonePath } from './path.js';\nimport Transformable from '../core/Transformable.js';\nimport { split } from './dividePath.js';\nimport { pathToBezierCurves } from './convertPath.js';\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1;\n                    tmpArr[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr.length; m++) {\n                        newToSubpathBezier[m] = tmpArr[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function isCombineMorphing(path) {\n    return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n    return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    var originalMethod = obj[savedMethodName] || obj[methodName];\n    if (!obj[savedMethodName]) {\n        obj[savedMethodName] = obj[methodName];\n    }\n    var replace = modifiers.replace;\n    var after = modifiers.after;\n    var before = modifiers.before;\n    obj[methodName] = function () {\n        var args = arguments;\n        var res;\n        before && before.apply(this, args);\n        if (replace) {\n            res = replace.apply(this, args);\n        }\n        else {\n            res = originalMethod.apply(this, args);\n        }\n        after && after.apply(this, args);\n        return res;\n    };\n}\nfunction restoreMethod(obj, methodName) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    if (obj[savedMethodName]) {\n        obj[methodName] = obj[savedMethodName];\n        obj[savedMethodName] = null;\n    }\n}\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n    for (var i = 0; i < bezierCurves.length; i++) {\n        var subBeziers = bezierCurves[i];\n        for (var k = 0; k < subBeziers.length;) {\n            var x = subBeziers[k];\n            var y = subBeziers[k + 1];\n            subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n            subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n        }\n    }\n}\nfunction prepareMorphPath(fromPath, toPath) {\n    var fromPathProxy = fromPath.getUpdatedPathProxy();\n    var toPathProxy = toPath.getUpdatedPathProxy();\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var fromPathTransform = fromPath.getComputedTransform();\n    var toPathTransform = toPath.getComputedTransform();\n    function updateIdentityTransform() {\n        this.transform = null;\n    }\n    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform });\n    toPath.transform = null;\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    var tmpArr = [];\n    saveAndModifyMethod(toPath, 'buildPath', { replace: function (path) {\n            var t = toPath.__morphT;\n            var onet = 1 - t;\n            var newCp = [];\n            for (var i = 0; i < morphingData.length; i++) {\n                var item = morphingData[i];\n                var from = item.from;\n                var to = item.to;\n                var angle = item.rotation * t;\n                var fromCp = item.fromCp;\n                var toCp = item.toCp;\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                lerp(newCp, fromCp, toCp, t);\n                for (var m = 0; m < from.length; m += 2) {\n                    var x0_1 = from[m];\n                    var y0_1 = from[m + 1];\n                    var x1 = to[m];\n                    var y1 = to[m + 1];\n                    var x = x0_1 * onet + x1 * t;\n                    var y = y0_1 * onet + y1 * t;\n                    tmpArr[m] = (x * ca - y * sa) + newCp[0];\n                    tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n                }\n                var x0 = tmpArr[0];\n                var y0 = tmpArr[1];\n                path.moveTo(x0, y0);\n                for (var m = 2; m < from.length;) {\n                    var x1 = tmpArr[m++];\n                    var y1 = tmpArr[m++];\n                    var x2 = tmpArr[m++];\n                    var y2 = tmpArr[m++];\n                    var x3 = tmpArr[m++];\n                    var y3 = tmpArr[m++];\n                    if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n                        path.lineTo(x3, y3);\n                    }\n                    else {\n                        path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    }\n                    x0 = x3;\n                    y0 = y3;\n                }\n            }\n        } });\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    prepareMorphPath(fromPath, toPath);\n    toPath.__morphT = 0;\n    function restoreToPath() {\n        restoreMethod(toPath, 'buildPath');\n        restoreMethod(toPath, 'updateTransform');\n        toPath.__morphT = -1;\n        toPath.createPathProxy();\n        toPath.dirtyShape();\n    }\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreToPath();\n            oldDone && oldDone();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n    var bits = 16;\n    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n    var d = 0;\n    var tmp;\n    for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n        var rx = 0;\n        var ry = 0;\n        if ((x & s) > 0) {\n            rx = 1;\n        }\n        if ((y & s) > 0) {\n            ry = 1;\n        }\n        d += s * s * ((3 * rx) ^ ry);\n        if (ry === 0) {\n            if (rx === 1) {\n                x = s - 1 - x;\n                y = s - 1 - y;\n            }\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n    }\n    return d;\n}\nfunction sortPaths(pathList) {\n    var xMin = Infinity;\n    var yMin = Infinity;\n    var xMax = -Infinity;\n    var yMax = -Infinity;\n    var cps = map(pathList, function (path) {\n        var rect = path.getBoundingRect();\n        var m = path.getComputedTransform();\n        var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n        var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n        xMin = Math.min(x, xMin);\n        yMin = Math.min(y, yMin);\n        xMax = Math.max(x, xMax);\n        yMax = Math.max(y, yMax);\n        return [x, y];\n    });\n    var items = map(cps, function (cp, idx) {\n        return {\n            cp: cp,\n            z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n            path: pathList[idx]\n        };\n    });\n    return items.sort(function (a, b) { return a.z - b.z; }).map(function (item) { return item.path; });\n}\n;\nfunction defaultDividePath(param) {\n    return split(param.path, param.count);\n}\nfunction createEmptyReturn() {\n    return {\n        fromIndividuals: [],\n        toIndividuals: [],\n        count: 0\n    };\n}\nexport function combineMorph(fromList, toPath, animationOpts) {\n    var fromPathList = [];\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    addFromPath(fromList);\n    var separateCount = fromPathList.length;\n    if (!separateCount) {\n        return createEmptyReturn();\n    }\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    var toSubPathList = dividePath({\n        path: toPath, count: separateCount\n    });\n    if (toSubPathList.length !== separateCount) {\n        console.error('Invalid morphing: unmatched splitted path');\n        return createEmptyReturn();\n    }\n    fromPathList = sortPaths(fromPathList);\n    toSubPathList = sortPaths(toSubPathList);\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    var individualDelay = animationOpts.individualDelay;\n    var identityTransform = new Transformable();\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromPathList[i];\n        var to = toSubPathList[i];\n        to.parent = toPath;\n        to.copyTransform(identityTransform);\n        if (!individualDelay) {\n            prepareMorphPath(from, to);\n        }\n    }\n    toPath.__isCombineMorphing = true;\n    toPath.childrenRef = function () {\n        return toSubPathList;\n    };\n    function addToSubPathListToZr(zr) {\n        for (var i = 0; i < toSubPathList.length; i++) {\n            toSubPathList[i].addSelfToZr(zr);\n        }\n    }\n    saveAndModifyMethod(toPath, 'addSelfToZr', {\n        after: function (zr) {\n            addToSubPathListToZr(zr);\n        }\n    });\n    saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n        after: function (zr) {\n            for (var i = 0; i < toSubPathList.length; i++) {\n                toSubPathList[i].removeSelfFromZr(zr);\n            }\n        }\n    });\n    function restoreToPath() {\n        toPath.__isCombineMorphing = false;\n        toPath.__morphT = -1;\n        toPath.childrenRef = null;\n        restoreMethod(toPath, 'addSelfToZr');\n        restoreMethod(toPath, 'removeSelfFromZr');\n    }\n    var toLen = toSubPathList.length;\n    if (individualDelay) {\n        var animating_1 = toLen;\n        var eachDone = function () {\n            animating_1--;\n            if (animating_1 === 0) {\n                restoreToPath();\n                oldDone && oldDone();\n            }\n        };\n        for (var i = 0; i < toLen; i++) {\n            var indivdualAnimationOpts = individualDelay ? defaults({\n                delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n                done: eachDone\n            }, animationOpts) : animationOpts;\n            morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n        }\n    }\n    else {\n        toPath.__morphT = 0;\n        toPath.animateTo({\n            __morphT: 1\n        }, defaults({\n            during: function (p) {\n                for (var i = 0; i < toLen; i++) {\n                    var child = toSubPathList[i];\n                    child.__morphT = toPath.__morphT;\n                    child.dirtyShape();\n                }\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreToPath();\n                for (var i = 0; i < fromList.length; i++) {\n                    restoreMethod(fromList[i], 'updateTransform');\n                }\n                oldDone && oldDone();\n            }\n        }, animationOpts));\n    }\n    if (toPath.__zr) {\n        addToSubPathListToZr(toPath.__zr);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toSubPathList,\n        count: toLen\n    };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n    var toLen = toPathList.length;\n    var fromPathList = [];\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    if (isCombineMorphing(fromPath)) {\n        addFromPath(fromPath.childrenRef());\n        var fromLen = fromPathList.length;\n        if (fromLen < toLen) {\n            var k = 0;\n            for (var i = fromLen; i < toLen; i++) {\n                fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n            }\n        }\n        fromPathList.length = toLen;\n    }\n    else {\n        fromPathList = dividePath({ path: fromPath, count: toLen });\n        var fromPathTransform = fromPath.getComputedTransform();\n        for (var i = 0; i < fromPathList.length; i++) {\n            fromPathList[i].setLocalTransform(fromPathTransform);\n        }\n        if (fromPathList.length !== toLen) {\n            console.error('Invalid morphing: unmatched splitted path');\n            return createEmptyReturn();\n        }\n    }\n    fromPathList = sortPaths(fromPathList);\n    toPathList = sortPaths(toPathList);\n    var individualDelay = animationOpts.individualDelay;\n    for (var i = 0; i < toLen; i++) {\n        var indivdualAnimationOpts = individualDelay ? defaults({\n            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n        }, animationOpts) : animationOpts;\n        morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathList.length\n    };\n}\nexport { split as defaultDividePath };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}