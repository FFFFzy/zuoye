{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Arc\", {\n  enumerable: true,\n  get: function () {\n    return _Arc.default;\n  }\n});\nObject.defineProperty(exports, \"BezierCurve\", {\n  enumerable: true,\n  get: function () {\n    return _BezierCurve.default;\n  }\n});\nObject.defineProperty(exports, \"BoundingRect\", {\n  enumerable: true,\n  get: function () {\n    return _BoundingRect.default;\n  }\n});\nObject.defineProperty(exports, \"Circle\", {\n  enumerable: true,\n  get: function () {\n    return _Circle.default;\n  }\n});\nObject.defineProperty(exports, \"CompoundPath\", {\n  enumerable: true,\n  get: function () {\n    return _CompoundPath.default;\n  }\n});\nObject.defineProperty(exports, \"Ellipse\", {\n  enumerable: true,\n  get: function () {\n    return _Ellipse.default;\n  }\n});\nObject.defineProperty(exports, \"Group\", {\n  enumerable: true,\n  get: function () {\n    return _Group.default;\n  }\n});\nObject.defineProperty(exports, \"Image\", {\n  enumerable: true,\n  get: function () {\n    return _Image.default;\n  }\n});\nObject.defineProperty(exports, \"IncrementalDisplayable\", {\n  enumerable: true,\n  get: function () {\n    return _IncrementalDisplayable.default;\n  }\n});\nObject.defineProperty(exports, \"Line\", {\n  enumerable: true,\n  get: function () {\n    return _Line.default;\n  }\n});\nObject.defineProperty(exports, \"LinearGradient\", {\n  enumerable: true,\n  get: function () {\n    return _LinearGradient.default;\n  }\n});\nObject.defineProperty(exports, \"OrientedBoundingRect\", {\n  enumerable: true,\n  get: function () {\n    return _OrientedBoundingRect.default;\n  }\n});\nObject.defineProperty(exports, \"Path\", {\n  enumerable: true,\n  get: function () {\n    return _Path.default;\n  }\n});\nObject.defineProperty(exports, \"Point\", {\n  enumerable: true,\n  get: function () {\n    return _Point.default;\n  }\n});\nObject.defineProperty(exports, \"Polygon\", {\n  enumerable: true,\n  get: function () {\n    return _Polygon.default;\n  }\n});\nObject.defineProperty(exports, \"Polyline\", {\n  enumerable: true,\n  get: function () {\n    return _Polyline.default;\n  }\n});\nObject.defineProperty(exports, \"RadialGradient\", {\n  enumerable: true,\n  get: function () {\n    return _RadialGradient.default;\n  }\n});\nObject.defineProperty(exports, \"Rect\", {\n  enumerable: true,\n  get: function () {\n    return _Rect.default;\n  }\n});\nObject.defineProperty(exports, \"Ring\", {\n  enumerable: true,\n  get: function () {\n    return _Ring.default;\n  }\n});\nObject.defineProperty(exports, \"Sector\", {\n  enumerable: true,\n  get: function () {\n    return _Sector.default;\n  }\n});\nObject.defineProperty(exports, \"Text\", {\n  enumerable: true,\n  get: function () {\n    return _Text.default;\n  }\n});\nexports.applyTransform = applyTransform;\nexports.clipPointsByRect = clipPointsByRect;\nexports.clipRectByRect = clipRectByRect;\nexports.createIcon = createIcon;\nexports.extendPath = extendPath;\nexports.extendShape = extendShape;\nexports.getShapeClass = getShapeClass;\nexports.getTransform = getTransform;\nexports.groupTransition = groupTransition;\nObject.defineProperty(exports, \"initProps\", {\n  enumerable: true,\n  get: function () {\n    return _basicTrasition.initProps;\n  }\n});\nObject.defineProperty(exports, \"isElementRemoved\", {\n  enumerable: true,\n  get: function () {\n    return _basicTrasition.isElementRemoved;\n  }\n});\nexports.lineLineIntersect = lineLineIntersect;\nexports.linePolygonIntersect = linePolygonIntersect;\nexports.makeImage = makeImage;\nexports.makePath = makePath;\nexports.mergePath = void 0;\nexports.registerShape = registerShape;\nObject.defineProperty(exports, \"removeElement\", {\n  enumerable: true,\n  get: function () {\n    return _basicTrasition.removeElement;\n  }\n});\nObject.defineProperty(exports, \"removeElementWithFadeOut\", {\n  enumerable: true,\n  get: function () {\n    return _basicTrasition.removeElementWithFadeOut;\n  }\n});\nexports.resizePath = resizePath;\nexports.setTooltipConfig = setTooltipConfig;\nexports.subPixelOptimize = void 0;\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.transformDirection = transformDirection;\nexports.traverseElements = traverseElements;\nObject.defineProperty(exports, \"updateProps\", {\n  enumerable: true,\n  get: function () {\n    return _basicTrasition.updateProps;\n  }\n});\n\nvar pathTool = _interopRequireWildcard(require(\"zrender/lib/tool/path.js\"));\n\nvar matrix = _interopRequireWildcard(require(\"zrender/lib/core/matrix.js\"));\n\nvar vector = _interopRequireWildcard(require(\"zrender/lib/core/vector.js\"));\n\nvar _Path = _interopRequireDefault(require(\"zrender/lib/graphic/Path.js\"));\n\nvar _Transformable = _interopRequireDefault(require(\"zrender/lib/core/Transformable.js\"));\n\nvar _Image = _interopRequireDefault(require(\"zrender/lib/graphic/Image.js\"));\n\nvar _Group = _interopRequireDefault(require(\"zrender/lib/graphic/Group.js\"));\n\nvar _Text = _interopRequireDefault(require(\"zrender/lib/graphic/Text.js\"));\n\nvar _Circle = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Circle.js\"));\n\nvar _Ellipse = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Ellipse.js\"));\n\nvar _Sector = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Sector.js\"));\n\nvar _Ring = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Ring.js\"));\n\nvar _Polygon = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Polygon.js\"));\n\nvar _Polyline = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Polyline.js\"));\n\nvar _Rect = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Rect.js\"));\n\nvar _Line = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Line.js\"));\n\nvar _BezierCurve = _interopRequireDefault(require(\"zrender/lib/graphic/shape/BezierCurve.js\"));\n\nvar _Arc = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Arc.js\"));\n\nvar _CompoundPath = _interopRequireDefault(require(\"zrender/lib/graphic/CompoundPath.js\"));\n\nvar _LinearGradient = _interopRequireDefault(require(\"zrender/lib/graphic/LinearGradient.js\"));\n\nvar _RadialGradient = _interopRequireDefault(require(\"zrender/lib/graphic/RadialGradient.js\"));\n\nvar _BoundingRect = _interopRequireDefault(require(\"zrender/lib/core/BoundingRect.js\"));\n\nvar _OrientedBoundingRect = _interopRequireDefault(require(\"zrender/lib/core/OrientedBoundingRect.js\"));\n\nvar _Point = _interopRequireDefault(require(\"zrender/lib/core/Point.js\"));\n\nvar _IncrementalDisplayable = _interopRequireDefault(require(\"zrender/lib/graphic/IncrementalDisplayable.js\"));\n\nvar subPixelOptimizeUtil = _interopRequireWildcard(require(\"zrender/lib/graphic/helper/subPixelOptimize.js\"));\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _innerStore = require(\"./innerStore.js\");\n\nvar _basicTrasition = require(\"../animation/basicTrasition.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @deprecated export for compatitable reason\n */\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar _customShapeMap = {};\n/**\n * Extend shape with parameters\n */\n\nfunction extendShape(opts) {\n  return _Path.default.extend(opts);\n}\n\nvar extendPathFromString = pathTool.extendFromString;\n/**\n * Extend path\n */\n\nfunction extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\n * Register a user defined shape.\n * The shape class can be fetched by `getShapeClass`\n * This method will overwrite the registered shapes, including\n * the registered built-in shapes, if using the same `name`.\n * The shape can be used in `custom series` and\n * `graphic component` by declaring `{type: name}`.\n *\n * @param name\n * @param ShapeClass Can be generated by `extendShape`.\n */\n\n\nfunction registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\n * Find shape class registered by `registerShape`. Usually used in\n * fetching user defined shape.\n *\n * [Caution]:\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\n * to use user registered shapes.\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\n * `registerShape` by default. That enables users to get both built-in\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\n * the built-in shapes by using names like 'circle', 'rect' via calling\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\n * in case that it is overwritten by users, except that some features, like\n * `custom series`, `graphic component`, do it deliberately.\n *\n * (2) In the features like `custom series`, `graphic component`, the user input\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\n * are reserved names, that is, if some user register a shape named `'image'`,\n * the shape will not be used. If we intending to add some more reserved names\n * in feature, that might bring break changes (disable some existing user shape\n * names). But that case probably rearly happen. So we dont make more mechanism\n * to resolve this issue here.\n *\n * @param name\n * @return The shape class. If not found, return nothing.\n */\n\n\nfunction getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\n * Create a path element from path data string\n * @param pathData\n * @param opts\n * @param rect\n * @param layout 'center' or 'cover' default to be cover\n */\n\n\nfunction makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\n * Create a image element from image url\n * @param imageUrl image url\n * @param opts options\n * @param rect constrain rect\n * @param layout 'center' or 'cover'. Default to be 'cover'\n */\n\n\nfunction makeImage(imageUrl, rect, layout) {\n  var zrImg = new _Image.default({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  rect         element local bounding box\n * @param  boundingRect constraint bounding box\n * @return element position containing x, y, width, and height\n */\n\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nvar mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param path\n * @param rect\n */\n\nexports.mergePath = mergePath;\n\nfunction resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n */\n\n\nfunction subPixelOptimizeLine(param) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n */\n\n\nfunction subPixelOptimizeRect(param) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param position Coordinate, such as x, y\n * @param lineWidth Should be nonnegative integer.\n * @param positiveOrNegative Default false (negative).\n * @return Optimized position.\n */\n\n\nvar subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param target\n * @param [ancestor]\n */\n\nexports.subPixelOptimize = subPixelOptimize;\n\nfunction getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param target [x, y]\n * @param transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param invert Whether use invert matrix.\n * @return [x, y]\n */\n\n\nfunction applyTransform(target, transform, invert) {\n  if (transform && !(0, _util.isArrayLike)(transform)) {\n    transform = _Transformable.default.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param direction 'left' 'right' 'top' 'bottom'\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param invert Whether use invert matrix.\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\n\nfunction transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\n\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\n\nfunction groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n\n    if (isPath(el)) {\n      obj.shape = (0, _util.extend)({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        (0, _basicTrasition.updateProps)(el, newProp, animatableModel, (0, _innerStore.getECData)(el).dataIndex);\n      }\n    }\n  });\n}\n\nfunction clipPointsByRect(points, rect) {\n  // FIXME: this way migth be incorrect when grpahic clipped by a corner.\n  // and when element have border.\n  return (0, _util.map)(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * Return a new clipped rect. If rect size are negative, return undefined.\n */\n\n\nfunction clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n\nfunction createIcon(iconStr, // Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = (0, _util.extend)({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), (0, _util.defaults)(style, rect), new _Image.default(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\n * Return `true` if the given line (line `a`) and the given polygon\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\n\nfunction linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n\n    p2 = p;\n  }\n}\n/**\n * Return `true` if the given two lines (line `a` and line `b`)\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\n\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff\n  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  } // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n\n  if (q < 0 || q > 1) {\n    return false;\n  }\n\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Cross product of 2-dimension vector.\n */\n\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\n\nfunction setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = (0, _util.isString)(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n\n  if (formatterParamsExtra) {\n    (0, _util.each)((0, _util.keys)(formatterParamsExtra), function (key) {\n      if (!(0, _util.hasOwn)(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n\n  var ecData = (0, _innerStore.getECData)(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: (0, _util.defaults)({\n      content: itemName,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n}\n\nfunction traverseElement(el, cb) {\n  var stopped; // TODO\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\n\n  if (el.isGroup) {\n    stopped = cb(el);\n  }\n\n  if (!stopped) {\n    el.traverse(cb);\n  }\n}\n\nfunction traverseElements(els, cb) {\n  if (els) {\n    if ((0, _util.isArray)(els)) {\n      for (var i = 0; i < els.length; i++) {\n        traverseElement(els[i], cb);\n      }\n    } else {\n      traverseElement(els, cb);\n    }\n  }\n} // Register built-in shapes. These shapes might be overwirtten\n// by users, although we do not recommend that.\n\n\nregisterShape('circle', _Circle.default);\nregisterShape('ellipse', _Ellipse.default);\nregisterShape('sector', _Sector.default);\nregisterShape('ring', _Ring.default);\nregisterShape('polygon', _Polygon.default);\nregisterShape('polyline', _Polyline.default);\nregisterShape('rect', _Rect.default);\nregisterShape('line', _Line.default);\nregisterShape('bezierCurve', _BezierCurve.default);\nregisterShape('arc', _Arc.default);","map":{"version":3,"names":["mathMax","Math","max","mathMin","min","_customShapeMap","extendShape","opts","Path","extend","extendPathFromString","pathTool","extendFromString","extendPath","pathData","registerShape","name","ShapeClass","getShapeClass","hasOwnProperty","makePath","rect","layout","path","createFromString","centerGraphic","getBoundingRect","resizePath","makeImage","imageUrl","zrImg","ZRImage","style","image","x","y","width","height","onload","img","boundingRect","setStyle","aspect","cx","cy","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimizeUtil","shape","subPixelOptimizeRect","subPixelOptimize","getTransform","target","ancestor","mat","matrix","identity","mul","getLocalTransform","parent","transform","invert","isArrayLike","Transformable","vector","transformDirection","direction","hBase","abs","vBase","vertex","isNotGroup","el","isGroup","isPath","groupTransition","g1","g2","animatableModel","getElMap","g","elMap","traverse","anid","getAnimatableProps","obj","rotation","elMap1","oldEl","newProp","attr","updateProps","getECData","dataIndex","clipPointsByRect","points","map","point","clipRectByRect","targetRect","x2","y2","createIcon","iconStr","opt","innerOpts","rectHover","strokeNoScale","indexOf","slice","defaults","replace","linePolygonIntersect","a1x","a1y","a2x","a2y","i","p2","length","p","lineLineIntersect","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","crossProduct2d","nearZero","b1a1x","b1a1y","q","x1","y1","val","setTooltipConfig","itemTooltipOption","componentModel","itemName","itemTooltipOptionObj","isString","formatter","mainType","componentIndex","formatterParams","componentType","$vars","formatterParamsExtra","each","keys","key","hasOwn","push","ecData","componentMainType","tooltipConfig","option","content","traverseElement","cb","stopped","traverseElements","els","isArray","Circle","Ellipse","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/util/graphic.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as pathTool from 'zrender/lib/tool/path.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport Transformable from 'zrender/lib/core/Transformable.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport ZRText from 'zrender/lib/graphic/Text.js';\nimport Circle from 'zrender/lib/graphic/shape/Circle.js';\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse.js';\nimport Sector from 'zrender/lib/graphic/shape/Sector.js';\nimport Ring from 'zrender/lib/graphic/shape/Ring.js';\nimport Polygon from 'zrender/lib/graphic/shape/Polygon.js';\nimport Polyline from 'zrender/lib/graphic/shape/Polyline.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport Line from 'zrender/lib/graphic/shape/Line.js';\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve.js';\nimport Arc from 'zrender/lib/graphic/shape/Arc.js';\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath.js';\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient.js';\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect.js';\nimport Point from 'zrender/lib/core/Point.js';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable.js';\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { extend, isArrayLike, map, defaults, isString, keys, each, hasOwn, isArray } from 'zrender/lib/core/util.js';\nimport { getECData } from './innerStore.js';\nimport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved } from '../animation/basicTrasition.js';\n/**\n * @deprecated export for compatitable reason\n */\n\nexport { updateProps, initProps, removeElement, removeElementWithFadeOut, isElementRemoved };\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar _customShapeMap = {};\n/**\n * Extend shape with parameters\n */\n\nexport function extendShape(opts) {\n  return Path.extend(opts);\n}\nvar extendPathFromString = pathTool.extendFromString;\n/**\n * Extend path\n */\n\nexport function extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\n * Register a user defined shape.\n * The shape class can be fetched by `getShapeClass`\n * This method will overwrite the registered shapes, including\n * the registered built-in shapes, if using the same `name`.\n * The shape can be used in `custom series` and\n * `graphic component` by declaring `{type: name}`.\n *\n * @param name\n * @param ShapeClass Can be generated by `extendShape`.\n */\n\nexport function registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\n * Find shape class registered by `registerShape`. Usually used in\n * fetching user defined shape.\n *\n * [Caution]:\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\n * to use user registered shapes.\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\n * `registerShape` by default. That enables users to get both built-in\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\n * the built-in shapes by using names like 'circle', 'rect' via calling\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\n * in case that it is overwritten by users, except that some features, like\n * `custom series`, `graphic component`, do it deliberately.\n *\n * (2) In the features like `custom series`, `graphic component`, the user input\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\n * are reserved names, that is, if some user register a shape named `'image'`,\n * the shape will not be used. If we intending to add some more reserved names\n * in feature, that might bring break changes (disable some existing user shape\n * names). But that case probably rearly happen. So we dont make more mechanism\n * to resolve this issue here.\n *\n * @param name\n * @return The shape class. If not found, return nothing.\n */\n\nexport function getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\n * Create a path element from path data string\n * @param pathData\n * @param opts\n * @param rect\n * @param layout 'center' or 'cover' default to be cover\n */\n\nexport function makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\n * Create a image element from image url\n * @param imageUrl image url\n * @param opts options\n * @param rect constrain rect\n * @param layout 'center' or 'cover'. Default to be 'cover'\n */\n\nexport function makeImage(imageUrl, rect, layout) {\n  var zrImg = new ZRImage({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  rect         element local bounding box\n * @param  boundingRect constraint bounding box\n * @return element position containing x, y, width, and height\n */\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nexport var mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param path\n * @param rect\n */\n\nexport function resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n */\n\nexport function subPixelOptimizeLine(param) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n */\n\nexport function subPixelOptimizeRect(param) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param position Coordinate, such as x, y\n * @param lineWidth Should be nonnegative integer.\n * @param positiveOrNegative Default false (negative).\n * @return Optimized position.\n */\n\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param target\n * @param [ancestor]\n */\n\nexport function getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param target [x, y]\n * @param transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param invert Whether use invert matrix.\n * @return [x, y]\n */\n\nexport function applyTransform(target, transform, invert) {\n  if (transform && !isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param direction 'left' 'right' 'top' 'bottom'\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param invert Whether use invert matrix.\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\nexport function transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\n\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\n\nexport function groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n\n    if (isPath(el)) {\n      obj.shape = extend({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n      }\n    }\n  });\n}\nexport function clipPointsByRect(points, rect) {\n  // FIXME: this way migth be incorrect when grpahic clipped by a corner.\n  // and when element have border.\n  return map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * Return a new clipped rect. If rect size are negative, return undefined.\n */\n\nexport function clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nexport function createIcon(iconStr, // Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = extend({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\n * Return `true` if the given line (line `a`) and the given polygon\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n\n    p2 = p;\n  }\n}\n/**\n * Return `true` if the given two lines (line `a` and line `b`)\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff\n  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  } // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n\n  if (q < 0 || q > 1) {\n    return false;\n  }\n\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Cross product of 2-dimension vector.\n */\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\n\nexport function setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n\n  if (formatterParamsExtra) {\n    each(keys(formatterParamsExtra), function (key) {\n      if (!hasOwn(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n\n  var ecData = getECData(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: defaults({\n      content: itemName,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n}\n\nfunction traverseElement(el, cb) {\n  var stopped; // TODO\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\n\n  if (el.isGroup) {\n    stopped = cb(el);\n  }\n\n  if (!stopped) {\n    el.traverse(cb);\n  }\n}\n\nexport function traverseElements(els, cb) {\n  if (els) {\n    if (isArray(els)) {\n      for (var i = 0; i < els.length; i++) {\n        traverseElement(els[i], cb);\n      }\n    } else {\n      traverseElement(els, cb);\n    }\n  }\n} // Register built-in shapes. These shapes might be overwirtten\n// by users, although we do not recommend that.\n\nregisterShape('circle', Circle);\nregisterShape('ellipse', Ellipse);\nregisterShape('sector', Sector);\nregisterShape('ring', Ring);\nregisterShape('polygon', Polygon);\nregisterShape('polyline', Polyline);\nregisterShape('rect', Rect);\nregisterShape('line', Line);\nregisterShape('bezierCurve', BezierCurve);\nregisterShape('arc', Arc);\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA8BA;AACA;AACA;AAGA,IAAIA,OAAO,GAAGC,IAAI,CAACC,GAAnB;AACA,IAAIC,OAAO,GAAGF,IAAI,CAACG,GAAnB;AACA,IAAIC,eAAe,GAAG,EAAtB;AACA;AACA;AACA;;AAEO,SAASC,WAAT,CAAqBC,IAArB,EAA2B;EAChC,OAAOC,aAAA,CAAKC,MAAL,CAAYF,IAAZ,CAAP;AACD;;AACD,IAAIG,oBAAoB,GAAGC,QAAQ,CAACC,gBAApC;AACA;AACA;AACA;;AAEO,SAASC,UAAT,CAAoBC,QAApB,EAA8BP,IAA9B,EAAoC;EACzC,OAAOG,oBAAoB,CAACI,QAAD,EAAWP,IAAX,CAA3B;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEO,SAASQ,aAAT,CAAuBC,IAAvB,EAA6BC,UAA7B,EAAyC;EAC9CZ,eAAe,CAACW,IAAD,CAAf,GAAwBC,UAAxB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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"},"metadata":{},"sourceType":"script"}