{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScaleRawExtentInfo = void 0;\nexports.ensureScaleRawExtentInfo = ensureScaleRawExtentInfo;\nexports.parseAxisModelMinMax = parseAxisModelMinMax;\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _text = require(\"zrender/lib/contain/text.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar ScaleRawExtentInfo =\n/** @class */\nfunction () {\n  function ScaleRawExtentInfo(scale, model, // Usually: data extent from all series on this axis.\n  originalExtent) {\n    this._prepareParams(scale, model, originalExtent);\n  }\n  /**\n   * Parameters depending on ouside (like model, user callback)\n   * are prepared and fixed here.\n   */\n\n\n  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, // Usually: data extent from all series on this axis.\n  dataExtent) {\n    if (dataExtent[1] < dataExtent[0]) {\n      dataExtent = [NaN, NaN];\n    }\n\n    this._dataMin = dataExtent[0];\n    this._dataMax = dataExtent[1];\n    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';\n    this._needCrossZero = scale.type === 'interval' && model.getNeedCrossZero && model.getNeedCrossZero();\n    var modelMinRaw = this._modelMinRaw = model.get('min', true);\n\n    if ((0, _util.isFunction)(modelMinRaw)) {\n      // This callback alway provide users the full data extent (before data filtered).\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMinRaw !== 'dataMin') {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);\n    }\n\n    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);\n\n    if ((0, _util.isFunction)(modelMaxRaw)) {\n      // This callback alway provide users the full data extent (before data filtered).\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMaxRaw !== 'dataMax') {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);\n    }\n\n    if (isOrdinal) {\n      // FIXME: there is a flaw here: if there is no \"block\" data processor like `dataZoom`,\n      // and progressive rendering is using, here the category result might just only contain\n      // the processed chunk rather than the entire result.\n      this._axisDataLen = model.getCategories().length;\n    } else {\n      var boundaryGap = model.get('boundaryGap');\n      var boundaryGapArr = (0, _util.isArray)(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];\n\n      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., \"20%\". Currently, ' + 'boundaryGap is set to be 0.');\n        }\n\n        this._boundaryGapInner = [0, 0];\n      } else {\n        this._boundaryGapInner = [(0, _text.parsePercent)(boundaryGapArr[0], 1), (0, _text.parsePercent)(boundaryGapArr[1], 1)];\n      }\n    }\n  };\n  /**\n   * Calculate extent by prepared parameters.\n   * This method has no external dependency and can be called duplicatedly,\n   * getting the same result.\n   * If parameters changed, should call this method to recalcuate.\n   */\n\n\n  ScaleRawExtentInfo.prototype.calculate = function () {\n    // Notice: When min/max is not set (that is, when there are null/undefined,\n    // which is the most common case), these cases should be ensured:\n    // (1) For 'ordinal', show all axis.data.\n    // (2) For others:\n    //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n    //      disabled).\n    //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n    //      be the result that originalExtent enlarged by boundaryGap.\n    // (3) If no data, it should be ensured that `scale.setBlank` is set.\n    var isOrdinal = this._isOrdinal;\n    var dataMin = this._dataMin;\n    var dataMax = this._dataMax;\n    var axisDataLen = this._axisDataLen;\n    var boundaryGapInner = this._boundaryGapInner;\n    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null; // Currently if a `'value'` axis model min is specified as 'dataMin'/'dataMax',\n    // `boundaryGap` will not be used. It's the different from specifying as `null`/`undefined`.\n\n    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;\n    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum; // If `_modelMinNum`/`_modelMaxNum` is `null`/`undefined`, should not be fixed.\n\n    var minFixed = min != null;\n    var maxFixed = max != null;\n\n    if (min == null) {\n      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;\n    }\n\n    if (max == null) {\n      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;\n    }\n\n    (min == null || !isFinite(min)) && (min = NaN);\n    (max == null || !isFinite(max)) && (max = NaN);\n    var isBlank = (0, _util.eqNaN)(min) || (0, _util.eqNaN)(max) || isOrdinal && !axisDataLen; // If data extent modified, need to recalculated to ensure cross zero.\n\n    if (this._needCrossZero) {\n      // Axis is over zero and min is not set\n      if (min > 0 && max > 0 && !minFixed) {\n        min = 0; // minFixed = true;\n      } // Axis is under zero and max is not set\n\n\n      if (min < 0 && max < 0 && !maxFixed) {\n        max = 0; // maxFixed = true;\n      } // PENDING:\n      // When `needCrossZero` and all data is positive/negative, should it be ensured\n      // that the results processed by boundaryGap are positive/negative?\n      // If so, here `minFixed`/`maxFixed` need to be set.\n\n    }\n\n    var determinedMin = this._determinedMin;\n    var determinedMax = this._determinedMax;\n\n    if (determinedMin != null) {\n      min = determinedMin;\n      minFixed = true;\n    }\n\n    if (determinedMax != null) {\n      max = determinedMax;\n      maxFixed = true;\n    } // Ensure min/max be finite number or NaN here. (not to be null/undefined)\n    // `NaN` means min/max axis is blank.\n\n\n    return {\n      min: min,\n      max: max,\n      minFixed: minFixed,\n      maxFixed: maxFixed,\n      isBlank: isBlank\n    };\n  };\n\n  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(!this.frozen);\n    }\n\n    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {\n    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];\n\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(!this.frozen // Earse them usually means logic flaw.\n      && this[attr] == null);\n    }\n\n    this[attr] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.freeze = function () {\n    // @ts-ignore\n    this.frozen = true;\n  };\n\n  return ScaleRawExtentInfo;\n}();\n\nexports.ScaleRawExtentInfo = ScaleRawExtentInfo;\nvar DETERMINED_MIN_MAX_ATTR = {\n  min: '_determinedMin',\n  max: '_determinedMax'\n};\nvar DATA_MIN_MAX_ATTR = {\n  min: '_dataMin',\n  max: '_dataMax'\n};\n/**\n * Get scale min max and related info only depends on model settings.\n * This method can be called after coordinate system created.\n * For example, in data processing stage.\n *\n * Scale extent info probably be required multiple times during a workflow.\n * For example:\n * (1) `dataZoom` depends it to get the axis extent in \"100%\" state.\n * (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.\n * (3) `coordSys.update` use it to finally decide the scale extent.\n * But the callback of `min`/`max` should not be called multiple times.\n * The code below should not be implemented repeatedly either.\n * So we cache the result in the scale instance, which will be recreated at the begining\n * of the workflow (because `scale` instance will be recreated each round of the workflow).\n */\n\nfunction ensureScaleRawExtentInfo(scale, model, // Usually: data extent from all series on this axis.\noriginalExtent) {\n  // Do not permit to recreate.\n  var rawExtentInfo = scale.rawExtentInfo;\n\n  if (rawExtentInfo) {\n    return rawExtentInfo;\n  }\n\n  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent); // @ts-ignore\n\n  scale.rawExtentInfo = rawExtentInfo;\n  return rawExtentInfo;\n}\n\nfunction parseAxisModelMinMax(scale, minMax) {\n  return minMax == null ? null : (0, _util.eqNaN)(minMax) ? NaN : scale.parse(minMax);\n}","map":{"version":3,"names":["ScaleRawExtentInfo","scale","model","originalExtent","_prepareParams","prototype","dataExtent","NaN","_dataMin","_dataMax","isOrdinal","_isOrdinal","type","_needCrossZero","getNeedCrossZero","modelMinRaw","_modelMinRaw","get","isFunction","_modelMinNum","parseAxisModelMinMax","min","max","modelMaxRaw","_modelMaxRaw","_modelMaxNum","_axisDataLen","getCategories","length","boundaryGap","boundaryGapArr","isArray","process","env","NODE_ENV","console","warn","_boundaryGapInner","parsePercent","calculate","dataMin","dataMax","axisDataLen","boundaryGapInner","span","Math","abs","minFixed","maxFixed","isFinite","isBlank","eqNaN","determinedMin","_determinedMin","determinedMax","_determinedMax","modifyDataMinMax","minMaxName","val","assert","frozen","DATA_MIN_MAX_ATTR","setDeterminedMinMax","attr","DETERMINED_MIN_MAX_ATTR","freeze","ensureScaleRawExtentInfo","rawExtentInfo","minMax","parse"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/coord/scaleRawExtentInfo.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, isArray, eqNaN, isFunction } from 'zrender/lib/core/util.js';\nimport { parsePercent } from 'zrender/lib/contain/text.js';\n\nvar ScaleRawExtentInfo =\n/** @class */\nfunction () {\n  function ScaleRawExtentInfo(scale, model, // Usually: data extent from all series on this axis.\n  originalExtent) {\n    this._prepareParams(scale, model, originalExtent);\n  }\n  /**\n   * Parameters depending on ouside (like model, user callback)\n   * are prepared and fixed here.\n   */\n\n\n  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, // Usually: data extent from all series on this axis.\n  dataExtent) {\n    if (dataExtent[1] < dataExtent[0]) {\n      dataExtent = [NaN, NaN];\n    }\n\n    this._dataMin = dataExtent[0];\n    this._dataMax = dataExtent[1];\n    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';\n    this._needCrossZero = scale.type === 'interval' && model.getNeedCrossZero && model.getNeedCrossZero();\n    var modelMinRaw = this._modelMinRaw = model.get('min', true);\n\n    if (isFunction(modelMinRaw)) {\n      // This callback alway provide users the full data extent (before data filtered).\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMinRaw !== 'dataMin') {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);\n    }\n\n    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);\n\n    if (isFunction(modelMaxRaw)) {\n      // This callback alway provide users the full data extent (before data filtered).\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMaxRaw !== 'dataMax') {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);\n    }\n\n    if (isOrdinal) {\n      // FIXME: there is a flaw here: if there is no \"block\" data processor like `dataZoom`,\n      // and progressive rendering is using, here the category result might just only contain\n      // the processed chunk rather than the entire result.\n      this._axisDataLen = model.getCategories().length;\n    } else {\n      var boundaryGap = model.get('boundaryGap');\n      var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];\n\n      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., \"20%\". Currently, ' + 'boundaryGap is set to be 0.');\n        }\n\n        this._boundaryGapInner = [0, 0];\n      } else {\n        this._boundaryGapInner = [parsePercent(boundaryGapArr[0], 1), parsePercent(boundaryGapArr[1], 1)];\n      }\n    }\n  };\n  /**\n   * Calculate extent by prepared parameters.\n   * This method has no external dependency and can be called duplicatedly,\n   * getting the same result.\n   * If parameters changed, should call this method to recalcuate.\n   */\n\n\n  ScaleRawExtentInfo.prototype.calculate = function () {\n    // Notice: When min/max is not set (that is, when there are null/undefined,\n    // which is the most common case), these cases should be ensured:\n    // (1) For 'ordinal', show all axis.data.\n    // (2) For others:\n    //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n    //      disabled).\n    //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n    //      be the result that originalExtent enlarged by boundaryGap.\n    // (3) If no data, it should be ensured that `scale.setBlank` is set.\n    var isOrdinal = this._isOrdinal;\n    var dataMin = this._dataMin;\n    var dataMax = this._dataMax;\n    var axisDataLen = this._axisDataLen;\n    var boundaryGapInner = this._boundaryGapInner;\n    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null; // Currently if a `'value'` axis model min is specified as 'dataMin'/'dataMax',\n    // `boundaryGap` will not be used. It's the different from specifying as `null`/`undefined`.\n\n    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;\n    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum; // If `_modelMinNum`/`_modelMaxNum` is `null`/`undefined`, should not be fixed.\n\n    var minFixed = min != null;\n    var maxFixed = max != null;\n\n    if (min == null) {\n      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;\n    }\n\n    if (max == null) {\n      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;\n    }\n\n    (min == null || !isFinite(min)) && (min = NaN);\n    (max == null || !isFinite(max)) && (max = NaN);\n    var isBlank = eqNaN(min) || eqNaN(max) || isOrdinal && !axisDataLen; // If data extent modified, need to recalculated to ensure cross zero.\n\n    if (this._needCrossZero) {\n      // Axis is over zero and min is not set\n      if (min > 0 && max > 0 && !minFixed) {\n        min = 0; // minFixed = true;\n      } // Axis is under zero and max is not set\n\n\n      if (min < 0 && max < 0 && !maxFixed) {\n        max = 0; // maxFixed = true;\n      } // PENDING:\n      // When `needCrossZero` and all data is positive/negative, should it be ensured\n      // that the results processed by boundaryGap are positive/negative?\n      // If so, here `minFixed`/`maxFixed` need to be set.\n\n    }\n\n    var determinedMin = this._determinedMin;\n    var determinedMax = this._determinedMax;\n\n    if (determinedMin != null) {\n      min = determinedMin;\n      minFixed = true;\n    }\n\n    if (determinedMax != null) {\n      max = determinedMax;\n      maxFixed = true;\n    } // Ensure min/max be finite number or NaN here. (not to be null/undefined)\n    // `NaN` means min/max axis is blank.\n\n\n    return {\n      min: min,\n      max: max,\n      minFixed: minFixed,\n      maxFixed: maxFixed,\n      isBlank: isBlank\n    };\n  };\n\n  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this.frozen);\n    }\n\n    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {\n    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this.frozen // Earse them usually means logic flaw.\n      && this[attr] == null);\n    }\n\n    this[attr] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.freeze = function () {\n    // @ts-ignore\n    this.frozen = true;\n  };\n\n  return ScaleRawExtentInfo;\n}();\n\nexport { ScaleRawExtentInfo };\nvar DETERMINED_MIN_MAX_ATTR = {\n  min: '_determinedMin',\n  max: '_determinedMax'\n};\nvar DATA_MIN_MAX_ATTR = {\n  min: '_dataMin',\n  max: '_dataMax'\n};\n/**\n * Get scale min max and related info only depends on model settings.\n * This method can be called after coordinate system created.\n * For example, in data processing stage.\n *\n * Scale extent info probably be required multiple times during a workflow.\n * For example:\n * (1) `dataZoom` depends it to get the axis extent in \"100%\" state.\n * (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.\n * (3) `coordSys.update` use it to finally decide the scale extent.\n * But the callback of `min`/`max` should not be called multiple times.\n * The code below should not be implemented repeatedly either.\n * So we cache the result in the scale instance, which will be recreated at the begining\n * of the workflow (because `scale` instance will be recreated each round of the workflow).\n */\n\nexport function ensureScaleRawExtentInfo(scale, model, // Usually: data extent from all series on this axis.\noriginalExtent) {\n  // Do not permit to recreate.\n  var rawExtentInfo = scale.rawExtentInfo;\n\n  if (rawExtentInfo) {\n    return rawExtentInfo;\n  }\n\n  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent); // @ts-ignore\n\n  scale.rawExtentInfo = rawExtentInfo;\n  return rawExtentInfo;\n}\nexport function parseAxisModelMinMax(scale, minMax) {\n  return minMax == null ? null : eqNaN(minMax) ? NaN : scale.parse(minMax);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}