{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar graphic = _interopRequireWildcard(require(\"../../util/graphic.js\"));\n\nvar _innerStore = require(\"../../util/innerStore.js\");\n\nvar _labelStyle = require(\"../../label/labelStyle.js\");\n\nvar _Model = _interopRequireDefault(require(\"../../model/Model.js\"));\n\nvar _number = require(\"../../util/number.js\");\n\nvar _symbol = require(\"../../util/symbol.js\");\n\nvar matrixUtil = _interopRequireWildcard(require(\"zrender/lib/core/matrix.js\"));\n\nvar _vector = require(\"zrender/lib/core/vector.js\");\n\nvar _axisHelper = require(\"../../coord/axisHelper.js\");\n\nvar _labelLayoutHelper = require(\"../../label/labelLayoutHelper.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n */\n\nvar AxisBuilder =\n/** @class */\nfunction () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel; // Default value\n\n    (0, _util.defaults)(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    }); // FIXME Not use a seperate text group?\n\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    }); // this.group.add(transformGroup);\n    // this._transformGroup = transformGroup;\n\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = (0, _number.remRadian)(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if ((0, _number.isRadianAroundZero)(rotationDiff)) {\n      // Label is parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if ((0, _number.isRadianAroundZero)(rotationDiff - PI)) {\n      // Label is inverse parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      (0, _vector.applyTransform)(pt1, pt1, matrix);\n      (0, _vector.applyTransform)(pt2, pt2, matrix);\n    }\n\n    var lineStyle = (0, _util.extend)({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      // Id for animation\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n\n    if (arrows != null) {\n      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n\n      if ((0, _util.isString)(arrows)) {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if ((0, _util.isString)(arrowSize) || (0, _util.isNumber)(arrowSize)) {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var arrowOffset = (0, _symbol.normalizeSymbolOffset)(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      (0, _util.each)([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = (0, _symbol.createSymbol)(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt1[0] + r * Math.cos(opt.rotation),\n            y: pt1[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection); // This bit fixes the label overlap issue for the time chart.\n    // See https://github.com/apache/echarts/issues/14266 for more.\n\n    if (axisModel.get(['axisLabel', 'hideOverlap'])) {\n      var labelList = (0, _labelLayoutHelper.prepareLayoutList)((0, _util.map)(labelEls, function (label) {\n        return {\n          label: label,\n          priority: label.z2,\n          defaultAttr: {\n            ignore: label.ignore\n          }\n        };\n      }));\n      (0, _labelLayoutHelper.hideOverlap)(labelList);\n    }\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = (0, _util.retrieve)(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = (0, _util.retrieve)(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: (0, _labelStyle.createTextStyle)(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    graphic.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: name\n    });\n    textEl.__fullText = name; // Id for animation\n\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      (0, _innerStore.getECData)(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = (0, _number.remRadian)(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if ((0, _number.isRadianAroundZero)(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if ((0, _number.isRadianAroundZero)(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if ((0, _axisHelper.shouldShowAllLabels)(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      (0, _vector.applyTransform)(pt1, pt1, tickTransform);\n      (0, _vector.applyTransform)(pt2, pt2, tickTransform);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line({\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, (0, _util.defaults)(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = (0, _util.defaults)(lineStyleModel.getLineStyle(), (0, _util.defaults)(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = (0, _util.retrieve)(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = ((0, _util.retrieve)(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  (0, _util.each)(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if ((0, _util.isObject)(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new _Model.default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10 + (labelItem.level || 0),\n      style: (0, _labelStyle.createTextStyle)(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: (0, _util.isFunction)(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        // (2) Compatible with previous version, which always use formatted label as\n        // input. But in interval scale the formatted label is like '223,445', which\n        // maked user repalce ','. So we modify it to return original val but remain\n        // it as 'string' to avoid error in replacing.\n        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue; // Pack data for mouse event\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      eventData.tickIndex = index;\n\n      if (axis.type === 'category') {\n        eventData.dataIndex = tickValue;\n      }\n\n      (0, _innerStore.getECData)(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nexports.default = _default;","map":{"version":3,"names":["PI","Math","AxisBuilder","axisModel","opt","group","graphic","Group","defaults","labelOffset","nameDirection","tickDirection","labelDirection","silent","handleAutoShown","transformGroup","x","position","y","rotation","updateTransform","_transformGroup","prototype","hasBuilder","name","builders","add","getGroup","innerTextLayout","axisRotation","textRotation","direction","rotationDiff","remRadian","textAlign","textVerticalAlign","isRadianAroundZero","makeAxisEventDataBase","eventData","componentType","mainType","componentIndex","isLabelSilent","tooltipOpt","get","show","axisLine","shown","extent","axis","getExtent","matrix","transform","pt1","pt2","v2ApplyTransform","lineStyle","extend","lineCap","getModel","getLineStyle","line","Line","subPixelOptimize","shape","x1","y1","x2","y2","style","strokeContainThreshold","z2","anid","arrows","arrowSize","isString","isNumber","arrowOffset","normalizeSymbolOffset","symbolWidth_1","symbolHeight_1","each","rotate","offset","r","sqrt","point","index","symbol","createSymbol","stroke","attr","cos","sin","axisTickLabel","ticksEls","buildAxisMajorTicks","labelEls","buildAxisLabel","fixMinMaxLabelShow","buildAxisMinorTicks","labelList","prepareLayoutList","map","label","priority","defaultAttr","ignore","hideOverlap","axisName","retrieve","nameLocation","textStyleModel","gap","gapSignal","pos","isNameLocationCenter","labelLayout","nameRotation","axisNameAvailableWidth","endTextLayout","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","textEl","Text","createTextStyle","text","font","overflow","width","fill","getTextColor","align","verticalAlign","setTooltipConfig","el","componentModel","itemName","__fullText","targetType","getECData","decomposeTransform","textPosition","textRotate","inverse","onLeft","tickEls","shouldShowAllLabels","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","length","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","current","next","firstRect","getBoundingRect","clone","nextRect","mRotationBack","matrixUtil","identity","applyTransform","mul","getLocalTransform","intersect","createTicks","ticksCoords","tickTransform","tickEndCoord","tickLineStyle","anidPrefix","i","tickCoord","coord","tickEl","autoBatch","tickValue","push","tickModel","scale","isBlank","lineStyleModel","getTicksCoords","minorTickModel","minorTicksCoords","getMinorTicksCoords","minorTickLineStyle","minorTicksEls","k","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","rawCategoryData","getCategories","triggerEvent","labelItem","type","getRawOrdinalNumber","formattedLabel","rawLabel","itemLabelModel","rawCategoryItem","isObject","textStyle","Model","ecModel","textColor","dataToCoord","level","getShallow","isFunction","value","tickIndex","dataIndex"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/component/axis/AxisBuilder.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { retrieve, defaults, extend, each, isObject, map, isString, isNumber, isFunction } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { createTextStyle } from '../../label/labelStyle.js';\nimport Model from '../../model/Model.js';\nimport { isRadianAroundZero, remRadian } from '../../util/number.js';\nimport { createSymbol, normalizeSymbolOffset } from '../../util/symbol.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { applyTransform as v2ApplyTransform } from 'zrender/lib/core/vector.js';\nimport { shouldShowAllLabels } from '../../coord/axisHelper.js';\nimport { prepareLayoutList, hideOverlap } from '../../label/labelLayoutHelper.js';\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n */\n\nvar AxisBuilder =\n/** @class */\nfunction () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel; // Default value\n\n    defaults(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    }); // FIXME Not use a seperate text group?\n\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    }); // this.group.add(transformGroup);\n    // this._transformGroup = transformGroup;\n\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (isRadianAroundZero(rotationDiff)) {\n      // Label is parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if (isRadianAroundZero(rotationDiff - PI)) {\n      // Label is inverse parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      // Id for animation\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n\n    if (arrows != null) {\n      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n\n      if (isString(arrows)) {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (isString(arrowSize) || isNumber(arrowSize)) {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var arrowOffset = normalizeSymbolOffset(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt1[0] + r * Math.cos(opt.rotation),\n            y: pt1[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection); // This bit fixes the label overlap issue for the time chart.\n    // See https://github.com/apache/echarts/issues/14266 for more.\n\n    if (axisModel.get(['axisLabel', 'hideOverlap'])) {\n      var labelList = prepareLayoutList(map(labelEls, function (label) {\n        return {\n          label: label,\n          priority: label.z2,\n          defaultAttr: {\n            ignore: label.ignore\n          }\n        };\n      }));\n      hideOverlap(labelList);\n    }\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: createTextStyle(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    graphic.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: name\n    });\n    textEl.__fullText = name; // Id for animation\n\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (shouldShowAllLabels(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      v2ApplyTransform(pt1, pt1, tickTransform);\n      v2ApplyTransform(pt2, pt2, tickTransform);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line({\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10 + (labelItem.level || 0),\n      style: createTextStyle(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: isFunction(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        // (2) Compatible with previous version, which always use formatted label as\n        // input. But in interval scale the formatted label is like '223,445', which\n        // maked user repalce ','. So we modify it to return original val but remain\n        // it as 'string' to avoid error in replacing.\n        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue; // Pack data for mouse event\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      eventData.tickIndex = index;\n\n      if (axis.type === 'category') {\n        eventData.dataIndex = tickValue;\n      }\n\n      getECData(textEl).eventData = eventData;\n    } // FIXME\n\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nexport default AxisBuilder;"],"mappings":"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"},"metadata":{},"sourceType":"script"}