{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar _BoundingRect = _interopRequireDefault(require(\"zrender/lib/core/BoundingRect.js\"));\n\nvar _number = require(\"../../util/number.js\");\n\nvar layout = _interopRequireWildcard(require(\"../../util/layout.js\"));\n\nvar helper = _interopRequireWildcard(require(\"../helper/treeHelper.js\"));\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/*\n* A third-party license is embeded for some of the code in this file:\n* The treemap layout implementation was originally copied from\n* \"d3.js\" with some modifications made for this project.\n* (See more details in the comment of the method \"squarify\" below.)\n* The use of the source code of this file is also subject to the terms\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\n* </licenses/LICENSE-d3>).\n*/\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar retrieveValue = zrUtil.retrieve;\nvar each = zrUtil.each;\nvar PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];\n;\n/**\n * @public\n */\n\nvar _default = {\n  seriesType: 'treemap',\n  reset: function (seriesModel, ecModel, api, payload) {\n    // Layout result in each node:\n    // {x, y, width, height, area, borderWidth}\n    var ecWidth = api.getWidth();\n    var ecHeight = api.getHeight();\n    var seriesOption = seriesModel.option;\n    var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    var size = seriesOption.size || []; // Compatible with ec2.\n\n    var containerWidth = (0, _number.parsePercent)(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n    var containerHeight = (0, _number.parsePercent)(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.\n\n    var payloadType = payload && payload.type;\n    var types = ['treemapZoomToNode', 'treemapRootToNode'];\n    var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);\n    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n    var viewRoot = seriesModel.getViewRoot();\n    var viewAbovePath = helper.getPathToRoot(viewRoot);\n\n    if (payloadType !== 'treemapMove') {\n      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n      var sort_1 = seriesOption.sort;\n\n      if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {\n        // Default to be desc order.\n        sort_1 = 'desc';\n      }\n\n      var options = {\n        squareRatio: seriesOption.squareRatio,\n        sort: sort_1,\n        leafDepth: seriesOption.leafDepth\n      }; // layout should be cleared because using updateView but not update.\n\n      viewRoot.hostTree.clearLayouts(); // TODO\n      // optimize: if out of view clip, do not layout.\n      // But take care that if do not render node out of view clip,\n      // how to calculate start po\n\n      var viewRootLayout_1 = {\n        x: 0,\n        y: 0,\n        width: rootSize[0],\n        height: rootSize[1],\n        area: rootSize[0] * rootSize[1]\n      };\n      viewRoot.setLayout(viewRootLayout_1);\n      squarify(viewRoot, options, false, 0); // Supplement layout.\n\n      viewRootLayout_1 = viewRoot.getLayout();\n      each(viewAbovePath, function (node, index) {\n        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n        node.setLayout(zrUtil.extend({\n          dataExtent: [childValue, childValue],\n          borderWidth: 0,\n          upperHeight: 0\n        }, viewRootLayout_1));\n      });\n    }\n\n    var treeRoot = seriesModel.getData().tree.root;\n    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n    seriesModel.setLayoutInfo(layoutInfo); // FIXME\n    // 现在没有clip功能，暂时取ec高宽。\n\n    prunning(treeRoot, // Transform to base element coordinate system.\n    new _BoundingRect.default(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n  }\n};\n/**\n * Layout treemap with squarify algorithm.\n * The original presentation of this algorithm\n * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\n * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.\n * The implementation of this algorithm was originally copied from \"d3.js\"\n * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>\n * with some modifications made for this program.\n * See the license statement at the head of this file.\n *\n * @protected\n * @param {module:echarts/data/Tree~TreeNode} node\n * @param {Object} options\n * @param {string} options.sort 'asc' or 'desc'\n * @param {number} options.squareRatio\n * @param {boolean} hideChildren\n * @param {number} depth\n */\n\nexports.default = _default;\n\nfunction squarify(node, options, hideChildren, depth) {\n  var width;\n  var height;\n\n  if (node.isRemoved()) {\n    return;\n  }\n\n  var thisLayout = node.getLayout();\n  width = thisLayout.width;\n  height = thisLayout.height; // Considering border and gap\n\n  var nodeModel = node.getModel();\n  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n  var upperLabelHeight = getUpperLabelHeight(nodeModel);\n  var upperHeight = Math.max(borderWidth, upperLabelHeight);\n  var layoutOffset = borderWidth - halfGapWidth;\n  var layoutOffsetUpper = upperHeight - halfGapWidth;\n  node.setLayout({\n    borderWidth: borderWidth,\n    upperHeight: upperHeight,\n    upperLabelHeight: upperLabelHeight\n  }, true);\n  width = mathMax(width - 2 * layoutOffset, 0);\n  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);\n  var totalArea = width * height;\n  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n\n  if (!viewChildren.length) {\n    return;\n  }\n\n  var rect = {\n    x: layoutOffset,\n    y: layoutOffsetUpper,\n    width: width,\n    height: height\n  };\n  var rowFixedLength = mathMin(width, height);\n  var best = Infinity; // the best row score so far\n\n  var row = [];\n  row.area = 0;\n\n  for (var i = 0, len = viewChildren.length; i < len;) {\n    var child = viewChildren[i];\n    row.push(child);\n    row.area += child.getLayout().area;\n    var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation\n\n    if (score <= best) {\n      i++;\n      best = score;\n    } // abort, and try a different orientation\n    else {\n      row.area -= row.pop().getLayout().area;\n      position(row, rowFixedLength, rect, halfGapWidth, false);\n      rowFixedLength = mathMin(rect.width, rect.height);\n      row.length = row.area = 0;\n      best = Infinity;\n    }\n  }\n\n  if (row.length) {\n    position(row, rowFixedLength, rect, halfGapWidth, true);\n  }\n\n  if (!hideChildren) {\n    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n\n    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n      hideChildren = true;\n    }\n  }\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    squarify(viewChildren[i], options, hideChildren, depth + 1);\n  }\n}\n/**\n * Set area to each child, and calculate data extent for visual coding.\n */\n\n\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n  var viewChildren = node.children || [];\n  var orderBy = options.sort;\n  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.\n\n  if (hideChildren && !overLeafDepth) {\n    return node.viewChildren = [];\n  } // Sort children, order by desc.\n\n\n  viewChildren = zrUtil.filter(viewChildren, function (child) {\n    return !child.isRemoved();\n  });\n  sort(viewChildren, orderBy);\n  var info = statistic(nodeModel, viewChildren, orderBy);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n\n  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  } // Set area to each child.\n\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.\n\n    viewChildren[i].setLayout({\n      area: area\n    });\n  }\n\n  if (overLeafDepth) {\n    viewChildren.length && node.setLayout({\n      isLeafRoot: true\n    }, true);\n    viewChildren.length = 0;\n  }\n\n  node.viewChildren = viewChildren;\n  node.setLayout({\n    dataExtent: info.dataExtent\n  }, true);\n  return viewChildren;\n}\n/**\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\n */\n\n\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n  // visibleMin is not supported yet when no option.sort.\n  if (!orderBy) {\n    return sum;\n  }\n\n  var visibleMin = nodeModel.get('visibleMin');\n  var len = orderedChildren.length;\n  var deletePoint = len; // Always travel from little value to big value.\n\n  for (var i = len - 1; i >= 0; i--) {\n    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n\n    if (value / sum * totalArea < visibleMin) {\n      deletePoint = i;\n      sum -= value;\n    }\n  }\n\n  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n  return sum;\n}\n/**\n * Sort\n */\n\n\nfunction sort(viewChildren, orderBy) {\n  if (orderBy) {\n    viewChildren.sort(function (a, b) {\n      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n    });\n  }\n\n  return viewChildren;\n}\n/**\n * Statistic\n */\n\n\nfunction statistic(nodeModel, children, orderBy) {\n  // Calculate sum.\n  var sum = 0;\n\n  for (var i = 0, len = children.length; i < len; i++) {\n    sum += children[i].getValue();\n  } // Statistic data extent for latter visual coding.\n  // Notice: data extent should be calculate based on raw children\n  // but not filtered view children, otherwise visual mapping will not\n  // be stable when zoom (where children is filtered by visibleMin).\n\n\n  var dimension = nodeModel.get('visualDimension');\n  var dataExtent; // The same as area dimension.\n\n  if (!children || !children.length) {\n    dataExtent = [NaN, NaN];\n  } else if (dimension === 'value' && orderBy) {\n    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n    orderBy === 'asc' && dataExtent.reverse();\n  } // Other dimension.\n  else {\n    dataExtent = [Infinity, -Infinity];\n    each(children, function (child) {\n      var value = child.getValue(dimension);\n      value < dataExtent[0] && (dataExtent[0] = value);\n      value > dataExtent[1] && (dataExtent[1] = value);\n    });\n  }\n\n  return {\n    sum: sum,\n    dataExtent: dataExtent\n  };\n}\n/**\n * Computes the score for the specified row,\n * as the worst aspect ratio.\n */\n\n\nfunction worst(row, rowFixedLength, ratio) {\n  var areaMax = 0;\n  var areaMin = Infinity;\n\n  for (var i = 0, area = void 0, len = row.length; i < len; i++) {\n    area = row[i].getLayout().area;\n\n    if (area) {\n      area < areaMin && (areaMin = area);\n      area > areaMax && (areaMax = area);\n    }\n  }\n\n  var squareArea = row.area * row.area;\n  var f = rowFixedLength * rowFixedLength * ratio;\n  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n}\n/**\n * Positions the specified row of nodes. Modifies `rect`.\n */\n\n\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n  // When rowFixedLength === rect.width,\n  // it is horizontal subdivision,\n  // rowFixedLength is the width of the subdivision,\n  // rowOtherLength is the height of the subdivision,\n  // and nodes will be positioned from left to right.\n  // wh[idx0WhenH] means: when horizontal,\n  //      wh[idx0WhenH] => wh[0] => 'width'.\n  //      xy[idx1WhenH] => xy[1] => 'y'.\n  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n  var idx1WhenH = 1 - idx0WhenH;\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  var last = rect[xy[idx0WhenH]];\n  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n\n  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n  }\n\n  for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n    var node = row[i];\n    var nodeLayout = {};\n    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.\n\n    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n    var modWH = i === rowLen - 1 || remain < step ? remain : step;\n    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);\n    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);\n    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);\n    last += modWH;\n    node.setLayout(nodeLayout, true);\n  }\n\n  rect[xy[idx1WhenH]] += rowOtherLength;\n  rect[wh[idx1WhenH]] -= rowOtherLength;\n} // Return [containerWidth, containerHeight] as default.\n\n\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n  // If targetInfo.node exists, we zoom to the node,\n  // so estimate whold width and heigth by target node.\n  var currNode = (targetInfo || {}).node;\n  var defaultSize = [containerWidth, containerHeight];\n\n  if (!currNode || currNode === viewRoot) {\n    return defaultSize;\n  }\n\n  var parent;\n  var viewArea = containerWidth * containerHeight;\n  var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n  while (parent = currNode.parentNode) {\n    // jshint ignore:line\n    var sum = 0;\n    var siblings = parent.children;\n\n    for (var i = 0, len = siblings.length; i < len; i++) {\n      sum += siblings[i].getValue();\n    }\n\n    var currNodeValue = currNode.getValue();\n\n    if (currNodeValue === 0) {\n      return defaultSize;\n    }\n\n    area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.\n\n    var parentModel = parent.getModel();\n    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));\n    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n    area > _number.MAX_SAFE_INTEGER && (area = _number.MAX_SAFE_INTEGER);\n    currNode = parent;\n  }\n\n  area < viewArea && (area = viewArea);\n  var scale = Math.pow(area / viewArea, 0.5);\n  return [containerWidth * scale, containerHeight * scale];\n} // Root postion base on coord of containerGroup\n\n\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n  if (rootRect) {\n    return {\n      x: rootRect.x,\n      y: rootRect.y\n    };\n  }\n\n  var defaultPosition = {\n    x: 0,\n    y: 0\n  };\n\n  if (!targetInfo) {\n    return defaultPosition;\n  } // If targetInfo is fetched by 'retrieveTargetInfo',\n  // old tree and new tree are the same tree,\n  // so the node still exists and we can visit it.\n\n\n  var targetNode = targetInfo.node;\n  var layout = targetNode.getLayout();\n\n  if (!layout) {\n    return defaultPosition;\n  } // Transform coord from local to container.\n\n\n  var targetCenter = [layout.width / 2, layout.height / 2];\n  var node = targetNode;\n\n  while (node) {\n    var nodeLayout = node.getLayout();\n    targetCenter[0] += nodeLayout.x;\n    targetCenter[1] += nodeLayout.y;\n    node = node.parentNode;\n  }\n\n  return {\n    x: layoutInfo.width / 2 - targetCenter[0],\n    y: layoutInfo.height / 2 - targetCenter[1]\n  };\n} // Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\n\n\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n  var nodeLayout = node.getLayout();\n  var nodeInViewAbovePath = viewAbovePath[depth];\n  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n    return;\n  }\n\n  node.setLayout({\n    // isInView means: viewRoot sub tree + viewAbovePath\n    isInView: true,\n    // invisible only means: outside view clip so that the node can not\n    // see but still layout for animation preparation but not render.\n    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n    isAboveViewRoot: isAboveViewRoot\n  }, true); // Transform to child coordinate.\n\n  var childClipRect = new _BoundingRect.default(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n  each(node.viewChildren || [], function (child) {\n    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n  });\n}\n\nfunction getUpperLabelHeight(model) {\n  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}","map":{"version":3,"names":["mathMax","Math","max","mathMin","min","retrieveValue","zrUtil","retrieve","each","PATH_BORDER_WIDTH","PATH_GAP_WIDTH","PATH_UPPER_LABEL_SHOW","PATH_UPPER_LABEL_HEIGHT","seriesType","reset","seriesModel","ecModel","api","payload","ecWidth","getWidth","ecHeight","getHeight","seriesOption","option","layoutInfo","layout","getLayoutRect","getBoxLayoutParams","width","height","size","containerWidth","parsePercent","containerHeight","payloadType","type","types","targetInfo","helper","retrieveTargetInfo","rootRect","viewRoot","getViewRoot","viewAbovePath","getPathToRoot","rootSize","estimateRootSize","sort_1","sort","options","squareRatio","leafDepth","hostTree","clearLayouts","viewRootLayout_1","x","y","area","setLayout","squarify","getLayout","node","index","childValue","getValue","extend","dataExtent","borderWidth","upperHeight","treeRoot","getData","tree","root","calculateRootPosition","setLayoutInfo","prunning","BoundingRect","hideChildren","depth","isRemoved","thisLayout","nodeModel","getModel","get","halfGapWidth","upperLabelHeight","getUpperLabelHeight","layoutOffset","layoutOffsetUpper","totalArea","viewChildren","initChildren","length","rect","rowFixedLength","best","Infinity","row","i","len","child","push","score","worst","pop","position","childrenVisibleMin","children","orderBy","overLeafDepth","filter","info","statistic","sum","filterByThreshold","isLeafRoot","orderedChildren","visibleMin","deletePoint","value","splice","a","b","diff","dataIndex","dimension","NaN","reverse","ratio","areaMax","areaMin","squareArea","f","flush","idx0WhenH","idx1WhenH","xy","wh","last","rowOtherLength","rowLen","nodeLayout","step","wh1","remain","modWH","wh0","currNode","defaultSize","parent","viewArea","zoomToNodeRatio","parentNode","siblings","currNodeValue","parentModel","pow","MAX_SAFE_INTEGER","scale","defaultPosition","targetNode","targetCenter","clipRect","nodeInViewAbovePath","isAboveViewRoot","isInView","invisible","intersect","childClipRect","model"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/chart/treemap/treemapLayout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/*\n* A third-party license is embeded for some of the code in this file:\n* The treemap layout implementation was originally copied from\n* \"d3.js\" with some modifications made for this project.\n* (See more details in the comment of the method \"squarify\" below.)\n* The use of the source code of this file is also subject to the terms\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\n* </licenses/LICENSE-d3>).\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parsePercent, MAX_SAFE_INTEGER } from '../../util/number.js';\nimport * as layout from '../../util/layout.js';\nimport * as helper from '../helper/treeHelper.js';\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar retrieveValue = zrUtil.retrieve;\nvar each = zrUtil.each;\nvar PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];\n;\n/**\n * @public\n */\n\nexport default {\n  seriesType: 'treemap',\n  reset: function (seriesModel, ecModel, api, payload) {\n    // Layout result in each node:\n    // {x, y, width, height, area, borderWidth}\n    var ecWidth = api.getWidth();\n    var ecHeight = api.getHeight();\n    var seriesOption = seriesModel.option;\n    var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    var size = seriesOption.size || []; // Compatible with ec2.\n\n    var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n    var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.\n\n    var payloadType = payload && payload.type;\n    var types = ['treemapZoomToNode', 'treemapRootToNode'];\n    var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);\n    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n    var viewRoot = seriesModel.getViewRoot();\n    var viewAbovePath = helper.getPathToRoot(viewRoot);\n\n    if (payloadType !== 'treemapMove') {\n      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n      var sort_1 = seriesOption.sort;\n\n      if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {\n        // Default to be desc order.\n        sort_1 = 'desc';\n      }\n\n      var options = {\n        squareRatio: seriesOption.squareRatio,\n        sort: sort_1,\n        leafDepth: seriesOption.leafDepth\n      }; // layout should be cleared because using updateView but not update.\n\n      viewRoot.hostTree.clearLayouts(); // TODO\n      // optimize: if out of view clip, do not layout.\n      // But take care that if do not render node out of view clip,\n      // how to calculate start po\n\n      var viewRootLayout_1 = {\n        x: 0,\n        y: 0,\n        width: rootSize[0],\n        height: rootSize[1],\n        area: rootSize[0] * rootSize[1]\n      };\n      viewRoot.setLayout(viewRootLayout_1);\n      squarify(viewRoot, options, false, 0); // Supplement layout.\n\n      viewRootLayout_1 = viewRoot.getLayout();\n      each(viewAbovePath, function (node, index) {\n        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n        node.setLayout(zrUtil.extend({\n          dataExtent: [childValue, childValue],\n          borderWidth: 0,\n          upperHeight: 0\n        }, viewRootLayout_1));\n      });\n    }\n\n    var treeRoot = seriesModel.getData().tree.root;\n    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n    seriesModel.setLayoutInfo(layoutInfo); // FIXME\n    // 现在没有clip功能，暂时取ec高宽。\n\n    prunning(treeRoot, // Transform to base element coordinate system.\n    new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n  }\n};\n/**\n * Layout treemap with squarify algorithm.\n * The original presentation of this algorithm\n * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\n * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.\n * The implementation of this algorithm was originally copied from \"d3.js\"\n * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>\n * with some modifications made for this program.\n * See the license statement at the head of this file.\n *\n * @protected\n * @param {module:echarts/data/Tree~TreeNode} node\n * @param {Object} options\n * @param {string} options.sort 'asc' or 'desc'\n * @param {number} options.squareRatio\n * @param {boolean} hideChildren\n * @param {number} depth\n */\n\nfunction squarify(node, options, hideChildren, depth) {\n  var width;\n  var height;\n\n  if (node.isRemoved()) {\n    return;\n  }\n\n  var thisLayout = node.getLayout();\n  width = thisLayout.width;\n  height = thisLayout.height; // Considering border and gap\n\n  var nodeModel = node.getModel();\n  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n  var upperLabelHeight = getUpperLabelHeight(nodeModel);\n  var upperHeight = Math.max(borderWidth, upperLabelHeight);\n  var layoutOffset = borderWidth - halfGapWidth;\n  var layoutOffsetUpper = upperHeight - halfGapWidth;\n  node.setLayout({\n    borderWidth: borderWidth,\n    upperHeight: upperHeight,\n    upperLabelHeight: upperLabelHeight\n  }, true);\n  width = mathMax(width - 2 * layoutOffset, 0);\n  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);\n  var totalArea = width * height;\n  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n\n  if (!viewChildren.length) {\n    return;\n  }\n\n  var rect = {\n    x: layoutOffset,\n    y: layoutOffsetUpper,\n    width: width,\n    height: height\n  };\n  var rowFixedLength = mathMin(width, height);\n  var best = Infinity; // the best row score so far\n\n  var row = [];\n  row.area = 0;\n\n  for (var i = 0, len = viewChildren.length; i < len;) {\n    var child = viewChildren[i];\n    row.push(child);\n    row.area += child.getLayout().area;\n    var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation\n\n    if (score <= best) {\n      i++;\n      best = score;\n    } // abort, and try a different orientation\n    else {\n        row.area -= row.pop().getLayout().area;\n        position(row, rowFixedLength, rect, halfGapWidth, false);\n        rowFixedLength = mathMin(rect.width, rect.height);\n        row.length = row.area = 0;\n        best = Infinity;\n      }\n  }\n\n  if (row.length) {\n    position(row, rowFixedLength, rect, halfGapWidth, true);\n  }\n\n  if (!hideChildren) {\n    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n\n    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n      hideChildren = true;\n    }\n  }\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    squarify(viewChildren[i], options, hideChildren, depth + 1);\n  }\n}\n/**\n * Set area to each child, and calculate data extent for visual coding.\n */\n\n\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n  var viewChildren = node.children || [];\n  var orderBy = options.sort;\n  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.\n\n  if (hideChildren && !overLeafDepth) {\n    return node.viewChildren = [];\n  } // Sort children, order by desc.\n\n\n  viewChildren = zrUtil.filter(viewChildren, function (child) {\n    return !child.isRemoved();\n  });\n  sort(viewChildren, orderBy);\n  var info = statistic(nodeModel, viewChildren, orderBy);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n\n  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  } // Set area to each child.\n\n\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.\n\n    viewChildren[i].setLayout({\n      area: area\n    });\n  }\n\n  if (overLeafDepth) {\n    viewChildren.length && node.setLayout({\n      isLeafRoot: true\n    }, true);\n    viewChildren.length = 0;\n  }\n\n  node.viewChildren = viewChildren;\n  node.setLayout({\n    dataExtent: info.dataExtent\n  }, true);\n  return viewChildren;\n}\n/**\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\n */\n\n\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n  // visibleMin is not supported yet when no option.sort.\n  if (!orderBy) {\n    return sum;\n  }\n\n  var visibleMin = nodeModel.get('visibleMin');\n  var len = orderedChildren.length;\n  var deletePoint = len; // Always travel from little value to big value.\n\n  for (var i = len - 1; i >= 0; i--) {\n    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n\n    if (value / sum * totalArea < visibleMin) {\n      deletePoint = i;\n      sum -= value;\n    }\n  }\n\n  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n  return sum;\n}\n/**\n * Sort\n */\n\n\nfunction sort(viewChildren, orderBy) {\n  if (orderBy) {\n    viewChildren.sort(function (a, b) {\n      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n    });\n  }\n\n  return viewChildren;\n}\n/**\n * Statistic\n */\n\n\nfunction statistic(nodeModel, children, orderBy) {\n  // Calculate sum.\n  var sum = 0;\n\n  for (var i = 0, len = children.length; i < len; i++) {\n    sum += children[i].getValue();\n  } // Statistic data extent for latter visual coding.\n  // Notice: data extent should be calculate based on raw children\n  // but not filtered view children, otherwise visual mapping will not\n  // be stable when zoom (where children is filtered by visibleMin).\n\n\n  var dimension = nodeModel.get('visualDimension');\n  var dataExtent; // The same as area dimension.\n\n  if (!children || !children.length) {\n    dataExtent = [NaN, NaN];\n  } else if (dimension === 'value' && orderBy) {\n    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n    orderBy === 'asc' && dataExtent.reverse();\n  } // Other dimension.\n  else {\n      dataExtent = [Infinity, -Infinity];\n      each(children, function (child) {\n        var value = child.getValue(dimension);\n        value < dataExtent[0] && (dataExtent[0] = value);\n        value > dataExtent[1] && (dataExtent[1] = value);\n      });\n    }\n\n  return {\n    sum: sum,\n    dataExtent: dataExtent\n  };\n}\n/**\n * Computes the score for the specified row,\n * as the worst aspect ratio.\n */\n\n\nfunction worst(row, rowFixedLength, ratio) {\n  var areaMax = 0;\n  var areaMin = Infinity;\n\n  for (var i = 0, area = void 0, len = row.length; i < len; i++) {\n    area = row[i].getLayout().area;\n\n    if (area) {\n      area < areaMin && (areaMin = area);\n      area > areaMax && (areaMax = area);\n    }\n  }\n\n  var squareArea = row.area * row.area;\n  var f = rowFixedLength * rowFixedLength * ratio;\n  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n}\n/**\n * Positions the specified row of nodes. Modifies `rect`.\n */\n\n\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n  // When rowFixedLength === rect.width,\n  // it is horizontal subdivision,\n  // rowFixedLength is the width of the subdivision,\n  // rowOtherLength is the height of the subdivision,\n  // and nodes will be positioned from left to right.\n  // wh[idx0WhenH] means: when horizontal,\n  //      wh[idx0WhenH] => wh[0] => 'width'.\n  //      xy[idx1WhenH] => xy[1] => 'y'.\n  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n  var idx1WhenH = 1 - idx0WhenH;\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  var last = rect[xy[idx0WhenH]];\n  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n\n  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n  }\n\n  for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n    var node = row[i];\n    var nodeLayout = {};\n    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.\n\n    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n    var modWH = i === rowLen - 1 || remain < step ? remain : step;\n    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);\n    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);\n    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);\n    last += modWH;\n    node.setLayout(nodeLayout, true);\n  }\n\n  rect[xy[idx1WhenH]] += rowOtherLength;\n  rect[wh[idx1WhenH]] -= rowOtherLength;\n} // Return [containerWidth, containerHeight] as default.\n\n\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n  // If targetInfo.node exists, we zoom to the node,\n  // so estimate whold width and heigth by target node.\n  var currNode = (targetInfo || {}).node;\n  var defaultSize = [containerWidth, containerHeight];\n\n  if (!currNode || currNode === viewRoot) {\n    return defaultSize;\n  }\n\n  var parent;\n  var viewArea = containerWidth * containerHeight;\n  var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n  while (parent = currNode.parentNode) {\n    // jshint ignore:line\n    var sum = 0;\n    var siblings = parent.children;\n\n    for (var i = 0, len = siblings.length; i < len; i++) {\n      sum += siblings[i].getValue();\n    }\n\n    var currNodeValue = currNode.getValue();\n\n    if (currNodeValue === 0) {\n      return defaultSize;\n    }\n\n    area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.\n\n    var parentModel = parent.getModel();\n    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));\n    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n    area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);\n    currNode = parent;\n  }\n\n  area < viewArea && (area = viewArea);\n  var scale = Math.pow(area / viewArea, 0.5);\n  return [containerWidth * scale, containerHeight * scale];\n} // Root postion base on coord of containerGroup\n\n\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n  if (rootRect) {\n    return {\n      x: rootRect.x,\n      y: rootRect.y\n    };\n  }\n\n  var defaultPosition = {\n    x: 0,\n    y: 0\n  };\n\n  if (!targetInfo) {\n    return defaultPosition;\n  } // If targetInfo is fetched by 'retrieveTargetInfo',\n  // old tree and new tree are the same tree,\n  // so the node still exists and we can visit it.\n\n\n  var targetNode = targetInfo.node;\n  var layout = targetNode.getLayout();\n\n  if (!layout) {\n    return defaultPosition;\n  } // Transform coord from local to container.\n\n\n  var targetCenter = [layout.width / 2, layout.height / 2];\n  var node = targetNode;\n\n  while (node) {\n    var nodeLayout = node.getLayout();\n    targetCenter[0] += nodeLayout.x;\n    targetCenter[1] += nodeLayout.y;\n    node = node.parentNode;\n  }\n\n  return {\n    x: layoutInfo.width / 2 - targetCenter[0],\n    y: layoutInfo.height / 2 - targetCenter[1]\n  };\n} // Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\n\n\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n  var nodeLayout = node.getLayout();\n  var nodeInViewAbovePath = viewAbovePath[depth];\n  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n    return;\n  }\n\n  node.setLayout({\n    // isInView means: viewRoot sub tree + viewAbovePath\n    isInView: true,\n    // invisible only means: outside view clip so that the node can not\n    // see but still layout for animation preparation but not render.\n    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n    isAboveViewRoot: isAboveViewRoot\n  }, true); // Transform to child coordinate.\n\n  var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n  each(node.viewChildren || [], function (child) {\n    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n  });\n}\n\nfunction getUpperLabelHeight(model) {\n  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}