{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableDataStack = enableDataStack;\nexports.getStackedDimension = getStackedDimension;\nexports.isDimensionStacked = isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _SeriesDataSchema = require(\"./SeriesDataSchema.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param seriesModel\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\n *        The input will be modified.\n * @param opt\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\n * @param opt.byIndex=false\n * @return calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\nfunction enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  } // Compatibal: when `stack` is set as '', do not stack.\n\n\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  (0, _util.each)(dimensionDefineList, function (dimensionInfo, index) {\n    if ((0, _util.isString)(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      } // Find the first stackable dimension as the stackedDimInfo.\n\n\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n\n\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id; // Create inverted index to fast query index by value.\n\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    (0, _util.each)(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\n\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !(0, _SeriesDataSchema.isSeriesDataSchema)(dimensionsInput.schema);\n}\n\nfunction isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\n\nfunction getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}","map":{"version":3,"names":["enableDataStack","seriesModel","dimensionsInput","opt","byIndex","stackedCoordDimension","dimensionDefineList","schema","store","isLegacyDimensionsInput","dimensions","mayStack","get","stackedByDimInfo","stackedDimInfo","stackResultDimension","stackedOverDimension","each","dimensionInfo","index","isString","name","isExtraCoord","ordinalMeta","type","coordDim","id","createInvertedIndices","stackedDimCoordDim_1","stackedDimType","stackedDimCoordIndex_1","stackedOverDimensionDefine","coordDimIndex","isCalculationCoord","storeDimIndex","length","stackResultDimensionDefine","ensureCalculationDimension","appendCalculationDimension","push","stackedDimension","stackedByDimension","isStackedByIndex","isSeriesDataSchema","isDimensionStacked","data","stackedDim","getCalculationInfo","getStackedDimension","targetDim"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/helper/dataStackHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isString } from 'zrender/lib/core/util.js';\nimport { isSeriesDataSchema } from './SeriesDataSchema.js';\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param seriesModel\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\n *        The input will be modified.\n * @param opt\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\n * @param opt.byIndex=false\n * @return calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\n\nexport function enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  } // Compatibal: when `stack` is set as '', do not stack.\n\n\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionDefineList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      } // Find the first stackable dimension as the stackedDimInfo.\n\n\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n\n\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id; // Create inverted index to fast query index by value.\n\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    each(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\n\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !isSeriesDataSchema(dimensionsInput.schema);\n}\n\nexport function isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\nexport function getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}