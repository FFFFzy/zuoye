{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createScaleByModel = createScaleByModel;\nexports.estimateLabelUnionRect = estimateLabelUnionRect;\nexports.getAxisRawValue = getAxisRawValue;\nexports.getDataDimensionsOnAxis = getDataDimensionsOnAxis;\nexports.getOptionCategoryInterval = getOptionCategoryInterval;\nexports.getScaleExtent = getScaleExtent;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.makeLabelFormatter = makeLabelFormatter;\nexports.niceScaleExtent = niceScaleExtent;\nexports.shouldShowAllLabels = shouldShowAllLabels;\nexports.unionAxisExtentFromData = unionAxisExtentFromData;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar _Ordinal = _interopRequireDefault(require(\"../scale/Ordinal.js\"));\n\nvar _Interval = _interopRequireDefault(require(\"../scale/Interval.js\"));\n\nvar _Scale = _interopRequireDefault(require(\"../scale/Scale.js\"));\n\nvar _barGrid = require(\"../layout/barGrid.js\");\n\nvar _BoundingRect = _interopRequireDefault(require(\"zrender/lib/core/BoundingRect.js\"));\n\nvar _Time = _interopRequireDefault(require(\"../scale/Time.js\"));\n\nvar _Log = _interopRequireDefault(require(\"../scale/Log.js\"));\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper.js\");\n\nvar _scaleRawExtentInfo = require(\"./scaleRawExtentInfo.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n *\n * Caution:\n * Precondition of calling this method:\n * The scale extent has been initialized using series data extent via\n * `scale.setExtent` or `scale.unionExtentFromData`;\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var rawExtentResult = (0, _scaleRawExtentInfo.ensureScaleRawExtentInfo)(scale, model, scale.getExtent()).calculate();\n  scale.setBlank(rawExtentResult.isBlank);\n  var min = rawExtentResult.min;\n  var max = rawExtentResult.max; // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time'\n  /*|| scaleType === 'interval' */\n  ) {\n    var barSeriesModels = (0, _barGrid.prepareLayoutBarSeries)('bar', ecModel);\n    var isBaseAxisAndHasBarSeries_1 = false;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries_1) {\n      // Calculate placement of bars on axis. TODO should be decoupled\n      // with barLayout\n      var barWidthAndOffset = (0, _barGrid.makeColumnLayout)(barSeriesModels); // Adjust axis min and max to account for overflow\n\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return {\n    extent: [min, max],\n    // \"fix\" means \"fixed\", the value should not be\n    // changed in the subsequent steps.\n    fixMin: rawExtentResult.minFixed,\n    fixMax: rawExtentResult.maxFixed\n  };\n}\n\nfunction adjustScaleForOverflow(min, max, model, // Only support cartesian coord yet.\nbarWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow\n\n  var barsOnCurrentAxis = (0, _barGrid.retrieveColumnLayout)(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow; // Calculate required buffer based on old range and overflow\n\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n} // Precondition of calling this method:\n// The scale extent has been initailized using series data extent via\n// `scale.setExtent` or `scale.unionExtentFromData`;\n\n\nfunction niceScaleExtent(scale, inModel) {\n  var model = inModel;\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale instanceof _Log.default) {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  var interval = model.get('interval');\n  var isIntervalOrTime = scaleType === 'interval' || scaleType === 'time';\n  scale.setExtent(extent[0], extent[1]);\n  scale.calcNiceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: isIntervalOrTime ? model.get('minInterval') : null,\n    maxInterval: isIntervalOrTime ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param axisType Default retrieve from model.type\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new _Ordinal.default({\n          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new _Time.default({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // case 'value'/'interval', 'log', or others.\n        return new (_Scale.default.getClass(axisType) || _Interval.default)();\n    }\n  }\n}\n/**\n * Check if the axis cross 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param axis\n * @return Label formatter function.\n *         param: {number} tickValue,\n *         param: {number} idx, the index in all ticks.\n *                         If category axis, this param is not required.\n *         return: {string} label string.\n */\n\n\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (axis.scale.type === 'time') {\n    return function (tpl) {\n      return function (tick, idx) {\n        return axis.scale.getFormattedLabel(tick, idx, tpl);\n      };\n    }(labelFormatter);\n  } else if (zrUtil.isString(labelFormatter)) {\n    return function (tpl) {\n      return function (tick) {\n        // For category axis, get raw value; for numeric axis,\n        // get formatted label like '1,333,444'.\n        var label = axis.scale.getLabel(tick);\n        var text = tpl.replace('{value}', label != null ? label : '');\n        return text;\n      };\n    }(labelFormatter);\n  } else if (zrUtil.isFunction(labelFormatter)) {\n    return function (cb) {\n      return function (tick, idx) {\n        // The original intention of `idx` is \"the index of the tick in all ticks\".\n        // But the previous implementation of category axis do not consider the\n        // `axisLabel.interval`, which cause that, for example, the `interval` is\n        // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n        // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n        // the definition here for back compatibility.\n        if (categoryTickStart != null) {\n          idx = tick.value - categoryTickStart;\n        }\n\n        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n          level: tick.level\n        } : null);\n      };\n    }(labelFormatter);\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\n\nfunction getAxisRawValue(axis, tick) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n}\n/**\n * @param axis\n * @return Be null/undefined if no labels.\n */\n\n\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.\n\n  if (scale instanceof _Ordinal.default) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1; // Simple optimization for large amount of labels\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var beforeWidth = textRect.width;\n  var beforeHeight = textRect.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new _BoundingRect.default(textRect.x, textRect.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\n * @param model axisLabelModel or axisTickModel\n * @return {number|String} Can be null|'auto'|number|function\n */\n\n\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\n * Set `categoryInterval` as 0 implicitly indicates that\n * show all labels reguardless of overlap.\n * @param {Object} axis axisModel.axis\n */\n\n\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\n\nfunction getDataDimensionsOnAxis(data, axisDim) {\n  // Remove duplicated dat dimensions caused by `getStackedDimension`.\n  var dataDimMap = {}; // Currently `mapDimensionsAll` will contain stack result dimension ('__\\0ecstackresult').\n  // PENDING: is it reasonable? Do we need to remove the original dim from \"coord dim\" since\n  // there has been stacked result dim?\n\n  zrUtil.each(data.mapDimensionsAll(axisDim), function (dataDim) {\n    // For example, the extent of the original dimension\n    // is [0.1, 0.5], the extent of the `stackResultDimension`\n    // is [7, 9], the final extent should NOT include [0.1, 0.5],\n    // because there is no graphic corresponding to [0.1, 0.5].\n    // See the case in `test/area-stack.html` `main1`, where area line\n    // stack needs `yAxis` not start from 0.\n    dataDimMap[(0, _dataStackHelper.getStackedDimension)(data, dataDim)] = true;\n  });\n  return zrUtil.keys(dataDimMap);\n}\n\nfunction unionAxisExtentFromData(dataExtent, data, axisDim) {\n  if (data) {\n    zrUtil.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n      var seriesExtent = data.getApproximateExtent(dim);\n      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n    });\n  }\n}","map":{"version":3,"names":["getScaleExtent","scale","model","scaleType","type","rawExtentResult","ensureScaleRawExtentInfo","getExtent","calculate","setBlank","isBlank","min","max","ecModel","barSeriesModels","prepareLayoutBarSeries","isBaseAxisAndHasBarSeries_1","zrUtil","each","seriesModel","getBaseAxis","axis","barWidthAndOffset","makeColumnLayout","adjustedScale","adjustScaleForOverflow","extent","fixMin","minFixed","fixMax","maxFixed","axisExtent","axisLength","barsOnCurrentAxis","retrieveColumnLayout","undefined","minOverflow","Infinity","item","Math","offset","maxOverflow","width","abs","totalOverFlow","oldRange","oldRangePercentOfNew","overflowBuffer","niceScaleExtent","inModel","extentInfo","splitNumber","get","LogScale","base","interval","isIntervalOrTime","setExtent","calcNiceExtent","minInterval","maxInterval","setInterval","createScaleByModel","axisType","OrdinalScale","ordinalMeta","getOrdinalMeta","getCategories","TimeScale","locale","getLocaleModel","useUTC","Scale","getClass","IntervalScale","ifAxisCrossZero","dataExtent","makeLabelFormatter","labelFormatter","getLabelModel","categoryTickStart","tpl","tick","idx","getFormattedLabel","isString","label","getLabel","text","replace","isFunction","cb","value","getAxisRawValue","level","estimateLabelUnionRect","axisModel","realNumberScaleTicks","tickCount","categoryScaleExtent","count","getTicks","length","axisLabelModel","rect","step","ceil","i","unrotatedSingleRect","getTextRect","singleRect","rotateTextRect","union","textRect","rotate","rotateRadians","PI","beforeWidth","beforeHeight","height","afterWidth","cos","sin","afterHeight","rotatedRect","BoundingRect","x","y","getOptionCategoryInterval","shouldShowAllLabels","getDataDimensionsOnAxis","data","axisDim","dataDimMap","mapDimensionsAll","dataDim","getStackedDimension","keys","unionAxisExtentFromData","dim","seriesExtent","getApproximateExtent"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/coord/axisHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport OrdinalScale from '../scale/Ordinal.js';\nimport IntervalScale from '../scale/Interval.js';\nimport Scale from '../scale/Scale.js';\nimport { prepareLayoutBarSeries, makeColumnLayout, retrieveColumnLayout } from '../layout/barGrid.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport TimeScale from '../scale/Time.js';\nimport LogScale from '../scale/Log.js';\nimport { getStackedDimension } from '../data/helper/dataStackHelper.js';\nimport { ensureScaleRawExtentInfo } from './scaleRawExtentInfo.js';\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n *\n * Caution:\n * Precondition of calling this method:\n * The scale extent has been initialized using series data extent via\n * `scale.setExtent` or `scale.unionExtentFromData`;\n */\n\nexport function getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var rawExtentResult = ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();\n  scale.setBlank(rawExtentResult.isBlank);\n  var min = rawExtentResult.min;\n  var max = rawExtentResult.max; // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time'\n  /*|| scaleType === 'interval' */\n  ) {\n    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries_1 = false;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries_1) {\n      // Calculate placement of bars on axis. TODO should be decoupled\n      // with barLayout\n      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow\n\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return {\n    extent: [min, max],\n    // \"fix\" means \"fixed\", the value should not be\n    // changed in the subsequent steps.\n    fixMin: rawExtentResult.minFixed,\n    fixMax: rawExtentResult.maxFixed\n  };\n}\n\nfunction adjustScaleForOverflow(min, max, model, // Only support cartesian coord yet.\nbarWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow\n\n  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow; // Calculate required buffer based on old range and overflow\n\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n} // Precondition of calling this method:\n// The scale extent has been initailized using series data extent via\n// `scale.setExtent` or `scale.unionExtentFromData`;\n\n\nexport function niceScaleExtent(scale, inModel) {\n  var model = inModel;\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale instanceof LogScale) {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  var interval = model.get('interval');\n  var isIntervalOrTime = scaleType === 'interval' || scaleType === 'time';\n  scale.setExtent(extent[0], extent[1]);\n  scale.calcNiceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: isIntervalOrTime ? model.get('minInterval') : null,\n    maxInterval: isIntervalOrTime ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param axisType Default retrieve from model.type\n */\n\nexport function createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale({\n          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new TimeScale({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // case 'value'/'interval', 'log', or others.\n        return new (Scale.getClass(axisType) || IntervalScale)();\n    }\n  }\n}\n/**\n * Check if the axis cross 0\n */\n\nexport function ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param axis\n * @return Label formatter function.\n *         param: {number} tickValue,\n *         param: {number} idx, the index in all ticks.\n *                         If category axis, this param is not required.\n *         return: {string} label string.\n */\n\nexport function makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (axis.scale.type === 'time') {\n    return function (tpl) {\n      return function (tick, idx) {\n        return axis.scale.getFormattedLabel(tick, idx, tpl);\n      };\n    }(labelFormatter);\n  } else if (zrUtil.isString(labelFormatter)) {\n    return function (tpl) {\n      return function (tick) {\n        // For category axis, get raw value; for numeric axis,\n        // get formatted label like '1,333,444'.\n        var label = axis.scale.getLabel(tick);\n        var text = tpl.replace('{value}', label != null ? label : '');\n        return text;\n      };\n    }(labelFormatter);\n  } else if (zrUtil.isFunction(labelFormatter)) {\n    return function (cb) {\n      return function (tick, idx) {\n        // The original intention of `idx` is \"the index of the tick in all ticks\".\n        // But the previous implementation of category axis do not consider the\n        // `axisLabel.interval`, which cause that, for example, the `interval` is\n        // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n        // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n        // the definition here for back compatibility.\n        if (categoryTickStart != null) {\n          idx = tick.value - categoryTickStart;\n        }\n\n        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n          level: tick.level\n        } : null);\n      };\n    }(labelFormatter);\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\nexport function getAxisRawValue(axis, tick) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n}\n/**\n * @param axis\n * @return Be null/undefined if no labels.\n */\n\nexport function estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.\n\n  if (scale instanceof OrdinalScale) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1; // Simple optimization for large amount of labels\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var beforeWidth = textRect.width;\n  var beforeHeight = textRect.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new BoundingRect(textRect.x, textRect.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\n * @param model axisLabelModel or axisTickModel\n * @return {number|String} Can be null|'auto'|number|function\n */\n\n\nexport function getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\n * Set `categoryInterval` as 0 implicitly indicates that\n * show all labels reguardless of overlap.\n * @param {Object} axis axisModel.axis\n */\n\nexport function shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\nexport function getDataDimensionsOnAxis(data, axisDim) {\n  // Remove duplicated dat dimensions caused by `getStackedDimension`.\n  var dataDimMap = {}; // Currently `mapDimensionsAll` will contain stack result dimension ('__\\0ecstackresult').\n  // PENDING: is it reasonable? Do we need to remove the original dim from \"coord dim\" since\n  // there has been stacked result dim?\n\n  zrUtil.each(data.mapDimensionsAll(axisDim), function (dataDim) {\n    // For example, the extent of the original dimension\n    // is [0.1, 0.5], the extent of the `stackResultDimension`\n    // is [7, 9], the final extent should NOT include [0.1, 0.5],\n    // because there is no graphic corresponding to [0.1, 0.5].\n    // See the case in `test/area-stack.html` `main1`, where area line\n    // stack needs `yAxis` not start from 0.\n    dataDimMap[getStackedDimension(data, dataDim)] = true;\n  });\n  return zrUtil.keys(dataDimMap);\n}\nexport function unionAxisExtentFromData(dataExtent, data, axisDim) {\n  if (data) {\n    zrUtil.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n      var seriesExtent = data.getApproximateExtent(dim);\n      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n    });\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}