{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ECPolyline = exports.ECPolygon = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _Path = _interopRequireDefault(require(\"zrender/lib/graphic/Path.js\"));\n\nvar _PathProxy = _interopRequireDefault(require(\"zrender/lib/core/PathProxy.js\"));\n\nvar _curve = require(\"zrender/lib/core/curve.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = _PathProxy.default.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? (0, _curve.cubicRootAt)(x0, x, x2, x3, xOrY, roots) : (0, _curve.cubicRootAt)(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? (0, _curve.cubicAt)(y0, y, y2, y3, t_1) : (0, _curve.cubicAt)(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(_Path.default);\n\nexports.ECPolyline = ECPolyline;\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(_Path.default);\n\nexports.ECPolygon = ECPolygon;","map":{"version":3,"names":["mathMin","Math","min","mathMax","max","isPointNull","x","y","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smooth","smoothMonotone","connectNulls","prevX","prevY","cpx0","cpy0","cpx1","cpy1","idx","k","dx","dy","nextIdx","nextX","nextY","tmpK","ratioNextSeg","vx","vy","nextCpx0","nextCpy0","dx0","dx1","dy0","dy1","lenPrevSeg","lenNextSeg","abs","dir_1","dir_2","sqrt","bezierCurveTo","lineTo","ECPolylineShape","smoothConstraint","ECPolyline","_super","__extends","opts","_this","call","type","prototype","getDefaultStyle","stroke","fill","getDefaultShape","buildPath","shape","i","len","length","getPointOn","xOrY","dim","path","createPathProxy","data","CMD","PathProxy","x0","y0","isDimX","roots","cmd","x2","y2","x3","y3","t","M","L","val","C","nRoot","cubicRootAt","i_1","t_1","cubicAt","Path","ECPolygonShape","apply","arguments","ECPolygon","stackedOnPoints","stackedOnSmooth","closePath"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/chart/line/poly.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // Poly path support NaN point\n\nimport Path from 'zrender/lib/graphic/Path.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { cubicRootAt, cubicAt } from 'zrender/lib/core/curve.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  __extends(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path);\n\nexport { ECPolyline };\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path);\n\nexport { ECPolygon };"],"mappings":"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"},"metadata":{},"sourceType":"script"}