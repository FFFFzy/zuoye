{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExternalSource = void 0;\nexports.applyDataTransform = applyDataTransform;\nexports.registerExternalTransform = registerExternalTransform;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _types = require(\"../../util/types.js\");\n\nvar _model = require(\"../../util/model.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _dataProvider = require(\"./dataProvider.js\");\n\nvar _dataValueHelper = require(\"./dataValueHelper.js\");\n\nvar _log = require(\"../../util/log.js\");\n\nvar _Source = require(\"../Source.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\nvar ExternalSource =\n/** @class */\nfunction () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * becuase transform function is not case-specific, no need to use name literally.\n   */\n\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return (0, _dataValueHelper.parseDataValue)(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexports.ExternalSource = ExternalSource;\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n\n  if (internalSource.seriesLayoutBy !== _types.SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n\n    (0, _log.throwError)(errMsg);\n  } // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Becuase the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is relialbe and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n\n\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    (0, _util.each)(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform\n      // do not generate dimension name.\n\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbid name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n\n        if ((0, _util.hasOwn)(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          (0, _log.throwError)(errMsg_1);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      // Do not generete name or anything others. The consequence process in\n      // `transform` or `series` probably have there own name generation strategry.\n      dimensions.push({\n        index: i\n      });\n    }\n  } // Implement public methods:\n\n\n  var rawItemGetter = (0, _dataProvider.getRawSourceItemGetter)(sourceFormat, _types.SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = (0, _util.bind)(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = (0, _util.bind)(cloneRawData, null, internalSource);\n  var rawCounter = (0, _dataProvider.getRawSourceDataCounter)(sourceFormat, _types.SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = (0, _util.bind)(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = (0, _dataProvider.getRawSourceValueGetter)(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = (0, _util.bind)(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = (0, _util.bind)(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  return upstream.data;\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  if (sourceFormat === _types.SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === _types.SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push((0, _util.extend)({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  } // Keep the same logic as `List::getDimension` did.\n\n\n  if ((0, _util.isNumber)(dim) // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !(0, _util.hasOwn)(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if ((0, _util.hasOwn)(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return (0, _util.clone)(dimensions);\n}\n\nvar externalTransformMap = (0, _util.createHashMap)();\n\nfunction registerExternalTransform(externalTransform) {\n  externalTransform = (0, _util.clone)(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    (0, _log.throwError)(errMsg);\n  } // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\n\nfunction applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = (0, _model.normalizeToArray)(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  if (!(0, _util.isObject)(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    (0, _log.throwError)(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    (0, _log.throwError)(errMsg);\n  } // Prepare source\n\n\n  var extUpSourceList = (0, _util.map)(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = (0, _model.normalizeToArray)(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: (0, _util.clone)(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = (0, _util.map)(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', (0, _log.makePrintable)(extSource.data), '- transform result dimensions:', (0, _log.makePrintable)(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      (0, _log.log)(printStrArr);\n    }\n  }\n\n  return (0, _util.map)(resultList, function (result, resultIndex) {\n    var errMsg = '';\n\n    if (!(0, _util.isObject)(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      (0, _log.throwError)(errMsg);\n    }\n\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n\n      (0, _log.throwError)(errMsg);\n    }\n\n    var sourceFormat = (0, _Source.detectSourceFormat)(result.data);\n\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n\n      (0, _log.throwError)(errMsg);\n    }\n\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n\n    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n\n      resultMetaRawOption = {\n        seriesLayoutBy: _types.SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: _types.SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n\n    return (0, _Source.createSource)(result.data, resultMetaRawOption, null);\n  });\n}\n\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === _types.SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === _types.SOURCE_FORMAT_OBJECT_ROWS;\n}","map":{"version":3,"names":["ExternalSource","prototype","getRawData","Error","getRawDataItem","dataIndex","cloneRawData","getDimensionInfo","dim","cloneAllDimensionInfo","count","retrieveValue","dimIndex","retrieveValueFromItem","dataItem","convertValue","rawVal","dimInfo","parseDataValue","createExternalSource","internalSource","externalTransform","extSource","data","sourceFormat","sourceHeaderCount","startIndex","errMsg","seriesLayoutBy","SERIES_LAYOUT_BY_COLUMN","process","env","NODE_ENV","throwError","dimensions","dimsByName","dimsDef","dimensionsDefine","each","dimDef","idx","name","dimDefExt","index","displayName","push","errMsg_1","hasOwn","i","dimensionsDetectedCount","rawItemGetter","getRawSourceItemGetter","__isBuiltIn","bind","rawCounter","getRawSourceDataCounter","rawValueGetter","getRawSourceValueGetter","rawItem","upstream","isSupportedSourceFormat","SOURCE_FORMAT_ARRAY_ROWS","result","len","length","slice","SOURCE_FORMAT_OBJECT_ROWS","extend","isNumber","isNaN","clone","externalTransformMap","createHashMap","registerExternalTransform","type","typeParsed","split","isBuiltIn","set","applyDataTransform","rawTransOption","sourceList","infoForPrint","pipedTransOption","normalizeToArray","pipeLen","transOption","applySingleDataTransform","Math","max","upSourceList","pipeIndex","isObject","transType","get","extUpSourceList","map","upSource","resultList","transform","upstreamList","config","print","printStrArr","pipeIndexStr","datasetIndex","makePrintable","join","log","resultIndex","detectSourceFormat","resultMetaRawOption","firstUpSource","concat","sourceHeader","metaRawOption","createSource"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/helper/transform.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, extend, isNumber } from 'zrender/lib/core/util.js';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider.js';\nimport { parseDataValue } from './dataValueHelper.js';\nimport { log, makePrintable, throwError } from '../../util/log.js';\nimport { createSource, detectSourceFormat } from '../Source.js';\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\n\nvar ExternalSource =\n/** @class */\nfunction () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * becuase transform function is not case-specific, no need to use name literally.\n   */\n\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n\n  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n\n    throwError(errMsg);\n  } // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Becuase the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is relialbe and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n\n\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform\n      // do not generate dimension name.\n\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbid name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg_1);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n      for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n        // Do not generete name or anything others. The consequence process in\n        // `transform` or `series` probably have there own name generation strategry.\n        dimensions.push({\n          index: i\n        });\n      }\n    } // Implement public methods:\n\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  return upstream.data;\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  } // Keep the same logic as `List::getDimension` did.\n\n\n  if (isNumber(dim) // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  } // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  } // Prepare source\n\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result, resultIndex) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n\n      throwError(errMsg);\n    }\n\n    var sourceFormat = detectSourceFormat(result.data);\n\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n\n    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n\n    return createSource(result.data, resultMetaRawOption, null);\n  });\n}\n\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}