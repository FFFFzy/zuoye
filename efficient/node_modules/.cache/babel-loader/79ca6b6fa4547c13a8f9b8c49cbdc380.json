{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar graphic = _interopRequireWildcard(require(\"../../util/graphic.js\"));\n\nvar layoutUtil = _interopRequireWildcard(require(\"../../util/layout.js\"));\n\nvar _LegendView = _interopRequireDefault(require(\"./LegendView.js\"));\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\n\nvar ScrollableLegendView =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(ScrollableLegendView, _super);\n\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n\n    this.group.add(this._controllerGroup = new Group());\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this; // Render content items.\n\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = zrUtil.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]\n\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n      }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n\n\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(_LegendView.default);\n\nvar _default = ScrollableLegendView;\nexports.default = _default;","map":{"version":3,"names":["Group","graphic","WH","XY","ScrollableLegendView","_super","__extends","_this","apply","arguments","type","newlineDisabled","_currentIndex","prototype","init","call","group","add","_containerGroup","getContentGroup","_controllerGroup","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","selector","orient","selectorPosition","self","controllerGroup","pageIconSize","get","pageIconSizeArr","zrUtil","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","text","fill","getTextColor","font","getFont","verticalAlign","align","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","selectorGroup","getSelectorGroup","orientIdx","index","wh","xy","hw","yx","layoutUtil","box","selectorButtonGap","selectorRect","getBoundingRect","selectorPos","processMaxSize","clone","mainRect","_layoutContentAndController","offset","Math","max","min","markRedraw","contentGroup","containerGroup","contentRect","controllerRect","showController","_showController","contentPos","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","setPosition","clipShape","setClipPath","Rect","shape","eachChild","child","attr","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","key","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","defaultIndex","idx","legendDataIdx","LegendView"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as layoutUtil from '../../util/layout.js';\nimport LegendView from './LegendView.js';\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\n\nvar ScrollableLegendView =\n/** @class */\nfunction (_super) {\n  __extends(ScrollableLegendView, _super);\n\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n\n    this.group.add(this._controllerGroup = new Group());\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this; // Render content items.\n\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = zrUtil.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]\n\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n\n\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(LegendView);\n\nexport default ScrollableLegendView;"],"mappings":"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"},"metadata":{},"sourceType":"script"}