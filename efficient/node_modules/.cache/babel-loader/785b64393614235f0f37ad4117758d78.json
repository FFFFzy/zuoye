{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TEXT_STYLE_OPTIONS = exports.SINGLE_REFERRING = exports.MULTIPLE_REFERRING = void 0;\nexports.compressBatches = compressBatches;\nexports.convertOptionIdName = convertOptionIdName;\nexports.defaultEmphasis = defaultEmphasis;\nexports.getAttribute = getAttribute;\nexports.getDataItemValue = getDataItemValue;\nexports.getTooltipRenderMode = getTooltipRenderMode;\nexports.groupData = groupData;\nexports.interpolateRawValues = interpolateRawValues;\nexports.isComponentIdInternal = isComponentIdInternal;\nexports.isDataItemOption = isDataItemOption;\nexports.isNameSpecified = isNameSpecified;\nexports.makeInner = makeInner;\nexports.makeInternalComponentId = makeInternalComponentId;\nexports.mappingToExists = mappingToExists;\nexports.normalizeToArray = normalizeToArray;\nexports.parseFinder = parseFinder;\nexports.preParseFinder = preParseFinder;\nexports.queryDataIndex = queryDataIndex;\nexports.queryReferringComponents = queryReferringComponents;\nexports.setAttribute = setAttribute;\nexports.setComponentTypeToKeyInfo = setComponentTypeToKeyInfo;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _env = _interopRequireDefault(require(\"zrender/lib/core/env.js\"));\n\nvar _number = require(\"./number.js\");\n\nvar _log = require(\"./log.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * Make the name displayable. But we should\n * make sure it is not duplicated with user\n * specified name, so use '\\0';\n */\n\n\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *          show: false,\n *          position: 'outside',\n *          fontSize: 18\n *     },\n *     emphasis: {\n *          label: { show: true }\n *     }\n */\n\n\nfunction defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\n\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * The method do not ensure performance.\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n */\n\nexports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;\n\nfunction getDataItemValue(dataItem) {\n  return (0, _util.isObject)(dataItem) && !(0, _util.isArray)(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n */\n\n\nfunction isDataItemOption(dataItem) {\n  return (0, _util.isObject)(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n\n;\n/**\n * Mapping to existings for merge.\n *\n * Mode \"normalMege\":\n *     The mapping result (merge result) will keep the order of the existing\n *     component, rather than the order of new option. Because we should ensure\n *     some specified index reference (like xAxisIndex) keep work.\n *     And in most cases, \"merge option\" is used to update partial option but not\n *     be expected to change the order.\n *\n * Mode \"replaceMege\":\n *     (1) Only the id mapped components will be merged.\n *     (2) Other existing components (except internal compoonets) will be removed.\n *     (3) Other new options will be used to create new component.\n *     (4) The index of the existing compoents will not be modified.\n *     That means their might be \"hole\" after the removal.\n *     The new components are created first at those available index.\n *\n * Mode \"replaceAll\":\n *     This mode try to support that reproduce an echarts instance from another\n *     echarts instance (via `getOption`) in some simple cases.\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\n *     the \"hole\" in `newCmptOptions` will also be kept.\n *     On the contrary, other modes try best to eliminate holes.\n *     PENDING: This is an experimental mode yet.\n *\n * @return See the comment of <MappingResult>.\n */\n\nfunction mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = (0, _util.createHashMap)(); // Validate id and name on user input option.\n\n  (0, _util.each)(newCmptOptions, function (cmptOption, index) {\n    if (!(0, _util.isObject)(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // There is some legacy case that name is set as `false`.\n      // But should work normally rather than throw error.\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n        warnInvalidateIdOrName(cmptOption.id);\n      }\n\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n        warnInvalidateIdOrName(cmptOption.name);\n      }\n    }\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will ommit those items and result in incorrect result.\n\n  return result;\n}\n\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n\n  if (mode === 'replaceAll') {\n    return result;\n  } // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be ommited.\n\n\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\n\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    } // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n\n\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n\n  return result;\n}\n\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  (0, _util.each)(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      (0, _util.assert)(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\n\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  (0, _util.each)(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\n\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  (0, _util.each)(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n\n\n    var resultItem;\n    var nextIdx = 0;\n\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n\n    nextIdx++;\n  });\n}\n\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  (0, _util.each)(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that compoennt index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = (0, _util.createHashMap)();\n  (0, _util.each)(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  (0, _util.each)(mapResult, function (item) {\n    var opt = item.newOption; // Force ensure id not duplicated.\n\n    (0, _util.assert)(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  (0, _util.each)(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n\n    if (!(0, _util.isObject)(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\n * @return return null if not exist.\n */\n\n\nfunction makeComparableKey(val) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (val == null) {\n      throw new Error();\n    }\n  }\n\n  return convertOptionIdName(val, '');\n}\n\nfunction convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n\n  return (0, _util.isString)(idOrName) ? idOrName : (0, _util.isNumber)(idOrName) || (0, _util.isStringSafe)(idOrName) ? idOrName + '' : defaultValue;\n}\n\nfunction warnInvalidateIdOrName(idOrName) {\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _log.warn)('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n  }\n}\n\nfunction isValidIdOrName(idOrName) {\n  return (0, _util.isStringSafe)(idOrName) || (0, _number.isNumeric)(idOrName);\n}\n\nfunction isNameSpecified(componentModel) {\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\n\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\n * @public\n * @param {Object} cmptOption\n * @return {boolean}\n */\n\n\nfunction isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\n\nfunction makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\n\nfunction setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  (0, _util.each)(mappingResult, function (item) {\n    var newOption = item.newOption;\n\n    if ((0, _util.isObject)(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\n\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return result: [resultBatchA, resultBatchB]\n */\n\n\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n      if (seriesId == null) {\n        return;\n      }\n\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return dataIndex If not found, return undefined/null.\n */\n\n\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return (0, _util.isArray)(payload.dataIndex) ? (0, _util.map)(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return (0, _util.isArray)(payload.name) ? (0, _util.map)(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * let inner = zrUitl.makeInner();\n *\n * function some1(hostObj) {\n *      inner(hostObj).someProperty = 1212;\n *      ...\n * }\n * function some2() {\n *      let fields = inner(this);\n *      fields.someProperty1 = 1212;\n *      fields.someProperty2 = 'xx';\n *      ...\n * }\n *\n * @return {Function}\n */\n\n\nfunction makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\n\nvar innerUniqueIndex = (0, _number.getRandomIdBase)();\n/**\n * The same behavior as `component.getReferringComponents`.\n */\n\nfunction parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n      mainTypeSpecified = _a.mainTypeSpecified,\n      queryOptionMap = _a.queryOptionMap,\n      others = _a.others;\n\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\n\nfunction preParseFinder(finderInput, opt) {\n  var finder;\n\n  if ((0, _util.isString)(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n\n  var queryOptionMap = (0, _util.createHashMap)();\n  var others = {};\n  var mainTypeSpecified = false;\n  (0, _util.each)(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || opt && opt.includeMainTypes && (0, _util.indexOf)(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\n\nvar SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nexports.SINGLE_REFERRING = SINGLE_REFERRING;\nvar MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nexports.MULTIPLE_REFERRING = MULTIPLE_REFERRING;\n\nfunction queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n\n  if (indexOption === 'none' || indexOption === false) {\n    (0, _util.assert)(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  } // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n\n\n  if (indexOption === 'all') {\n    (0, _util.assert)(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\n\nfunction setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\n\nfunction getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\n\nfunction getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return _env.default.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\n * Group a list by key.\n */\n\n\nfunction groupData(array, getKey // return key\n) {\n  var buckets = (0, _util.createHashMap)();\n  var keys = [];\n  (0, _util.each)(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\n * Interpolate raw values of a series with percent\n *\n * @param data         data\n * @param labelModel   label model of the text element\n * @param sourceValue  start value. May be null/undefined when init.\n * @param targetValue  end value\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\n * @return             interpolated values\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\n *                     Other cases do not supported.\n */\n\n\nfunction interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n\n  if (targetValue == null) {\n    return targetValue;\n  }\n\n  if ((0, _util.isNumber)(targetValue)) {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return (0, _number.round)(value, isAutoPrecision ? Math.max((0, _number.getPrecision)(sourceValue || 0), (0, _number.getPrecision)(targetValue)) : precision);\n  } else if ((0, _util.isString)(targetValue)) {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\n\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = (0, _number.round)(value, isAutoPrecision ? Math.max((0, _number.getPrecision)(leftVal), (0, _number.getPrecision)(rightVal)) : precision);\n      }\n    }\n\n    return interpolated;\n  }\n}","map":{"version":3,"names":["interpolateNumber","p0","p1","percent","DUMMY_COMPONENT_NAME_PREFIX","INTERNAL_COMPONENT_ID_PREFIX","normalizeToArray","value","Array","defaultEmphasis","opt","key","subOpts","emphasis","i","len","length","subOptName","hasOwnProperty","TEXT_STYLE_OPTIONS","getDataItemValue","dataItem","isObject","isArray","Date","isDataItemOption","mappingToExists","existings","newCmptOptions","mode","isNormalMergeMode","isReplaceMergeMode","isReplaceAllMode","slice","existingIdIdxMap","createHashMap","each","cmptOption","index","process","env","NODE_ENV","id","isValidIdOrName","warnInvalidateIdOrName","name","result","prepareResult","mappingById","mappingByName","mappingByIndex","mappingInReplaceAllMode","makeIdAndName","existing","set","push","isComponentIdInternal","newOption","keyInfo","brandNew","optionId","makeComparableKey","existingIdx","get","resultItem","assert","keyExistAndEqual","nextIdx","mapResult","idMap","item","idNum","attr","obj1","obj2","key1","convertOptionIdName","key2","val","Error","idOrName","defaultValue","isString","isNumber","isStringSafe","warn","isNumeric","isNameSpecified","componentModel","indexOf","makeInternalComponentId","idSuffix","setComponentTypeToKeyInfo","mappingResult","mainType","componentModelCtor","subType","determineSubType","newCmptOption","existComponent","type","compressBatches","batchA","batchB","mapA","mapB","makeMap","mapToArray","sourceBatch","map","otherMap","seriesId","dataIndices","dataIndex","otherDataIndices","j","lenj","isData","queryDataIndex","data","payload","dataIndexInside","indexOfRawIndex","indexOfName","makeInner","innerUniqueIndex","hostObj","getRandomIdBase","parseFinder","ecModel","finderInput","_a","preParseFinder","mainTypeSpecified","queryOptionMap","others","defaultMainType","queryOption","queryResult","queryReferringComponents","useDefault","enableAll","enableNone","models","finder","obj","parsedKey","match","queryType","toLowerCase","includeMainTypes","SINGLE_REFERRING","MULTIPLE_REFERRING","userOption","indexOption","idOption","nameOption","specified","firstCmpt","getComponent","queryComponents","setAttribute","dom","getAttribute","getTooltipRenderMode","renderModeOption","domSupported","groupData","array","getKey","buckets","keys","interpolateRawValues","precision","sourceValue","targetValue","isAutoPrecision","round","Math","max","getPrecision","interpolated","leftArr","rightArr","length_1","info","getDimensionInfo","leftVal","rightVal"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/util/model.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isObject, isArray, createHashMap, map, assert, isString, indexOf, isStringSafe, isNumber } from 'zrender/lib/core/util.js';\nimport env from 'zrender/lib/core/env.js';\nimport { isNumeric, getRandomIdBase, getPrecision, round } from './number.js';\nimport { warn } from './log.js';\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * Make the name displayable. But we should\n * make sure it is not duplicated with user\n * specified name, so use '\\0';\n */\n\n\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nexport function normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *          show: false,\n *          position: 'outside',\n *          fontSize: 18\n *     },\n *     emphasis: {\n *          label: { show: true }\n *     }\n */\n\nexport function defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\nexport var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * The method do not ensure performance.\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n */\n\nexport function getDataItemValue(dataItem) {\n  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n */\n\nexport function isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n;\n/**\n * Mapping to existings for merge.\n *\n * Mode \"normalMege\":\n *     The mapping result (merge result) will keep the order of the existing\n *     component, rather than the order of new option. Because we should ensure\n *     some specified index reference (like xAxisIndex) keep work.\n *     And in most cases, \"merge option\" is used to update partial option but not\n *     be expected to change the order.\n *\n * Mode \"replaceMege\":\n *     (1) Only the id mapped components will be merged.\n *     (2) Other existing components (except internal compoonets) will be removed.\n *     (3) Other new options will be used to create new component.\n *     (4) The index of the existing compoents will not be modified.\n *     That means their might be \"hole\" after the removal.\n *     The new components are created first at those available index.\n *\n * Mode \"replaceAll\":\n *     This mode try to support that reproduce an echarts instance from another\n *     echarts instance (via `getOption`) in some simple cases.\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\n *     the \"hole\" in `newCmptOptions` will also be kept.\n *     On the contrary, other modes try best to eliminate holes.\n *     PENDING: This is an experimental mode yet.\n *\n * @return See the comment of <MappingResult>.\n */\n\nexport function mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.\n\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!isObject(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // There is some legacy case that name is set as `false`.\n      // But should work normally rather than throw error.\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n        warnInvalidateIdOrName(cmptOption.id);\n      }\n\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n        warnInvalidateIdOrName(cmptOption.name);\n      }\n    }\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will ommit those items and result in incorrect result.\n\n  return result;\n}\n\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n\n  if (mode === 'replaceAll') {\n    return result;\n  } // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be ommited.\n\n\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\n\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    } // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n\n\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n\n  return result;\n}\n\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\n\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\n\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  each(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n\n\n    var resultItem;\n    var nextIdx = 0;\n\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n\n    nextIdx++;\n  });\n}\n\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  each(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that compoennt index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = createHashMap();\n  each(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  each(mapResult, function (item) {\n    var opt = item.newOption; // Force ensure id not duplicated.\n\n    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\n * @return return null if not exist.\n */\n\n\nfunction makeComparableKey(val) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (val == null) {\n      throw new Error();\n    }\n  }\n\n  return convertOptionIdName(val, '');\n}\n\nexport function convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n\n  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\n}\n\nfunction warnInvalidateIdOrName(idOrName) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n  }\n}\n\nfunction isValidIdOrName(idOrName) {\n  return isStringSafe(idOrName) || isNumeric(idOrName);\n}\n\nexport function isNameSpecified(componentModel) {\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\n\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\n * @public\n * @param {Object} cmptOption\n * @return {boolean}\n */\n\nexport function isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\nexport function makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\nexport function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  each(mappingResult, function (item) {\n    var newOption = item.newOption;\n\n    if (isObject(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\n\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return result: [resultBatchA, resultBatchB]\n */\n\n\nexport function compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n      if (seriesId == null) {\n        return;\n      }\n\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return dataIndex If not found, return undefined/null.\n */\n\nexport function queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return isArray(payload.name) ? map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * let inner = zrUitl.makeInner();\n *\n * function some1(hostObj) {\n *      inner(hostObj).someProperty = 1212;\n *      ...\n * }\n * function some2() {\n *      let fields = inner(this);\n *      fields.someProperty1 = 1212;\n *      fields.someProperty2 = 'xx';\n *      ...\n * }\n *\n * @return {Function}\n */\n\nexport function makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\nvar innerUniqueIndex = getRandomIdBase();\n/**\n * The same behavior as `component.getReferringComponents`.\n */\n\nexport function parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n      mainTypeSpecified = _a.mainTypeSpecified,\n      queryOptionMap = _a.queryOptionMap,\n      others = _a.others;\n\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\nexport function preParseFinder(finderInput, opt) {\n  var finder;\n\n  if (isString(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n\n  var queryOptionMap = createHashMap();\n  var others = {};\n  var mainTypeSpecified = false;\n  each(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\nexport var SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nexport var MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nexport function queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n\n  if (indexOption === 'none' || indexOption === false) {\n    assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  } // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n\n\n  if (indexOption === 'all') {\n    assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\nexport function setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\nexport function getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\nexport function getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return env.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\n * Group a list by key.\n */\n\nexport function groupData(array, getKey // return key\n) {\n  var buckets = createHashMap();\n  var keys = [];\n  each(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\n * Interpolate raw values of a series with percent\n *\n * @param data         data\n * @param labelModel   label model of the text element\n * @param sourceValue  start value. May be null/undefined when init.\n * @param targetValue  end value\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\n * @return             interpolated values\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\n *                     Other cases do not supported.\n */\n\nexport function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n\n  if (targetValue == null) {\n    return targetValue;\n  }\n\n  if (isNumber(targetValue)) {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);\n  } else if (isString(targetValue)) {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\n\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);\n      }\n    }\n\n    return interpolated;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}