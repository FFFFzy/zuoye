{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GeoSVGResource = void 0;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _parseSVG = require(\"zrender/lib/tool/parseSVG.js\");\n\nvar _Group = _interopRequireDefault(require(\"zrender/lib/graphic/Group.js\"));\n\nvar _Rect = _interopRequireDefault(require(\"zrender/lib/graphic/shape/Rect.js\"));\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _BoundingRect = _interopRequireDefault(require(\"zrender/lib/core/BoundingRect.js\"));\n\nvar _parseXML = require(\"zrender/lib/tool/parseXML.js\");\n\nvar _Region = require(\"./Region.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\n * to make it be a region.\n * 1. region styles and its label styles can be defined in echarts opton:\n * ```js\n * geo: {\n *     regions: [{\n *         name: 'xxx',\n *         itemStyle: { ... },\n *         label: { ... }\n *     }, {\n *         ...\n *     },\n *     ...]\n * };\n * ```\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\n * no common parents but both of them need to display label \"lung\" inside.\n */\nvar REGION_AVAILABLE_SVG_TAG_MAP = (0, _util.createHashMap)(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\n\nvar GeoSVGResource =\n/** @class */\nfunction () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\n\n    this._usedGraphicMap = (0, _util.createHashMap)(); // All unused graphics.\n\n    this._freedGraphics = [];\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n\n    this._parsedXML = (0, _parseXML.parseXML)(svg);\n  }\n\n  GeoSVGResource.prototype.load = function ()\n  /* nameMap: NameMap */\n  {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n\n      this._freedGraphics.push(firstGraphic);\n\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n\n      var _a = createRegions(firstGraphic.named),\n          regions = _a.regions,\n          regionsMap = _a.regionsMap;\n\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n\n    try {\n      result = svgXML && (0, _parseSVG.parseSVG)(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      (0, _util.assert)(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\n\n\n    var root = new _Group.default();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      } // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n\n\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n\n      boundingRect = this._boundingRect = new _BoundingRect.default(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n\n    if (viewBoxRect) {\n      var viewBoxTransform = (0, _parseSVG.makeViewBoxTransform)(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\n\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n\n\n    root.setClipPath(new _Rect.default({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    (0, _util.each)(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\n   * Consider:\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\n   * (2) Converting SVG to graphic elements is time consuming.\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\n   *     and it is called without view info.\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\n   * graphics from/to the pool with it's uid.\n   */\n\n\n  GeoSVGResource.prototype.useGraphic = function (hostKey\n  /*, nameMap: NameMap */\n  ) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n\n    return svgGraphic;\n  };\n\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n\n  return GeoSVGResource;\n}();\n\nexports.GeoSVGResource = GeoSVGResource;\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false; // text|tspan will be converted to group.\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\n\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = (0, _util.createHashMap)(); // Create resions only for the first graphic.\n\n  (0, _util.each)(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n\n    var region = new _Region.GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n} // PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }","map":{"version":3,"names":["REGION_AVAILABLE_SVG_TAG_MAP","createHashMap","GeoSVGResource","mapName","svg","type","_usedGraphicMap","_freedGraphics","_mapName","_parsedXML","parseXML","prototype","load","firstGraphic","_firstGraphic","_buildGraphic","push","_boundingRect","boundingRect","clone","_a","createRegions","named","regions","regionsMap","_regions","_regionsMap","svgXML","result","rootFromParse","parseSVG","ignoreViewBox","ignoreRootClip","root","assert","e","Error","message","Group","add","isGeoSVGGraphicRoot","svgWidth","width","svgHeight","height","viewBoxRect","bRectX","bRectY","bRectWidth","bRectHeight","x","y","calculatedBoundingRect","getBoundingRect","BoundingRect","viewBoxTransform","makeViewBoxTransform","scaleX","scaleY","scale","setClipPath","Rect","shape","plain","each","namedItem","get","svgNodeTagLower","setSilent","el","useGraphic","hostKey","usedRootMap","svgGraphic","pop","set","freeGraphic","removeKey","silent","isGroup","traverse","child","namedFrom","region","GeoSVGRegion","name"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/coord/geo/GeoSVGResource.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseSVG, makeViewBoxTransform } from 'zrender/lib/tool/parseSVG.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport Rect from 'zrender/lib/graphic/shape/Rect.js';\nimport { assert, createHashMap, each } from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parseXML } from 'zrender/lib/tool/parseXML.js';\nimport { GeoSVGRegion } from './Region.js';\n/**\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\n * to make it be a region.\n * 1. region styles and its label styles can be defined in echarts opton:\n * ```js\n * geo: {\n *     regions: [{\n *         name: 'xxx',\n *         itemStyle: { ... },\n *         label: { ... }\n *     }, {\n *         ...\n *     },\n *     ...]\n * };\n * ```\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\n * no common parents but both of them need to display label \"lung\" inside.\n */\n\nvar REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\n\nvar GeoSVGResource =\n/** @class */\nfunction () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\n\n    this._usedGraphicMap = createHashMap(); // All unused graphics.\n\n    this._freedGraphics = [];\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n\n    this._parsedXML = parseXML(svg);\n  }\n\n  GeoSVGResource.prototype.load = function ()\n  /* nameMap: NameMap */\n  {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n\n      this._freedGraphics.push(firstGraphic);\n\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n\n      var _a = createRegions(firstGraphic.named),\n          regions = _a.regions,\n          regionsMap = _a.regionsMap;\n\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n\n    try {\n      result = svgXML && parseSVG(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      assert(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\n\n\n    var root = new Group();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      } // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n\n\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n\n      boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n\n    if (viewBoxRect) {\n      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\n\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n\n\n    root.setClipPath(new Rect({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    each(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\n   * Consider:\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\n   * (2) Converting SVG to graphic elements is time consuming.\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\n   *     and it is called without view info.\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\n   * graphics from/to the pool with it's uid.\n   */\n\n\n  GeoSVGResource.prototype.useGraphic = function (hostKey\n  /*, nameMap: NameMap */\n  ) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n\n    return svgGraphic;\n  };\n\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n\n  return GeoSVGResource;\n}();\n\nexport { GeoSVGResource };\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false; // text|tspan will be converted to group.\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\n\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = createHashMap(); // Create resions only for the first graphic.\n\n  each(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n\n    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n} // PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }"],"mappings":"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"},"metadata":{},"sourceType":"script"}