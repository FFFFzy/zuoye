{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar modelUtil = _interopRequireWildcard(require(\"../util/model.js\"));\n\nvar _Model = _interopRequireDefault(require(\"./Model.js\"));\n\nvar _Component = _interopRequireDefault(require(\"./Component.js\"));\n\nvar _globalDefault = _interopRequireDefault(require(\"./globalDefault.js\"));\n\nvar _sourceHelper = require(\"../data/helper/sourceHelper.js\");\n\nvar _internalComponentCreator = require(\"./internalComponentCreator.js\");\n\nvar _palette = require(\"./mixin/palette.js\");\n\nvar _log = require(\"../util/log.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\n * consistent to the original sequence, even though there might result in \"hole\".\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n// -----------------------\n// Internal method names:\n// -----------------------\nvar reCreateSeriesIndices;\nvar assertSeriesInitialized;\nvar initBase;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\nvar OPTION_INNER_VALUE = 1;\nvar BUITIN_COMPONENTS_MAP = {\n  grid: 'GridComponent',\n  polar: 'PolarComponent',\n  geo: 'GeoComponent',\n  singleAxis: 'SingleAxisComponent',\n  parallel: 'ParallelComponent',\n  calendar: 'CalendarComponent',\n  graphic: 'GraphicComponent',\n  toolbox: 'ToolboxComponent',\n  tooltip: 'TooltipComponent',\n  axisPointer: 'AxisPointerComponent',\n  brush: 'BrushComponent',\n  title: 'TitleComponent',\n  timeline: 'TimelineComponent',\n  markPoint: 'MarkPointComponent',\n  markLine: 'MarkLineComponent',\n  markArea: 'MarkAreaComponent',\n  legend: 'LegendComponent',\n  dataZoom: 'DataZoomComponent',\n  visualMap: 'VisualMapComponent',\n  // aria: 'AriaComponent',\n  // dataset: 'DatasetComponent',\n  // Dependencies\n  xAxis: 'GridComponent',\n  yAxis: 'GridComponent',\n  angleAxis: 'PolarComponent',\n  radiusAxis: 'PolarComponent'\n};\nvar BUILTIN_CHARTS_MAP = {\n  line: 'LineChart',\n  bar: 'BarChart',\n  pie: 'PieChart',\n  scatter: 'ScatterChart',\n  radar: 'RadarChart',\n  map: 'MapChart',\n  tree: 'TreeChart',\n  treemap: 'TreemapChart',\n  graph: 'GraphChart',\n  gauge: 'GaugeChart',\n  funnel: 'FunnelChart',\n  parallel: 'ParallelChart',\n  sankey: 'SankeyChart',\n  boxplot: 'BoxplotChart',\n  candlestick: 'CandlestickChart',\n  effectScatter: 'EffectScatterChart',\n  lines: 'LinesChart',\n  heatmap: 'HeatmapChart',\n  pictorialBar: 'PictorialBarChart',\n  themeRiver: 'ThemeRiverChart',\n  sunburst: 'SunburstChart',\n  custom: 'CustomChart'\n};\nvar componetsMissingLogPrinted = {};\n\nfunction checkMissingComponents(option) {\n  (0, _util.each)(option, function (componentOption, mainType) {\n    if (!_Component.default.hasClass(mainType)) {\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\n\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\n        (0, _log.error)(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\n        componetsMissingLogPrinted[componentImportName] = true;\n      }\n    }\n  });\n}\n\nvar GlobalModel =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(GlobalModel, _super);\n\n  function GlobalModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    this._theme = new _Model.default(theme);\n    this._locale = new _Model.default(locale);\n    this._optionManager = optionManager;\n  };\n\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(option != null, 'option is null/undefined');\n      (0, _util.assert)(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\n    }\n\n    var innerOpt = normalizeSetOptionInput(opts);\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n\n    this._resetOption(null, innerOpt);\n  };\n  /**\n   * @param type null/undefined: reset all.\n   *        'recreate': force recreate all.\n   *        'timeline': only reset timeline option\n   *        'media': only reset media query option\n   * @return Whether option changed.\n   */\n\n\n  GlobalModel.prototype.resetOption = function (type, opt) {\n    return this._resetOption(type, normalizeSetOptionInput(opt));\n  };\n\n  GlobalModel.prototype._resetOption = function (type, opt) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkMissingComponents(baseOption);\n      }\n\n      if (!this.option || type === 'recreate') {\n        initBase(this, baseOption);\n      } else {\n        this.restoreData();\n\n        this._mergeOption(baseOption, opt);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\n    // it should better not have the same props with `MediaUnit['option']`.\n    // Becuase either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\n    // rather than original \"baseOption\". If they both override a prop, the result might be\n    // unexpected when media state changed after `setOption` called.\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\n    // (`{baseOption, media}`) in `setOption`.\n    // For `timeline`, the case is the same.\n\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n\n      if (timelineOption) {\n        optionChanged = true;\n\n        this._mergeOption(timelineOption, opt);\n      }\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this);\n\n      if (mediaOptions.length) {\n        (0, _util.each)(mediaOptions, function (mediaOption) {\n          optionChanged = true;\n\n          this._mergeOption(mediaOption, opt);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  };\n\n  GlobalModel.prototype.mergeOption = function (option) {\n    this._mergeOption(option, null);\n  };\n\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var componentsCount = this._componentsCount;\n    var newCmptTypes = [];\n    var newCmptTypeMap = (0, _util.createHashMap)();\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n    (0, _sourceHelper.resetSourceDefaulter)(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    (0, _util.each)(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!_Component.default.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? (0, _util.clone)(componentOption) : (0, _util.merge)(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCmptTypes.push(mainType);\n        newCmptTypeMap.set(mainType, true);\n      }\n    });\n\n    if (replaceMergeMainTypeMap) {\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n        if (_Component.default.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n          newCmptTypes.push(mainTypeInReplaceMerge);\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n        }\n      });\n    }\n\n    _Component.default.topologicalTravel(newCmptTypes, _Component.default.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType) {\n      var newCmptOptionList = (0, _internalComponentCreator.concatInternalOptions)(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));\n      var oldCmptList = componentsMap.get(mainType);\n      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.\n\n      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, _Component.default); // Empty it before the travel, in order to prevent `this._componentsMap`\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\n      // components, which is probably incorrect logic.\n\n      option[mainType] = null;\n      componentsMap.set(mainType, null);\n      componentsCount.set(mainType, 0);\n      var optionsByMainType = [];\n      var cmptsByMainType = [];\n      var cmptsCountByMainType = 0;\n      var tooltipExists;\n      var tooltipWarningLogged;\n      (0, _util.each)(mappingResult, function (resultItem, index) {\n        var componentModel = resultItem.existing;\n        var newCmptOption = resultItem.newOption;\n\n        if (!newCmptOption) {\n          if (componentModel) {\n            // Consider where is no new option and should be merged using {},\n            // see removeEdgeAndAdd in topologicalTravel and\n            // ComponentModel.getAllClassMainTypes.\n            componentModel.mergeOption({}, this);\n            componentModel.optionUpdated({}, false);\n          } // If no both `resultItem.exist` and `resultItem.option`,\n          // either it is in `replaceMerge` and not matched by any id,\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\n\n        } else {\n          var isSeriesType = mainType === 'series';\n\n          var ComponentModelClass = _Component.default.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\n          );\n\n          if (!ComponentModelClass) {\n            if (process.env.NODE_ENV !== 'production') {\n              var subType = resultItem.keyInfo.subType;\n              var seriesImportName = BUILTIN_CHARTS_MAP[subType];\n\n              if (!componetsMissingLogPrinted[subType]) {\n                componetsMissingLogPrinted[subType] = true;\n\n                if (seriesImportName) {\n                  (0, _log.error)(\"Series \" + subType + \" is used but not imported.\\nimport { \" + seriesImportName + \" } from 'echarts/charts';\\necharts.use([\" + seriesImportName + \"]);\");\n                } else {\n                  (0, _log.error)(\"Unkown series \" + subType);\n                }\n              }\n            }\n\n            return;\n          } // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.\n\n\n          if (mainType === 'tooltip') {\n            if (tooltipExists) {\n              if (process.env.NODE_ENV !== 'production') {\n                if (!tooltipWarningLogged) {\n                  (0, _log.warn)('Currently only one tooltip component is allowed.');\n                  tooltipWarningLogged = true;\n                }\n              }\n\n              return;\n            }\n\n            tooltipExists = true;\n          }\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCmptOption, this);\n            componentModel.optionUpdated(newCmptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = (0, _util.extend)({\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`\n\n            (0, _util.extend)(componentModel, extraOpt);\n\n            if (resultItem.brandNew) {\n              componentModel.__requireNewView = true;\n            }\n\n            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.\n            // newCmptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        if (componentModel) {\n          optionsByMainType.push(componentModel.option);\n          cmptsByMainType.push(componentModel);\n          cmptsCountByMainType++;\n        } else {\n          // Always do assign to avoid elided item in array.\n          optionsByMainType.push(void 0);\n          cmptsByMainType.push(void 0);\n        }\n      }, this);\n      option[mainType] = optionsByMainType;\n      componentsMap.set(mainType, cmptsByMainType);\n      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        reCreateSeriesIndices(this);\n      }\n    } // If no series declared, ensure `_seriesIndices` initialized.\n\n\n    if (!this._seriesIndices) {\n      reCreateSeriesIndices(this);\n    }\n  };\n  /**\n   * Get option for output (cloned option and inner info removed)\n   */\n\n\n  GlobalModel.prototype.getOption = function () {\n    var option = (0, _util.clone)(this.option);\n    (0, _util.each)(option, function (optInMainType, mainType) {\n      if (_Component.default.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(optInMainType); // Inner cmpts need to be removed.\n        // Inner cmpts might not be at last since ec5.0, but still\n        // compatible for users: if inner cmpt at last, splice the returned array.\n\n        var realLen = opts.length;\n        var metNonInner = false;\n\n        for (var i = realLen - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {\n            metNonInner = true;\n          } else {\n            opts[i] = null;\n            !metNonInner && realLen--;\n          }\n        }\n\n        opts.length = realLen;\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  };\n\n  GlobalModel.prototype.getTheme = function () {\n    return this._theme;\n  };\n\n  GlobalModel.prototype.getLocaleModel = function () {\n    return this._locale;\n  };\n\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\n    this._payload = payload;\n  };\n\n  GlobalModel.prototype.getUpdatePayload = function () {\n    return this._payload;\n  };\n  /**\n   * @param idx If not specified, return the first one.\n   */\n\n\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      var cmpt = list[idx || 0];\n\n      if (cmpt) {\n        return cmpt;\n      } else if (idx == null) {\n        for (var i = 0; i < list.length; i++) {\n          if (list[i]) {\n            return list[i];\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @return Never be null/undefined.\n   */\n\n\n  GlobalModel.prototype.queryComponents = function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cmpts = this._componentsMap.get(mainType);\n\n    if (!cmpts || !cmpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      result = [];\n      (0, _util.each)(modelUtil.normalizeToArray(index), function (idx) {\n        cmpts[idx] && result.push(cmpts[idx]);\n      });\n    } else if (id != null) {\n      result = queryByIdOrName('id', id, cmpts);\n    } else if (name != null) {\n      result = queryByIdOrName('name', name, cmpts);\n    } else {\n      // Return all non-empty components in that mainType\n      result = (0, _util.filter)(cmpts, function (cmpt) {\n        return !!cmpt;\n      });\n    }\n\n    return filterBySubType(result, condition);\n  };\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * let result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   */\n\n\n  GlobalModel.prototype.findComponents = function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.\n    : (0, _util.filter)(this._componentsMap.get(mainType), function (cmpt) {\n      return !!cmpt;\n    });\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? (0, _util.filter)(res, condition.filter) : res;\n    }\n  };\n\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if ((0, _util.isFunction)(mainType)) {\n      var ctxForAll_1 = cb;\n      var cbForAll_1 = mainType;\n      componentsMap.each(function (cmpts, componentType) {\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\n          var cmpt = cmpts[i];\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n        }\n      });\n    } else {\n      var cmpts = (0, _util.isString)(mainType) ? componentsMap.get(mainType) : (0, _util.isObject)(mainType) ? this.findComponents(mainType) : null;\n\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\n        var cmpt = cmpts[i];\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n      }\n    }\n  };\n  /**\n   * Get series list before filtered by name.\n   */\n\n\n  GlobalModel.prototype.getSeriesByName = function (name) {\n    var nameStr = modelUtil.convertOptionIdName(name, null);\n    return (0, _util.filter)(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n    });\n  };\n  /**\n   * Get series list before filtered by index.\n   */\n\n\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  };\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   */\n\n\n  GlobalModel.prototype.getSeriesByType = function (subType) {\n    return (0, _util.filter)(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && oneSeries.subType === subType;\n    });\n  };\n  /**\n   * Get all series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeries = function () {\n    return (0, _util.filter)(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries;\n    });\n  };\n  /**\n   * Count series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeriesCount = function () {\n    return this._componentsCount.get('series');\n  };\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    (0, _util.each)(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n\n\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\n    (0, _util.each)(this._componentsMap.get('series'), function (series) {\n      series && cb.call(context, series, series.componentIndex);\n    });\n  };\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    (0, _util.each)(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered of given type.\n   */\n\n\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n    return (0, _util.each)(this.getSeriesByType(subType), cb, context);\n  };\n\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  };\n\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\n    return (this._seriesIndices || []).slice();\n  };\n\n  GlobalModel.prototype.filterSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    var newSeriesIndices = [];\n    (0, _util.each)(this._seriesIndices, function (seriesRawIdx) {\n      var series = this._componentsMap.get('series')[seriesRawIdx];\n\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n    }, this);\n    this._seriesIndices = newSeriesIndices;\n    this._seriesIndicesMap = (0, _util.createHashMap)(newSeriesIndices);\n  };\n\n  GlobalModel.prototype.restoreData = function (payload) {\n    reCreateSeriesIndices(this);\n    var componentsMap = this._componentsMap;\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      if (_Component.default.hasClass(componentType)) {\n        componentTypes.push(componentType);\n      }\n    });\n\n    _Component.default.topologicalTravel(componentTypes, _Component.default.getAllClassMainTypes(), function (componentType) {\n      (0, _util.each)(componentsMap.get(componentType), function (component) {\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n          component.restoreData();\n        }\n      });\n    });\n  };\n\n  GlobalModel.internalField = function () {\n    reCreateSeriesIndices = function (ecModel) {\n      var seriesIndices = ecModel._seriesIndices = [];\n      (0, _util.each)(ecModel._componentsMap.get('series'), function (series) {\n        // series may have been removed by `replaceMerge`.\n        series && seriesIndices.push(series.componentIndex);\n      });\n      ecModel._seriesIndicesMap = (0, _util.createHashMap)(seriesIndices);\n    };\n\n    assertSeriesInitialized = function (ecModel) {\n      // Components that use _seriesIndices should depends on series component,\n      // which make sure that their initialization is after series.\n      if (process.env.NODE_ENV !== 'production') {\n        if (!ecModel._seriesIndices) {\n          throw new Error('Option should contains series.');\n        }\n      }\n    };\n\n    initBase = function (ecModel, baseOption) {\n      // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n      ecModel.option = {};\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method\n      // before series initialized.\n\n      ecModel._componentsMap = (0, _util.createHashMap)({\n        series: []\n      });\n      ecModel._componentsCount = (0, _util.createHashMap)(); // If user spefied `option.aria`, aria will be enable. This detection should be\n      // performed before theme and globalDefault merge.\n\n      var airaOption = baseOption.aria;\n\n      if ((0, _util.isObject)(airaOption) && airaOption.enabled == null) {\n        airaOption.enabled = true;\n      }\n\n      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property\n\n      (0, _util.merge)(baseOption, _globalDefault.default, false);\n\n      ecModel._mergeOption(baseOption, null);\n    };\n  }();\n\n  return GlobalModel;\n}(_Model.default);\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seriesIndex;\n    var id = payload.seriesId;\n    var name_1 = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n  }\n}\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  (0, _util.each)(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // If it is component model mainType, the model handles that merge later.\n    // otherwise, merge them here.\n\n\n    if (!_Component.default.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? (0, _util.clone)(themeItem) : (0, _util.merge)(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction queryByIdOrName(attr, idOrName, cmpts) {\n  // Here is a break from echarts4: string and number are\n  // treated as equal.\n  if ((0, _util.isArray)(idOrName)) {\n    var keyMap_1 = (0, _util.createHashMap)();\n    (0, _util.each)(idOrName, function (idOrNameItem) {\n      if (idOrNameItem != null) {\n        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);\n        idName != null && keyMap_1.set(idOrNameItem, true);\n      }\n    });\n    return (0, _util.filter)(cmpts, function (cmpt) {\n      return cmpt && keyMap_1.get(cmpt[attr]);\n    });\n  } else {\n    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);\n    return (0, _util.filter)(cmpts, function (cmpt) {\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n    });\n  }\n}\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? (0, _util.filter)(components, function (cmpt) {\n    return cmpt && cmpt.subType === condition.subType;\n  }) : components;\n}\n\nfunction normalizeSetOptionInput(opts) {\n  var replaceMergeMainTypeMap = (0, _util.createHashMap)();\n  opts && (0, _util.each)(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(_Component.default.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\n    }\n\n    replaceMergeMainTypeMap.set(mainType, true);\n  });\n  return {\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\n  };\n}\n\n(0, _util.mixin)(GlobalModel, _palette.PaletteMixin);\nvar _default = GlobalModel;\nexports.default = _default;","map":{"version":3,"names":["reCreateSeriesIndices","assertSeriesInitialized","initBase","OPTION_INNER_KEY","OPTION_INNER_VALUE","BUITIN_COMPONENTS_MAP","grid","polar","geo","singleAxis","parallel","calendar","graphic","toolbox","tooltip","axisPointer","brush","title","timeline","markPoint","markLine","markArea","legend","dataZoom","visualMap","xAxis","yAxis","angleAxis","radiusAxis","BUILTIN_CHARTS_MAP","line","bar","pie","scatter","radar","map","tree","treemap","graph","gauge","funnel","sankey","boxplot","candlestick","effectScatter","lines","heatmap","pictorialBar","themeRiver","sunburst","custom","componetsMissingLogPrinted","checkMissingComponents","option","each","componentOption","mainType","ComponentModel","hasClass","componentImportName","error","GlobalModel","_super","__extends","apply","arguments","prototype","init","parentModel","ecModel","theme","locale","optionManager","_theme","Model","_locale","_optionManager","setOption","opts","optionPreprocessorFuncs","process","env","NODE_ENV","assert","innerOpt","normalizeSetOptionInput","_resetOption","resetOption","type","opt","optionChanged","baseOption","mountOption","restoreData","_mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","length","mediaOption","mergeOption","newOption","componentsMap","_componentsMap","componentsCount","_componentsCount","newCmptTypes","newCmptTypeMap","createHashMap","replaceMergeMainTypeMap","resetSourceDefaulter","clone","merge","push","set","val","mainTypeInReplaceMerge","get","topologicalTravel","getAllClassMainTypes","visitComponent","newCmptOptionList","concatInternalOptions","modelUtil","normalizeToArray","oldCmptList","mergeMode","mappingResult","mappingToExists","setComponentTypeToKeyInfo","optionsByMainType","cmptsByMainType","cmptsCountByMainType","tooltipExists","tooltipWarningLogged","resultItem","index","componentModel","existing","newCmptOption","optionUpdated","isSeriesType","ComponentModelClass","getClass","keyInfo","subType","seriesImportName","warn","constructor","name","extraOpt","extend","componentIndex","brandNew","__requireNewView","_seriesIndices","getOption","optInMainType","realLen","metNonInner","i","isComponentIdInternal","getTheme","getLocaleModel","setUpdatePayload","payload","_payload","getUpdatePayload","getComponent","idx","list","cmpt","queryComponents","condition","id","cmpts","result","queryByIdOrName","filter","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","isFunction","ctxForAll_1","cbForAll_1","componentType","call","isString","isObject","getSeriesByName","nameStr","convertOptionIdName","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","getSeriesCount","eachSeries","rawSeriesIndex","series","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","_seriesIndicesMap","getCurrentSeriesIndices","slice","filterSeries","newSeriesIndices","seriesRawIdx","componentTypes","components","component","isNotTargetSeries","internalField","seriesIndices","Error","airaOption","aria","enabled","mergeTheme","globalDefault","seriesId","name_1","seriesName","notMergeColorLayer","color","colorLayer","themeItem","attr","idOrName","isArray","keyMap_1","idOrNameItem","idName","idName_1","hasOwnProperty","replaceMerge","mixin","PaletteMixin"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/model/Global.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\n * consistent to the original sequence, even though there might result in \"hole\".\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n\nimport { each, filter, isArray, isObject, isString, createHashMap, assert, clone, merge, extend, mixin, isFunction } from 'zrender/lib/core/util.js';\nimport * as modelUtil from '../util/model.js';\nimport Model from './Model.js';\nimport ComponentModel from './Component.js';\nimport globalDefault from './globalDefault.js';\nimport { resetSourceDefaulter } from '../data/helper/sourceHelper.js';\nimport { concatInternalOptions } from './internalComponentCreator.js';\nimport { PaletteMixin } from './mixin/palette.js';\nimport { error, warn } from '../util/log.js'; // -----------------------\n// Internal method names:\n// -----------------------\n\nvar reCreateSeriesIndices;\nvar assertSeriesInitialized;\nvar initBase;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\nvar OPTION_INNER_VALUE = 1;\nvar BUITIN_COMPONENTS_MAP = {\n  grid: 'GridComponent',\n  polar: 'PolarComponent',\n  geo: 'GeoComponent',\n  singleAxis: 'SingleAxisComponent',\n  parallel: 'ParallelComponent',\n  calendar: 'CalendarComponent',\n  graphic: 'GraphicComponent',\n  toolbox: 'ToolboxComponent',\n  tooltip: 'TooltipComponent',\n  axisPointer: 'AxisPointerComponent',\n  brush: 'BrushComponent',\n  title: 'TitleComponent',\n  timeline: 'TimelineComponent',\n  markPoint: 'MarkPointComponent',\n  markLine: 'MarkLineComponent',\n  markArea: 'MarkAreaComponent',\n  legend: 'LegendComponent',\n  dataZoom: 'DataZoomComponent',\n  visualMap: 'VisualMapComponent',\n  // aria: 'AriaComponent',\n  // dataset: 'DatasetComponent',\n  // Dependencies\n  xAxis: 'GridComponent',\n  yAxis: 'GridComponent',\n  angleAxis: 'PolarComponent',\n  radiusAxis: 'PolarComponent'\n};\nvar BUILTIN_CHARTS_MAP = {\n  line: 'LineChart',\n  bar: 'BarChart',\n  pie: 'PieChart',\n  scatter: 'ScatterChart',\n  radar: 'RadarChart',\n  map: 'MapChart',\n  tree: 'TreeChart',\n  treemap: 'TreemapChart',\n  graph: 'GraphChart',\n  gauge: 'GaugeChart',\n  funnel: 'FunnelChart',\n  parallel: 'ParallelChart',\n  sankey: 'SankeyChart',\n  boxplot: 'BoxplotChart',\n  candlestick: 'CandlestickChart',\n  effectScatter: 'EffectScatterChart',\n  lines: 'LinesChart',\n  heatmap: 'HeatmapChart',\n  pictorialBar: 'PictorialBarChart',\n  themeRiver: 'ThemeRiverChart',\n  sunburst: 'SunburstChart',\n  custom: 'CustomChart'\n};\nvar componetsMissingLogPrinted = {};\n\nfunction checkMissingComponents(option) {\n  each(option, function (componentOption, mainType) {\n    if (!ComponentModel.hasClass(mainType)) {\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\n\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\n        error(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\n        componetsMissingLogPrinted[componentImportName] = true;\n      }\n    }\n  });\n}\n\nvar GlobalModel =\n/** @class */\nfunction (_super) {\n  __extends(GlobalModel, _super);\n\n  function GlobalModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    this._theme = new Model(theme);\n    this._locale = new Model(locale);\n    this._optionManager = optionManager;\n  };\n\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(option != null, 'option is null/undefined');\n      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\n    }\n\n    var innerOpt = normalizeSetOptionInput(opts);\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n\n    this._resetOption(null, innerOpt);\n  };\n  /**\n   * @param type null/undefined: reset all.\n   *        'recreate': force recreate all.\n   *        'timeline': only reset timeline option\n   *        'media': only reset media query option\n   * @return Whether option changed.\n   */\n\n\n  GlobalModel.prototype.resetOption = function (type, opt) {\n    return this._resetOption(type, normalizeSetOptionInput(opt));\n  };\n\n  GlobalModel.prototype._resetOption = function (type, opt) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkMissingComponents(baseOption);\n      }\n\n      if (!this.option || type === 'recreate') {\n        initBase(this, baseOption);\n      } else {\n        this.restoreData();\n\n        this._mergeOption(baseOption, opt);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\n    // it should better not have the same props with `MediaUnit['option']`.\n    // Becuase either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\n    // rather than original \"baseOption\". If they both override a prop, the result might be\n    // unexpected when media state changed after `setOption` called.\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\n    // (`{baseOption, media}`) in `setOption`.\n    // For `timeline`, the case is the same.\n\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n\n      if (timelineOption) {\n        optionChanged = true;\n\n        this._mergeOption(timelineOption, opt);\n      }\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          optionChanged = true;\n\n          this._mergeOption(mediaOption, opt);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  };\n\n  GlobalModel.prototype.mergeOption = function (option) {\n    this._mergeOption(option, null);\n  };\n\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var componentsCount = this._componentsCount;\n    var newCmptTypes = [];\n    var newCmptTypeMap = createHashMap();\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCmptTypes.push(mainType);\n        newCmptTypeMap.set(mainType, true);\n      }\n    });\n\n    if (replaceMergeMainTypeMap) {\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n        if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n          newCmptTypes.push(mainTypeInReplaceMerge);\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n        }\n      });\n    }\n\n    ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType) {\n      var newCmptOptionList = concatInternalOptions(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));\n      var oldCmptList = componentsMap.get(mainType);\n      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.\n\n      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel); // Empty it before the travel, in order to prevent `this._componentsMap`\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\n      // components, which is probably incorrect logic.\n\n      option[mainType] = null;\n      componentsMap.set(mainType, null);\n      componentsCount.set(mainType, 0);\n      var optionsByMainType = [];\n      var cmptsByMainType = [];\n      var cmptsCountByMainType = 0;\n      var tooltipExists;\n      var tooltipWarningLogged;\n      each(mappingResult, function (resultItem, index) {\n        var componentModel = resultItem.existing;\n        var newCmptOption = resultItem.newOption;\n\n        if (!newCmptOption) {\n          if (componentModel) {\n            // Consider where is no new option and should be merged using {},\n            // see removeEdgeAndAdd in topologicalTravel and\n            // ComponentModel.getAllClassMainTypes.\n            componentModel.mergeOption({}, this);\n            componentModel.optionUpdated({}, false);\n          } // If no both `resultItem.exist` and `resultItem.option`,\n          // either it is in `replaceMerge` and not matched by any id,\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\n\n        } else {\n          var isSeriesType = mainType === 'series';\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\n          );\n\n          if (!ComponentModelClass) {\n            if (process.env.NODE_ENV !== 'production') {\n              var subType = resultItem.keyInfo.subType;\n              var seriesImportName = BUILTIN_CHARTS_MAP[subType];\n\n              if (!componetsMissingLogPrinted[subType]) {\n                componetsMissingLogPrinted[subType] = true;\n\n                if (seriesImportName) {\n                  error(\"Series \" + subType + \" is used but not imported.\\nimport { \" + seriesImportName + \" } from 'echarts/charts';\\necharts.use([\" + seriesImportName + \"]);\");\n                } else {\n                  error(\"Unkown series \" + subType);\n                }\n              }\n            }\n\n            return;\n          } // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.\n\n\n          if (mainType === 'tooltip') {\n            if (tooltipExists) {\n              if (process.env.NODE_ENV !== 'production') {\n                if (!tooltipWarningLogged) {\n                  warn('Currently only one tooltip component is allowed.');\n                  tooltipWarningLogged = true;\n                }\n              }\n\n              return;\n            }\n\n            tooltipExists = true;\n          }\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCmptOption, this);\n            componentModel.optionUpdated(newCmptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`\n\n            extend(componentModel, extraOpt);\n\n            if (resultItem.brandNew) {\n              componentModel.__requireNewView = true;\n            }\n\n            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.\n            // newCmptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        if (componentModel) {\n          optionsByMainType.push(componentModel.option);\n          cmptsByMainType.push(componentModel);\n          cmptsCountByMainType++;\n        } else {\n          // Always do assign to avoid elided item in array.\n          optionsByMainType.push(void 0);\n          cmptsByMainType.push(void 0);\n        }\n      }, this);\n      option[mainType] = optionsByMainType;\n      componentsMap.set(mainType, cmptsByMainType);\n      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        reCreateSeriesIndices(this);\n      }\n    } // If no series declared, ensure `_seriesIndices` initialized.\n\n\n    if (!this._seriesIndices) {\n      reCreateSeriesIndices(this);\n    }\n  };\n  /**\n   * Get option for output (cloned option and inner info removed)\n   */\n\n\n  GlobalModel.prototype.getOption = function () {\n    var option = clone(this.option);\n    each(option, function (optInMainType, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(optInMainType); // Inner cmpts need to be removed.\n        // Inner cmpts might not be at last since ec5.0, but still\n        // compatible for users: if inner cmpt at last, splice the returned array.\n\n        var realLen = opts.length;\n        var metNonInner = false;\n\n        for (var i = realLen - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {\n            metNonInner = true;\n          } else {\n            opts[i] = null;\n            !metNonInner && realLen--;\n          }\n        }\n\n        opts.length = realLen;\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  };\n\n  GlobalModel.prototype.getTheme = function () {\n    return this._theme;\n  };\n\n  GlobalModel.prototype.getLocaleModel = function () {\n    return this._locale;\n  };\n\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\n    this._payload = payload;\n  };\n\n  GlobalModel.prototype.getUpdatePayload = function () {\n    return this._payload;\n  };\n  /**\n   * @param idx If not specified, return the first one.\n   */\n\n\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      var cmpt = list[idx || 0];\n\n      if (cmpt) {\n        return cmpt;\n      } else if (idx == null) {\n        for (var i = 0; i < list.length; i++) {\n          if (list[i]) {\n            return list[i];\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @return Never be null/undefined.\n   */\n\n\n  GlobalModel.prototype.queryComponents = function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cmpts = this._componentsMap.get(mainType);\n\n    if (!cmpts || !cmpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      result = [];\n      each(modelUtil.normalizeToArray(index), function (idx) {\n        cmpts[idx] && result.push(cmpts[idx]);\n      });\n    } else if (id != null) {\n      result = queryByIdOrName('id', id, cmpts);\n    } else if (name != null) {\n      result = queryByIdOrName('name', name, cmpts);\n    } else {\n      // Return all non-empty components in that mainType\n      result = filter(cmpts, function (cmpt) {\n        return !!cmpt;\n      });\n    }\n\n    return filterBySubType(result, condition);\n  };\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * let result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   */\n\n\n  GlobalModel.prototype.findComponents = function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.\n    : filter(this._componentsMap.get(mainType), function (cmpt) {\n      return !!cmpt;\n    });\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  };\n\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (isFunction(mainType)) {\n      var ctxForAll_1 = cb;\n      var cbForAll_1 = mainType;\n      componentsMap.each(function (cmpts, componentType) {\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\n          var cmpt = cmpts[i];\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n        }\n      });\n    } else {\n      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;\n\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\n        var cmpt = cmpts[i];\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n      }\n    }\n  };\n  /**\n   * Get series list before filtered by name.\n   */\n\n\n  GlobalModel.prototype.getSeriesByName = function (name) {\n    var nameStr = modelUtil.convertOptionIdName(name, null);\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n    });\n  };\n  /**\n   * Get series list before filtered by index.\n   */\n\n\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  };\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   */\n\n\n  GlobalModel.prototype.getSeriesByType = function (subType) {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && oneSeries.subType === subType;\n    });\n  };\n  /**\n   * Get all series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeries = function () {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries;\n    });\n  };\n  /**\n   * Count series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeriesCount = function () {\n    return this._componentsCount.get('series');\n  };\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n\n\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\n    each(this._componentsMap.get('series'), function (series) {\n      series && cb.call(context, series, series.componentIndex);\n    });\n  };\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered of given type.\n   */\n\n\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  };\n\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  };\n\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\n    return (this._seriesIndices || []).slice();\n  };\n\n  GlobalModel.prototype.filterSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    var newSeriesIndices = [];\n    each(this._seriesIndices, function (seriesRawIdx) {\n      var series = this._componentsMap.get('series')[seriesRawIdx];\n\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n    }, this);\n    this._seriesIndices = newSeriesIndices;\n    this._seriesIndicesMap = createHashMap(newSeriesIndices);\n  };\n\n  GlobalModel.prototype.restoreData = function (payload) {\n    reCreateSeriesIndices(this);\n    var componentsMap = this._componentsMap;\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      if (ComponentModel.hasClass(componentType)) {\n        componentTypes.push(componentType);\n      }\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {\n      each(componentsMap.get(componentType), function (component) {\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n          component.restoreData();\n        }\n      });\n    });\n  };\n\n  GlobalModel.internalField = function () {\n    reCreateSeriesIndices = function (ecModel) {\n      var seriesIndices = ecModel._seriesIndices = [];\n      each(ecModel._componentsMap.get('series'), function (series) {\n        // series may have been removed by `replaceMerge`.\n        series && seriesIndices.push(series.componentIndex);\n      });\n      ecModel._seriesIndicesMap = createHashMap(seriesIndices);\n    };\n\n    assertSeriesInitialized = function (ecModel) {\n      // Components that use _seriesIndices should depends on series component,\n      // which make sure that their initialization is after series.\n      if (process.env.NODE_ENV !== 'production') {\n        if (!ecModel._seriesIndices) {\n          throw new Error('Option should contains series.');\n        }\n      }\n    };\n\n    initBase = function (ecModel, baseOption) {\n      // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n      ecModel.option = {};\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method\n      // before series initialized.\n\n      ecModel._componentsMap = createHashMap({\n        series: []\n      });\n      ecModel._componentsCount = createHashMap(); // If user spefied `option.aria`, aria will be enable. This detection should be\n      // performed before theme and globalDefault merge.\n\n      var airaOption = baseOption.aria;\n\n      if (isObject(airaOption) && airaOption.enabled == null) {\n        airaOption.enabled = true;\n      }\n\n      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property\n\n      merge(baseOption, globalDefault, false);\n\n      ecModel._mergeOption(baseOption, null);\n    };\n  }();\n\n  return GlobalModel;\n}(Model);\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seriesIndex;\n    var id = payload.seriesId;\n    var name_1 = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n  }\n}\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // If it is component model mainType, the model handles that merge later.\n    // otherwise, merge them here.\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction queryByIdOrName(attr, idOrName, cmpts) {\n  // Here is a break from echarts4: string and number are\n  // treated as equal.\n  if (isArray(idOrName)) {\n    var keyMap_1 = createHashMap();\n    each(idOrName, function (idOrNameItem) {\n      if (idOrNameItem != null) {\n        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);\n        idName != null && keyMap_1.set(idOrNameItem, true);\n      }\n    });\n    return filter(cmpts, function (cmpt) {\n      return cmpt && keyMap_1.get(cmpt[attr]);\n    });\n  } else {\n    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);\n    return filter(cmpts, function (cmpt) {\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n    });\n  }\n}\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {\n    return cmpt && cmpt.subType === condition.subType;\n  }) : components;\n}\n\nfunction normalizeSetOptionInput(opts) {\n  var replaceMergeMainTypeMap = createHashMap();\n  opts && each(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(ComponentModel.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\n    }\n\n    replaceMergeMainTypeMap.set(mainType, true);\n  });\n  return {\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\n  };\n}\n\nmixin(GlobalModel, PaletteMixin);\nexport default GlobalModel;"],"mappings":"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"},"metadata":{},"sourceType":"script"}