{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _layout = require(\"../../util/layout.js\");\n\nvar _axisHelper = require(\"../../coord/axisHelper.js\");\n\nvar _Cartesian2D = _interopRequireWildcard(require(\"./Cartesian2D.js\"));\n\nvar _Axis2D = _interopRequireDefault(require(\"./Axis2D.js\"));\n\nvar _model = require(\"../../util/model.js\");\n\nvar _cartesianAxisHelper = require(\"./cartesianAxisHelper.js\");\n\nvar _helper = require(\"../../scale/helper.js\");\n\nvar _axisAlignTicks = require(\"../axisAlignTicks.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar Grid =\n/** @class */\nfunction () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = _Cartesian2D.cartesian2DDimensions;\n\n    this._initCartesian(gridModel, ecModel, api);\n\n    this.model = gridModel;\n  }\n\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n\n    this._updateScale(ecModel, this.model);\n\n    function updateAxisTicks(axes) {\n      var alignTo; // Axis is added in order of axisIndex.\n\n      var axesIndices = (0, _util.keys)(axes);\n      var len = axesIndices.length;\n\n      if (!len) {\n        return;\n      }\n\n      var axisNeedsAlign = []; // Process once and calculate the ticks for those don't use alignTicks.\n\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n\n        if ( // Only value and log axis without interval support alignTicks.\n        (0, _helper.isIntervalOrLogScale)(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          (0, _axisHelper.niceScaleExtent)(scale, model);\n\n          if ((0, _helper.isIntervalOrLogScale)(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n\n      ; // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          (0, _axisHelper.niceScaleExtent)(alignTo.scale, alignTo.model);\n        }\n\n        (0, _util.each)(axisNeedsAlign, function (axis) {\n          (0, _axisAlignTicks.alignScaleTicks)(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n    var onZeroRecords = {};\n    (0, _util.each)(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    (0, _util.each)(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    }); // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n\n    this.resize(this.model, api);\n  };\n  /**\n   * Resize the grid\n   */\n\n\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n    var gridRect = (0, _layout.getLayoutRect)(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes(); // Minus label size\n\n    if (isContainLabel) {\n      (0, _util.each)(axesList, function (axis) {\n        if (!axis.model.get(['axisLabel', 'inside'])) {\n          var labelUnionRect = (0, _axisHelper.estimateLabelUnionRect)(axis);\n\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? 'height' : 'width';\n            var margin = axis.model.get(['axisLabel', 'margin']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n\n            if (axis.position === 'top') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === 'left') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n\n    (0, _util.each)(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n\n    function adjustAxes() {\n      (0, _util.each)(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n\n    if ((0, _util.isObject)(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', _model.SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', _model.SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      (0, _util.indexOf)(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    } // Lowest priority.\n    else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\n   * Initialize cartesian coordinate systems\n   */\n\n\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    }; /// Create axis\n\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n\n    this._axesMap = axesMap; /// Create cartesian2d\n\n    (0, _util.each)(axesMap.x, function (xAxis, xAxisIndex) {\n      (0, _util.each)(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new _Cartesian2D.default(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n\n        _this._coordsList.push(cartesian);\n\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n\n        var axisPosition = axisModel.get('position');\n\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n\n        axisPositionUsed[axisPosition] = true;\n        var axis = new _Axis2D.default(dimName, (0, _axisHelper.createScaleByModel)(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n        axisModel.axis = axis; // Inject axisModel into axis\n\n        axis.model = axisModel; // Inject grid info axis\n\n        axis.grid = grid; // Index of axis, can be used as key\n\n        axis.index = idx;\n\n        grid._axesList.push(axis);\n\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\n   * Update cartesian properties from series.\n   */\n\n\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    (0, _util.each)(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if ((0, _cartesianAxisHelper.isCartesian2DSeries)(seriesModel)) {\n        var axesModelMap = (0, _cartesianAxisHelper.findAxisModels)(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n\n    function unionExtent(data, axis) {\n      (0, _util.each)((0, _axisHelper.getDataDimensionsOnAxis)(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\n   */\n\n\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    (0, _util.each)(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      (0, _util.indexOf)(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      (0, _util.indexOf)(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    }); // Inject the coordinateSystems into seriesModel\n\n    ecModel.eachSeries(function (seriesModel) {\n      if (!(0, _cartesianAxisHelper.isCartesian2DSeries)(seriesModel)) {\n        return;\n      }\n\n      var axesModelMap = (0, _cartesianAxisHelper.findAxisModels)(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!gridModel) {\n          throw new Error('Grid \"' + (0, _util.retrieve3)(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n        }\n\n        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n          throw new Error('xAxis and yAxis must use the same grid');\n        }\n      }\n\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  }; // For deciding which dimensions to use when creating list data\n\n\n  Grid.dimensions = _Cartesian2D.cartesian2DDimensions;\n  return Grid;\n}();\n/**\n * Check if the axis is used in the specified grid.\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && (0, _axisHelper.ifAxisCrossZero)(axis);\n}\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar _default = Grid;\nexports.default = _default;","map":{"version":3,"names":["Grid","gridModel","ecModel","api","type","_coordsMap","_coordsList","_axesMap","_axesList","axisPointerEnabled","dimensions","cartesian2DDimensions","_initCartesian","model","prototype","getRect","_rect","update","axesMap","_updateScale","updateAxisTicks","axes","alignTo","axesIndices","keys","len","length","axisNeedsAlign","i","idx","axis","scale","isIntervalOrLogScale","get","push","niceScaleExtent","pop","each","alignScaleTicks","x","y","onZeroRecords","xAxis","fixAxisOnZero","yAxis","resize","ignoreContainLabel","boxLayoutParams","getBoxLayoutParams","isContainLabel","gridRect","getLayoutRect","width","getWidth","height","getHeight","axesList","adjustAxes","labelUnionRect","estimateLabelUnionRect","dim","isHorizontal","margin","position","coord","calcAffineTransform","extent","inverse","setExtent","updateAxisTransform","getAxis","axisIndex","axesMapOnDim","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","isObject","coordList","index","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","toGlobalCoord","dataToCoord","convertFromPixel","pointToData","coordToData","toLocalCoord","seriesModel","xAxisModel","getReferringComponents","SINGLE_REFERRING","models","yAxisModel","coordsList","coordinateSystem","indexOf","componentIndex","grid","containPoint","point","_this","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","Cartesian2D","master","addAxis","dimName","axisModel","isAxisUsedInTheGrid","axisPosition","Axis2D","createScaleByModel","isCategory","onBand","Infinity","categorySortInfo","setSortInfo","eachSeries","isCartesian2DSeries","axesModelMap","findAxisModels","data","getData","unionExtent","getDataDimensionsOnAxis","unionExtentFromData","getTooltipAxes","baseAxes","otherAxes","baseAxis","getBaseAxis","otherAxis","getOtherAxis","create","grids","name","getCoordSysModel","process","env","NODE_ENV","Error","retrieve3","otherAxisDim","getAxesOnZeroOf","otherAxisOnZeroOf","onZero","onZeroAxisIndex","canOnZeroToAxis","hasOwnProperty","getOnZeroRecordKey","ifAxisCrossZero","coordBase","axisExtent","getExtent","axisExtentSum"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/coord/cartesian/Grid.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nimport { isObject, each, indexOf, retrieve3, keys } from 'zrender/lib/core/util.js';\nimport { getLayoutRect } from '../../util/layout.js';\nimport { createScaleByModel, ifAxisCrossZero, niceScaleExtent, estimateLabelUnionRect, getDataDimensionsOnAxis } from '../../coord/axisHelper.js';\nimport Cartesian2D, { cartesian2DDimensions } from './Cartesian2D.js';\nimport Axis2D from './Axis2D.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { isCartesian2DSeries, findAxisModels } from './cartesianAxisHelper.js';\nimport { isIntervalOrLogScale } from '../../scale/helper.js';\nimport { alignScaleTicks } from '../axisAlignTicks.js';\n\nvar Grid =\n/** @class */\nfunction () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n\n    this._initCartesian(gridModel, ecModel, api);\n\n    this.model = gridModel;\n  }\n\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n\n    this._updateScale(ecModel, this.model);\n\n    function updateAxisTicks(axes) {\n      var alignTo; // Axis is added in order of axisIndex.\n\n      var axesIndices = keys(axes);\n      var len = axesIndices.length;\n\n      if (!len) {\n        return;\n      }\n\n      var axisNeedsAlign = []; // Process once and calculate the ticks for those don't use alignTicks.\n\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n\n        if ( // Only value and log axis without interval support alignTicks.\n        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          niceScaleExtent(scale, model);\n\n          if (isIntervalOrLogScale(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n\n      ; // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          niceScaleExtent(alignTo.scale, alignTo.model);\n        }\n\n        each(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n    var onZeroRecords = {};\n    each(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    each(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    }); // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n\n    this.resize(this.model, api);\n  };\n  /**\n   * Resize the grid\n   */\n\n\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n    var gridRect = getLayoutRect(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes(); // Minus label size\n\n    if (isContainLabel) {\n      each(axesList, function (axis) {\n        if (!axis.model.get(['axisLabel', 'inside'])) {\n          var labelUnionRect = estimateLabelUnionRect(axis);\n\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? 'height' : 'width';\n            var margin = axis.model.get(['axisLabel', 'margin']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n\n            if (axis.position === 'top') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === 'left') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n\n    each(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n\n    function adjustAxes() {\n      each(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n\n    if (isObject(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    } // Lowest priority.\n    else if (gridModel) {\n        var grid = gridModel.coordinateSystem;\n\n        if (grid === this) {\n          cartesian = this._coordsList[0];\n        }\n      }\n\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\n   * Initialize cartesian coordinate systems\n   */\n\n\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    }; /// Create axis\n\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n\n    this._axesMap = axesMap; /// Create cartesian2d\n\n    each(axesMap.x, function (xAxis, xAxisIndex) {\n      each(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n\n        _this._coordsList.push(cartesian);\n\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n\n        var axisPosition = axisModel.get('position');\n\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n\n        axisPositionUsed[axisPosition] = true;\n        var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n        axisModel.axis = axis; // Inject axisModel into axis\n\n        axis.model = axisModel; // Inject grid info axis\n\n        axis.grid = grid; // Index of axis, can be used as key\n\n        axis.index = idx;\n\n        grid._axesList.push(axis);\n\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\n   * Update cartesian properties from series.\n   */\n\n\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (isCartesian2DSeries(seriesModel)) {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n\n    function unionExtent(data, axis) {\n      each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\n   */\n\n\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    each(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    }); // Inject the coordinateSystems into seriesModel\n\n    ecModel.eachSeries(function (seriesModel) {\n      if (!isCartesian2DSeries(seriesModel)) {\n        return;\n      }\n\n      var axesModelMap = findAxisModels(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!gridModel) {\n          throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n        }\n\n        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n          throw new Error('xAxis and yAxis must use the same grid');\n        }\n      }\n\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  }; // For deciding which dimensions to use when creating list data\n\n\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\n * Check if the axis is used in the specified grid.\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nexport default Grid;"],"mappings":"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"},"metadata":{},"sourceType":"script"}