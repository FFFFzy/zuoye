{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar numberUtil = _interopRequireWildcard(require(\"../../util/number.js\"));\n\nvar _sliderMove = _interopRequireDefault(require(\"../helper/sliderMove.js\"));\n\nvar _axisHelper = require(\"../../coord/axisHelper.js\");\n\nvar _scaleRawExtentInfo = require(\"../../coord/scaleRawExtentInfo.js\");\n\nvar _helper = require(\"./helper.js\");\n\nvar _model = require(\"../../util/model.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n */\n\nvar AxisProxy =\n/** @class */\nfunction () {\n  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n    this._dimName = dimName;\n    this._axisIndex = axisIndex;\n    this.ecModel = ecModel;\n    this._dataZoomModel = dataZoomModel; // /**\n    //  * @readOnly\n    //  * @private\n    //  */\n    // this.hasSeriesStacked;\n  }\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   */\n\n\n  AxisProxy.prototype.hostedBy = function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  };\n  /**\n   * @return Value can only be NaN or finite value.\n   */\n\n\n  AxisProxy.prototype.getDataValueWindow = function () {\n    return this._valueWindow.slice();\n  };\n  /**\n   * @return {Array.<number>}\n   */\n\n\n  AxisProxy.prototype.getDataPercentWindow = function () {\n    return this._percentWindow.slice();\n  };\n\n  AxisProxy.prototype.getTargetSeriesModels = function () {\n    var seriesModels = [];\n    this.ecModel.eachSeries(function (seriesModel) {\n      if ((0, _helper.isCoordSupported)(seriesModel)) {\n        var axisMainType = (0, _helper.getAxisMainType)(this._dimName);\n        var axisModel = seriesModel.getReferringComponents(axisMainType, _model.SINGLE_REFERRING).models[0];\n\n        if (axisModel && this._axisIndex === axisModel.componentIndex) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  };\n\n  AxisProxy.prototype.getAxisModel = function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  };\n\n  AxisProxy.prototype.getMinMaxSpan = function () {\n    return zrUtil.clone(this._minMaxSpan);\n  };\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   */\n\n\n  AxisProxy.prototype.calculateDataWindow = function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      (0, _sliderMove.default)(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  };\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   */\n\n\n  AxisProxy.prototype.reset = function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // `calculateDataWindow` uses min/maxSpan.\n\n    this._updateMinMaxSpan();\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    this._setAxisModel();\n  };\n\n  AxisProxy.prototype.filterData = function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // let otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimensionsAll(axisDim);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        var store_1 = seriesData.getStore();\n        var dataDimIndices_1 = zrUtil.map(dataDims, function (dim) {\n          return seriesData.getDimensionIndex(dim);\n        }, seriesData);\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = store_1.get(dataDimIndices_1[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  };\n\n  AxisProxy.prototype._updateMinMaxSpan = function () {\n    var minMaxSpan = this._minMaxSpan = {};\n    var dataZoomModel = this._dataZoomModel;\n    var dataExtent = this._dataExtent;\n    each(['min', 'max'], function (minMax) {\n      var percentSpan = dataZoomModel.get(minMax + 'Span');\n      var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n      if (valueSpan != null) {\n        percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      } else if (percentSpan != null) {\n        valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n      }\n\n      minMaxSpan[minMax + 'Span'] = percentSpan;\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n    }, this);\n  };\n\n  AxisProxy.prototype._setAxisModel = function () {\n    var axisModel = this.getAxisModel();\n    var percentWindow = this._percentWindow;\n    var valueWindow = this._valueWindow;\n\n    if (!percentWindow) {\n      return;\n    } // [0, 500]: arbitrary value, guess axis extent.\n\n\n    var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n    precision = Math.min(precision, 20); // For value axis, if min/max/scale are not set, we just use the extent obtained\n    // by series data, which may be a little different from the extent calculated by\n    // `axisHelper.getScaleExtent`. But the different just affects the experience a\n    // little when zooming. So it will not be fixed until some users require it strongly.\n\n    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;\n\n    if (percentWindow[0] !== 0) {\n      rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));\n    }\n\n    if (percentWindow[1] !== 100) {\n      rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));\n    }\n\n    rawExtentInfo.freeze();\n  };\n\n  return AxisProxy;\n}();\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    (0, _axisHelper.unionAxisExtentFromData)(dataExtent, seriesModel.getData(), axisDim);\n  }); // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n  var axisModel = axisProxy.getAxisModel();\n  var rawExtentResult = (0, _scaleRawExtentInfo.ensureScaleRawExtentInfo)(axisModel.axis.scale, axisModel, dataExtent).calculate();\n  return [rawExtentResult.min, rawExtentResult.max];\n}\n\nvar _default = AxisProxy;\nexports.default = _default;","map":{"version":3,"names":["each","zrUtil","asc","numberUtil","AxisProxy","dimName","axisIndex","dataZoomModel","ecModel","_dimName","_axisIndex","_dataZoomModel","prototype","hostedBy","getDataValueWindow","_valueWindow","slice","getDataPercentWindow","_percentWindow","getTargetSeriesModels","seriesModels","eachSeries","seriesModel","isCoordSupported","axisMainType","getAxisMainType","axisModel","getReferringComponents","SINGLE_REFERRING","models","componentIndex","push","getAxisModel","getComponent","getMinMaxSpan","clone","_minMaxSpan","calculateDataWindow","opt","dataExtent","_dataExtent","scale","axis","rangePropMode","getRangePropMode","percentExtent","percentWindow","valueWindow","hasPropModeValue","prop","idx","boundPercent","boundValue","parse","linearMap","spans","restrictSet","fromWindow","toWindow","fromExtent","toExtent","toValue","suffix","sliderMove","i","reset","targetSeries","calculateDataExtent","_updateMinMaxSpan","dataWindow","settledOption","_setAxisModel","filterData","api","axisDim","filterMode","get","seriesData","getData","dataDims","mapDimensionsAll","length","store_1","getStore","dataDimIndices_1","map","dim","getDimensionIndex","filterSelf","dataIndex","leftOut","rightOut","hasValue","value","thisHasValue","isNaN","thisLeftOut","thisRightOut","setData","isInWindow","NaN","range","selectRange","setApproximateExtent","minMaxSpan","minMax","percentSpan","valueSpan","precision","getPixelPrecision","Math","min","rawExtentInfo","setDeterminedMinMax","toFixed","freeze","axisProxy","Infinity","unionAxisExtentFromData","rawExtentResult","ensureScaleRawExtentInfo","calculate","max"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/component/dataZoom/AxisProxy.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as numberUtil from '../../util/number.js';\nimport sliderMove from '../helper/sliderMove.js';\nimport { unionAxisExtentFromData } from '../../coord/axisHelper.js';\nimport { ensureScaleRawExtentInfo } from '../../coord/scaleRawExtentInfo.js';\nimport { getAxisMainType, isCoordSupported } from './helper.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n */\n\nvar AxisProxy =\n/** @class */\nfunction () {\n  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n    this._dimName = dimName;\n    this._axisIndex = axisIndex;\n    this.ecModel = ecModel;\n    this._dataZoomModel = dataZoomModel; // /**\n    //  * @readOnly\n    //  * @private\n    //  */\n    // this.hasSeriesStacked;\n  }\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   */\n\n\n  AxisProxy.prototype.hostedBy = function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  };\n  /**\n   * @return Value can only be NaN or finite value.\n   */\n\n\n  AxisProxy.prototype.getDataValueWindow = function () {\n    return this._valueWindow.slice();\n  };\n  /**\n   * @return {Array.<number>}\n   */\n\n\n  AxisProxy.prototype.getDataPercentWindow = function () {\n    return this._percentWindow.slice();\n  };\n\n  AxisProxy.prototype.getTargetSeriesModels = function () {\n    var seriesModels = [];\n    this.ecModel.eachSeries(function (seriesModel) {\n      if (isCoordSupported(seriesModel)) {\n        var axisMainType = getAxisMainType(this._dimName);\n        var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];\n\n        if (axisModel && this._axisIndex === axisModel.componentIndex) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  };\n\n  AxisProxy.prototype.getAxisModel = function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  };\n\n  AxisProxy.prototype.getMinMaxSpan = function () {\n    return zrUtil.clone(this._minMaxSpan);\n  };\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   */\n\n\n  AxisProxy.prototype.calculateDataWindow = function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  };\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   */\n\n\n  AxisProxy.prototype.reset = function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // `calculateDataWindow` uses min/maxSpan.\n\n    this._updateMinMaxSpan();\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    this._setAxisModel();\n  };\n\n  AxisProxy.prototype.filterData = function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // let otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimensionsAll(axisDim);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        var store_1 = seriesData.getStore();\n        var dataDimIndices_1 = zrUtil.map(dataDims, function (dim) {\n          return seriesData.getDimensionIndex(dim);\n        }, seriesData);\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = store_1.get(dataDimIndices_1[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  };\n\n  AxisProxy.prototype._updateMinMaxSpan = function () {\n    var minMaxSpan = this._minMaxSpan = {};\n    var dataZoomModel = this._dataZoomModel;\n    var dataExtent = this._dataExtent;\n    each(['min', 'max'], function (minMax) {\n      var percentSpan = dataZoomModel.get(minMax + 'Span');\n      var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n      if (valueSpan != null) {\n        percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      } else if (percentSpan != null) {\n        valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n      }\n\n      minMaxSpan[minMax + 'Span'] = percentSpan;\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n    }, this);\n  };\n\n  AxisProxy.prototype._setAxisModel = function () {\n    var axisModel = this.getAxisModel();\n    var percentWindow = this._percentWindow;\n    var valueWindow = this._valueWindow;\n\n    if (!percentWindow) {\n      return;\n    } // [0, 500]: arbitrary value, guess axis extent.\n\n\n    var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n    precision = Math.min(precision, 20); // For value axis, if min/max/scale are not set, we just use the extent obtained\n    // by series data, which may be a little different from the extent calculated by\n    // `axisHelper.getScaleExtent`. But the different just affects the experience a\n    // little when zooming. So it will not be fixed until some users require it strongly.\n\n    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;\n\n    if (percentWindow[0] !== 0) {\n      rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));\n    }\n\n    if (percentWindow[1] !== 100) {\n      rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));\n    }\n\n    rawExtentInfo.freeze();\n  };\n\n  return AxisProxy;\n}();\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);\n  }); // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n  var axisModel = axisProxy.getAxisModel();\n  var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();\n  return [rawExtentResult.min, rawExtentResult.max];\n}\n\nexport default AxisProxy;"],"mappings":"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"},"metadata":{},"sourceType":"script"}