{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyMorphAnimation = applyMorphAnimation;\nexports.getPathList = getPathList;\n\nvar _morphPath = require(\"zrender/lib/tool/morphPath.js\");\n\nvar _graphic = require(\"../util/graphic.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _basicTrasition = require(\"./basicTrasition.js\");\n\nvar _path = require(\"zrender/lib/tool/path.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction isMultiple(elements) {\n  return (0, _util.isArray)(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = (0, _path.clonePath)(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\n\nfunction applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = (0, _basicTrasition.getAnimationConfig)('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if ((0, _morphPath.isCombineMorphing)(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? (0, _util.defaults)({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        (0, _morphPath.morphPath)(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = (0, _util.defaults)({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? (0, _morphPath.combineMorph)(batchMany, batchOne, separateAnimationCfg) : (0, _morphPath.separateMorph)(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? (0, _util.defaults)({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\n\nfunction getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if ((0, _util.isArray)(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof _graphic.Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}","map":{"version":3,"names":["isMultiple","elements","isArray","prepareMorphBatches","one","many","batches","batchCount","length","i","push","len","k","off","moveFrom","mid","Math","ceil","slice","pathDividers","clone","params","ret","approxOpacity","pow","path","style","opacity","count","cloned","clonePath","setStyle","split","applyMorphAnimation","from","to","divideShape","seriesModel","dataIndex","animateOtherProps","updateAnimationCfg","getAnimationConfig","duration","animationDelay","getModel","get","animationCfg","Object","assign","setToFinal","morphOneBatch","batch","fromIsMany","animateIndex","animateCount","forceManyOne","batchMany","batchOne","batchFrom","batchTo","isCombineMorphing","individualAnimationCfg","defaults","delay","morphPath","separateAnimationCfg","dividePath","individualDelay","idx","fromPath","toPath","_a","combineMorph","separateMorph","fromIndividuals","toIndividuals","morphBatches","getPathList","pathList_1","pathList","traverse","el","Path","disableMorphing","invisible","ignore"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/animation/morphTransitionHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath.js';\nimport { Path } from '../util/graphic.js';\nimport { defaults, isArray } from 'zrender/lib/core/util.js';\nimport { getAnimationConfig } from './basicTrasition.js';\nimport { clonePath } from 'zrender/lib/tool/path.js';\n\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if (isArray(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}