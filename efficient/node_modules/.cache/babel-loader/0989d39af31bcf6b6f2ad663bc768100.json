{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceManager = void 0;\nexports.disableTransformOptionMerge = disableTransformOptionMerge;\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar _util = require(\"zrender/lib/core/util.js\");\n\nvar _Source = require(\"../Source.js\");\n\nvar _types = require(\"../../util/types.js\");\n\nvar _sourceHelper = require(\"./sourceHelper.js\");\n\nvar _transform = require(\"./transform.js\");\n\nvar _DataStore = _interopRequireDefault(require(\"../DataStore.js\"));\n\nvar _dataProvider = require(\"./dataProvider.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [REQUIREMENT_MEMO]:\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\n * `root-dataset`. Them on `series` has higher priority.\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\n * confuse users: whether those props indicate how to visit the upstream source or visit\n * the transform result source, and some transforms has nothing to do with these props,\n * and some transforms might have multiple upstream.\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\n * declared in `root-dataset`.\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\n * That is for reducing complexity in transfroms.\n * PENDING: Whether to provide transposition transform?\n *\n * [IMPLEMENTAION_MEMO]:\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\n * They will not be calculated until `source` is about to be visited (to prevent from\n * duplicate calcuation). `source` is visited only in series and input to transforms.\n *\n * [DIMENSION_INHERIT_RULE]:\n * By default the dimensions are inherited from ancestors, unless a transform return\n * a new dimensions definition.\n * Consider the case:\n * ```js\n * dataset: [{\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * dataset: [{\n *     dimension: ['Product', 'Sales', 'Prise'],\n *     source: [ ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * ```\n * The two types of option should have the same behavior after transform.\n *\n *\n * [SCENARIO]:\n * (1) Provide source data directly:\n * ```js\n * series: {\n *     encode: {...},\n *     dimensions: [...]\n *     seriesLayoutBy: 'row',\n *     data: [[...]]\n * }\n * ```\n * (2) Series refer to dataset.\n * ```js\n * series: [{\n *     encode: {...}\n *     // Ignore datasetIndex means `datasetIndex: 0`\n *     // and the dimensions defination in dataset is used\n * }, {\n *     encode: {...},\n *     seriesLayoutBy: 'column',\n *     datasetIndex: 1\n * }]\n * ```\n * (3) dataset transform\n * ```js\n * dataset: [{\n *     source: [...]\n * }, {\n *     source: [...]\n * }, {\n *     // By default from 0.\n *     transform: { type: 'filter', config: {...} }\n * }, {\n *     // Piped.\n *     transform: [\n *         { type: 'filter', config: {...} },\n *         { type: 'sort', config: {...} }\n *     ]\n * }, {\n *     id: 'regressionData',\n *     fromDatasetIndex: 1,\n *     // Third-party transform\n *     transform: { type: 'ecStat:regression', config: {...} }\n * }, {\n *     // retrieve the extra result.\n *     id: 'regressionFormula',\n *     fromDatasetId: 'regressionData',\n *     fromTransformResult: 1\n * }]\n * ```\n */\nvar SourceManager =\n/** @class */\nfunction () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = [];\n    this._storeList = []; // version sign of each upstream source manager.\n\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._dirty = true;\n    this._sourceHost = sourceHost;\n  }\n  /**\n   * Mark dirty.\n   */\n\n\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n\n    this._storeList = [];\n    this._dirty = true;\n  };\n\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\n   * For detecting whether the upstream source is dirty, so that\n   * the local cached source (in `_sourceList`) should be discarded.\n   */\n\n\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\n   * Always return a source instance. Otherwise throw error.\n   */\n\n\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n\n      this._dirty = false;\n    }\n  };\n\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n\n    var sourceHost = this._sourceHost;\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0; // Has upstream dataset\n\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      } // Series data is from own.\n      else {\n        data = seriesModel.get('data', true);\n        sourceFormat = (0, _util.isTypedArray)(data) ? _types.SOURCE_FORMAT_TYPED_ARRAY : _types.SOURCE_FORMAT_ORIGINAL;\n        upstreamSignList = [];\n      } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n\n\n      var newMetaRawOption = this._getSourceMetaRawOption() || {};\n      var upMetaRawOption = upSource && upSource.metaRawOption || {};\n      var seriesLayoutBy = (0, _util.retrieve2)(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;\n      var sourceHeader = (0, _util.retrieve2)(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader); // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n\n      var dimensions = (0, _util.retrieve2)(newMetaRawOption.dimensions, upMetaRawOption.dimensions); // We share source with dataset as much as possible\n      // to avoid extra memroy cost of high dimensional data.\n\n      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;\n      resultSourceList = needsCreateSource ? [(0, _Source.createSource)(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat)] : [];\n    } else {\n      var datasetModel = sourceHost; // Has upstream dataset.\n\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      } // Is root dataset.\n      else {\n        var sourceData = datasetModel.get('source', true);\n        resultSourceList = [(0, _Source.createSource)(sourceData, this._getSourceMetaRawOption(), null)];\n        upstreamSignList = [];\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(resultSourceList && upstreamSignList);\n    }\n\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(fromTransformResult != null || transformOption != null);\n    }\n\n    if (fromTransformResult != null) {\n      var errMsg = '';\n\n      if (upMgrList.length !== 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n        }\n\n        doThrow(errMsg);\n      }\n    }\n\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    (0, _util.each)(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n\n      if (fromTransformResult != null && !upSource) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n        }\n\n        doThrow(errMsg);\n      }\n\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n\n    if (transformOption) {\n      sourceList = (0, _transform.applyDataTransform)(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [(0, _Source.cloneSourceShallow)(upSourceList[0])];\n    }\n\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n\n  SourceManager.prototype._isDirty = function () {\n    if (this._dirty) {\n      return true;\n    } // All sourceList is from the some upsteam.\n\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n\n      if ( // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\n   * @param sourceIndex By defualt 0, means \"main source\".\n   *                    Most cases there is only one source.\n   */\n\n\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    sourceIndex = sourceIndex || 0;\n    var source = this._sourceList[sourceIndex];\n\n    if (!source) {\n      // Series may share source instance with dataset.\n      var upSourceMgrList = this._getUpstreamSourceManagers();\n\n      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);\n    }\n\n    return source;\n  };\n  /**\n   *\n   * Get a data store which can be shared across series.\n   * Only available for series.\n   *\n   * @param seriesDimRequest Dimensions that are generated in series.\n   *        Should have been sorted by `storeDimIndex` asc.\n   */\n\n\n  SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _util.assert)(isSeries(this._sourceHost), 'Can only call getDataStore on series source manager.');\n    }\n\n    var schema = seriesDimRequest.makeStoreSchema();\n    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);\n  };\n\n  SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {\n    // TODO Can use other sourceIndex?\n    var sourceIndex = 0;\n    var storeList = this._storeList;\n    var cachedStoreMap = storeList[sourceIndex];\n\n    if (!cachedStoreMap) {\n      cachedStoreMap = storeList[sourceIndex] = {};\n    }\n\n    var cachedStore = cachedStoreMap[sourceReadKey];\n\n    if (!cachedStore) {\n      var upSourceMgr = this._getUpstreamSourceManagers()[0];\n\n      if (isSeries(this._sourceHost) && upSourceMgr) {\n        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);\n      } else {\n        cachedStore = new _DataStore.default(); // Always create store from source of series.\n\n        cachedStore.initData(new _dataProvider.DefaultDataProvider(seriesSource, storeDims.length), storeDims);\n      }\n\n      cachedStoreMap[sourceReadKey] = cachedStore;\n    }\n\n    return cachedStore;\n  };\n  /**\n   * PEDING: Is it fast enough?\n   * If no upstream, return empty array.\n   */\n\n\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // no need to update them when change happen.\n    var sourceHost = this._sourceHost;\n\n    if (isSeries(sourceHost)) {\n      var datasetModel = (0, _sourceHelper.querySeriesUpstreamDatasetModel)(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return (0, _util.map)((0, _sourceHelper.queryDatasetUpstreamDatasetModels)(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n      var model = sourceHost;\n      seriesLayoutBy = model.get('seriesLayoutBy', true);\n      sourceHeader = model.get('sourceHeader', true);\n      dimensions = model.get('dimensions', true);\n    }\n\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n\n  return SourceManager;\n}();\n\nexports.SourceManager = SourceManager;\n\n// Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transfrom clone from rawOption.\nfunction disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && (0, _util.setAsPrimitive)(datasetModel.option.transform);\n}\n\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\n\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}","map":{"version":3,"names":["SourceManager","sourceHost","_sourceList","_storeList","_upstreamSignList","_versionSignBase","_dirty","_sourceHost","prototype","dirty","_setLocalSource","sourceList","upstreamSignList","_getVersionSign","uid","prepareSource","_isDirty","_createSource","upSourceMgrList","_getUpstreamSourceManagers","hasUpstream","length","resultSourceList","isSeries","seriesModel","data","sourceFormat","upSource","upSourceMgr","getSource","get","isTypedArray","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ORIGINAL","newMetaRawOption","_getSourceMetaRawOption","upMetaRawOption","metaRawOption","seriesLayoutBy","retrieve2","sourceHeader","dimensions","needsCreateSource","createSource","datasetModel","result","_applyTransform","sourceData","process","env","NODE_ENV","assert","upMgrList","transformOption","fromTransformResult","errMsg","doThrow","upSourceList","each","upMgr","push","applyDataTransform","datasetIndex","componentIndex","cloneSourceShallow","i","upSrcMgr","sourceIndex","source","getSharedDataStore","seriesDimRequest","schema","makeStoreSchema","_innerGetDataStore","hash","storeDims","seriesSource","sourceReadKey","storeList","cachedStoreMap","cachedStore","DataStore","initData","DefaultDataProvider","querySeriesUpstreamDatasetModel","getSourceManager","map","queryDatasetUpstreamDatasetModels","model","disableTransformOptionMerge","option","transform","setAsPrimitive","mainType","Error"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/data/helper/sourceManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { setAsPrimitive, map, isTypedArray, assert, each, retrieve2 } from 'zrender/lib/core/util.js';\nimport { createSource, cloneSourceShallow } from '../Source.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../../util/types.js';\nimport { querySeriesUpstreamDatasetModel, queryDatasetUpstreamDatasetModels } from './sourceHelper.js';\nimport { applyDataTransform } from './transform.js';\nimport DataStore from '../DataStore.js';\nimport { DefaultDataProvider } from './dataProvider.js';\n/**\n * [REQUIREMENT_MEMO]:\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\n * `root-dataset`. Them on `series` has higher priority.\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\n * confuse users: whether those props indicate how to visit the upstream source or visit\n * the transform result source, and some transforms has nothing to do with these props,\n * and some transforms might have multiple upstream.\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\n * declared in `root-dataset`.\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\n * That is for reducing complexity in transfroms.\n * PENDING: Whether to provide transposition transform?\n *\n * [IMPLEMENTAION_MEMO]:\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\n * They will not be calculated until `source` is about to be visited (to prevent from\n * duplicate calcuation). `source` is visited only in series and input to transforms.\n *\n * [DIMENSION_INHERIT_RULE]:\n * By default the dimensions are inherited from ancestors, unless a transform return\n * a new dimensions definition.\n * Consider the case:\n * ```js\n * dataset: [{\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * dataset: [{\n *     dimension: ['Product', 'Sales', 'Prise'],\n *     source: [ ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * ```\n * The two types of option should have the same behavior after transform.\n *\n *\n * [SCENARIO]:\n * (1) Provide source data directly:\n * ```js\n * series: {\n *     encode: {...},\n *     dimensions: [...]\n *     seriesLayoutBy: 'row',\n *     data: [[...]]\n * }\n * ```\n * (2) Series refer to dataset.\n * ```js\n * series: [{\n *     encode: {...}\n *     // Ignore datasetIndex means `datasetIndex: 0`\n *     // and the dimensions defination in dataset is used\n * }, {\n *     encode: {...},\n *     seriesLayoutBy: 'column',\n *     datasetIndex: 1\n * }]\n * ```\n * (3) dataset transform\n * ```js\n * dataset: [{\n *     source: [...]\n * }, {\n *     source: [...]\n * }, {\n *     // By default from 0.\n *     transform: { type: 'filter', config: {...} }\n * }, {\n *     // Piped.\n *     transform: [\n *         { type: 'filter', config: {...} },\n *         { type: 'sort', config: {...} }\n *     ]\n * }, {\n *     id: 'regressionData',\n *     fromDatasetIndex: 1,\n *     // Third-party transform\n *     transform: { type: 'ecStat:regression', config: {...} }\n * }, {\n *     // retrieve the extra result.\n *     id: 'regressionFormula',\n *     fromDatasetId: 'regressionData',\n *     fromTransformResult: 1\n * }]\n * ```\n */\n\nvar SourceManager =\n/** @class */\nfunction () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = [];\n    this._storeList = []; // version sign of each upstream source manager.\n\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._dirty = true;\n    this._sourceHost = sourceHost;\n  }\n  /**\n   * Mark dirty.\n   */\n\n\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n\n    this._storeList = [];\n    this._dirty = true;\n  };\n\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\n   * For detecting whether the upstream source is dirty, so that\n   * the local cached source (in `_sourceList`) should be discarded.\n   */\n\n\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\n   * Always return a source instance. Otherwise throw error.\n   */\n\n\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n\n      this._dirty = false;\n    }\n  };\n\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n\n    var sourceHost = this._sourceHost;\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0; // Has upstream dataset\n\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      } // Series data is from own.\n      else {\n          data = seriesModel.get('data', true);\n          sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n          upstreamSignList = [];\n        } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n\n\n      var newMetaRawOption = this._getSourceMetaRawOption() || {};\n      var upMetaRawOption = upSource && upSource.metaRawOption || {};\n      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;\n      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader); // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n\n      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions); // We share source with dataset as much as possible\n      // to avoid extra memroy cost of high dimensional data.\n\n      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;\n      resultSourceList = needsCreateSource ? [createSource(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat)] : [];\n    } else {\n      var datasetModel = sourceHost; // Has upstream dataset.\n\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      } // Is root dataset.\n      else {\n          var sourceData = datasetModel.get('source', true);\n          resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];\n          upstreamSignList = [];\n        }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(resultSourceList && upstreamSignList);\n    }\n\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(fromTransformResult != null || transformOption != null);\n    }\n\n    if (fromTransformResult != null) {\n      var errMsg = '';\n\n      if (upMgrList.length !== 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n        }\n\n        doThrow(errMsg);\n      }\n    }\n\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    each(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n\n      if (fromTransformResult != null && !upSource) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n        }\n\n        doThrow(errMsg);\n      }\n\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n\n    if (transformOption) {\n      sourceList = applyDataTransform(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [cloneSourceShallow(upSourceList[0])];\n    }\n\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n\n  SourceManager.prototype._isDirty = function () {\n    if (this._dirty) {\n      return true;\n    } // All sourceList is from the some upsteam.\n\n\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n\n      if ( // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\n   * @param sourceIndex By defualt 0, means \"main source\".\n   *                    Most cases there is only one source.\n   */\n\n\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    sourceIndex = sourceIndex || 0;\n    var source = this._sourceList[sourceIndex];\n\n    if (!source) {\n      // Series may share source instance with dataset.\n      var upSourceMgrList = this._getUpstreamSourceManagers();\n\n      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);\n    }\n\n    return source;\n  };\n  /**\n   *\n   * Get a data store which can be shared across series.\n   * Only available for series.\n   *\n   * @param seriesDimRequest Dimensions that are generated in series.\n   *        Should have been sorted by `storeDimIndex` asc.\n   */\n\n\n  SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isSeries(this._sourceHost), 'Can only call getDataStore on series source manager.');\n    }\n\n    var schema = seriesDimRequest.makeStoreSchema();\n    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);\n  };\n\n  SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {\n    // TODO Can use other sourceIndex?\n    var sourceIndex = 0;\n    var storeList = this._storeList;\n    var cachedStoreMap = storeList[sourceIndex];\n\n    if (!cachedStoreMap) {\n      cachedStoreMap = storeList[sourceIndex] = {};\n    }\n\n    var cachedStore = cachedStoreMap[sourceReadKey];\n\n    if (!cachedStore) {\n      var upSourceMgr = this._getUpstreamSourceManagers()[0];\n\n      if (isSeries(this._sourceHost) && upSourceMgr) {\n        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);\n      } else {\n        cachedStore = new DataStore(); // Always create store from source of series.\n\n        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);\n      }\n\n      cachedStoreMap[sourceReadKey] = cachedStore;\n    }\n\n    return cachedStore;\n  };\n  /**\n   * PEDING: Is it fast enough?\n   * If no upstream, return empty array.\n   */\n\n\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // no need to update them when change happen.\n    var sourceHost = this._sourceHost;\n\n    if (isSeries(sourceHost)) {\n      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n        var model = sourceHost;\n        seriesLayoutBy = model.get('seriesLayoutBy', true);\n        sourceHeader = model.get('sourceHeader', true);\n        dimensions = model.get('dimensions', true);\n      }\n\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n\n  return SourceManager;\n}();\n\nexport { SourceManager }; // Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transfrom clone from rawOption.\n\nexport function disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && setAsPrimitive(datasetModel.option.transform);\n}\n\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\n\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}"],"mappings":";;;;;;;;;;;;AA2CA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAhDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,aAAa;AACjB;AACA,YAAY;EACV,SAASA,aAAT,CAAuBC,UAAvB,EAAmC;IACjC;IACA,KAAKC,WAAL,GAAmB,EAAnB;IACA,KAAKC,UAAL,GAAkB,EAAlB,CAHiC,CAGX;;IAEtB,KAAKC,iBAAL,GAAyB,EAAzB;IACA,KAAKC,gBAAL,GAAwB,CAAxB;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAKC,WAAL,GAAmBN,UAAnB;EACD;EACD;AACF;AACA;;;EAGED,aAAa,CAACQ,SAAd,CAAwBC,KAAxB,GAAgC,YAAY;IAC1C,KAAKC,eAAL,CAAqB,EAArB,EAAyB,EAAzB;;IAEA,KAAKP,UAAL,GAAkB,EAAlB;IACA,KAAKG,MAAL,GAAc,IAAd;EACD,CALD;;EAOAN,aAAa,CAACQ,SAAd,CAAwBE,eAAxB,GAA0C,UAAUC,UAAV,EAAsBC,gBAAtB,EAAwC;IAChF,KAAKV,WAAL,GAAmBS,UAAnB;IACA,KAAKP,iBAAL,GAAyBQ,gBAAzB;IACA,KAAKP,gBAAL;;IAEA,IAAI,KAAKA,gBAAL,GAAwB,IAA5B,EAAkC;MAChC,KAAKA,gBAAL,GAAwB,CAAxB;IACD;EACF,CARD;EASA;AACF;AACA;AACA;;;EAGEL,aAAa,CAACQ,SAAd,CAAwBK,eAAxB,GAA0C,YAAY;IACpD,OAAO,KAAKN,WAAL,CAAiBO,GAAjB,GAAuB,GAAvB,GAA6B,KAAKT,gBAAzC;EACD,CAFD;EAGA;AACF;AACA;;;EAGEL,aAAa,CAACQ,SAAd,CAAwBO,aAAxB,GAAwC,YAAY;IAClD;IACA;IACA,IAAI,KAAKC,QAAL,EAAJ,EAAqB;MACnB,KAAKC,aAAL;;MAEA,KAAKX,MAAL,GAAc,KAAd;IACD;EACF,CARD;;EAUAN,aAAa,CAACQ,SAAd,CAAwBS,aAAxB,GAAwC,YAAY;IAClD,KAAKP,eAAL,CAAqB,EAArB,EAAyB,EAAzB;;IAEA,IAAIT,UAAU,GAAG,KAAKM,WAAtB;;IAEA,IAAIW,eAAe,GAAG,KAAKC,0BAAL,EAAtB;;IAEA,IAAIC,WAAW,GAAG,CAAC,CAACF,eAAe,CAACG,MAApC;IACA,IAAIC,gBAAJ;IACA,IAAIV,gBAAJ;;IAEA,IAAIW,QAAQ,CAACtB,UAAD,CAAZ,EAA0B;MACxB,IAAIuB,WAAW,GAAGvB,UAAlB;MACA,IAAIwB,IAAI,GAAG,KAAK,CAAhB;MACA,IAAIC,YAAY,GAAG,KAAK,CAAxB;MACA,IAAIC,QAAQ,GAAG,KAAK,CAApB,CAJwB,CAID;;MAEvB,IAAIP,WAAJ,EAAiB;QACf,IAAIQ,WAAW,GAAGV,eAAe,CAAC,CAAD,CAAjC;QACAU,WAAW,CAACb,aAAZ;QACAY,QAAQ,GAAGC,WAAW,CAACC,SAAZ,EAAX;QACAJ,IAAI,GAAGE,QAAQ,CAACF,IAAhB;QACAC,YAAY,GAAGC,QAAQ,CAACD,YAAxB;QACAd,gBAAgB,GAAG,CAACgB,WAAW,CAACf,eAAZ,EAAD,CAAnB;MACD,CAPD,CAOE;MAPF,KAQK;QACDY,IAAI,GAAGD,WAAW,CAACM,GAAZ,CAAgB,MAAhB,EAAwB,IAAxB,CAAP;QACAJ,YAAY,GAAG,IAAAK,kBAAA,EAAaN,IAAb,IAAqBO,gCAArB,GAAiDC,6BAAhE;QACArB,gBAAgB,GAAG,EAAnB;MACD,CAlBqB,CAkBpB;;;MAGJ,IAAIsB,gBAAgB,GAAG,KAAKC,uBAAL,MAAkC,EAAzD;MACA,IAAIC,eAAe,GAAGT,QAAQ,IAAIA,QAAQ,CAACU,aAArB,IAAsC,EAA5D;MACA,IAAIC,cAAc,GAAG,IAAAC,eAAA,EAAUL,gBAAgB,CAACI,cAA3B,EAA2CF,eAAe,CAACE,cAA3D,KAA8E,IAAnG;MACA,IAAIE,YAAY,GAAG,IAAAD,eAAA,EAAUL,gBAAgB,CAACM,YAA3B,EAAyCJ,eAAe,CAACI,YAAzD,CAAnB,CAxBwB,CAwBmE;MAC3F;MACA;;MAEA,IAAIC,UAAU,GAAG,IAAAF,eAAA,EAAUL,gBAAgB,CAACO,UAA3B,EAAuCL,eAAe,CAACK,UAAvD,CAAjB,CA5BwB,CA4B6D;MACrF;;MAEA,IAAIC,iBAAiB,GAAGJ,cAAc,KAAKF,eAAe,CAACE,cAAnC,IAAqD,CAAC,CAACE,YAAF,KAAmB,CAAC,CAACJ,eAAe,CAACI,YAA1F,IAA0GC,UAAlI;MACAnB,gBAAgB,GAAGoB,iBAAiB,GAAG,CAAC,IAAAC,oBAAA,EAAalB,IAAb,EAAmB;QACzDa,cAAc,EAAEA,cADyC;QAEzDE,YAAY,EAAEA,YAF2C;QAGzDC,UAAU,EAAEA;MAH6C,CAAnB,EAIrCf,YAJqC,CAAD,CAAH,GAIhB,EAJpB;IAKD,CArCD,MAqCO;MACL,IAAIkB,YAAY,GAAG3C,UAAnB,CADK,CAC0B;;MAE/B,IAAImB,WAAJ,EAAiB;QACf,IAAIyB,MAAM,GAAG,KAAKC,eAAL,CAAqB5B,eAArB,CAAb;;QAEAI,gBAAgB,GAAGuB,MAAM,CAAClC,UAA1B;QACAC,gBAAgB,GAAGiC,MAAM,CAACjC,gBAA1B;MACD,CALD,CAKE;MALF,KAMK;QACD,IAAImC,UAAU,GAAGH,YAAY,CAACd,GAAb,CAAiB,QAAjB,EAA2B,IAA3B,CAAjB;QACAR,gBAAgB,GAAG,CAAC,IAAAqB,oBAAA,EAAaI,UAAb,EAAyB,KAAKZ,uBAAL,EAAzB,EAAyD,IAAzD,CAAD,CAAnB;QACAvB,gBAAgB,GAAG,EAAnB;MACD;IACJ;;IAED,IAAIoC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC,IAAAC,YAAA,EAAO7B,gBAAgB,IAAIV,gBAA3B;IACD;;IAED,KAAKF,eAAL,CAAqBY,gBAArB,EAAuCV,gBAAvC;EACD,CArED;;EAuEAZ,aAAa,CAACQ,SAAd,CAAwBsC,eAAxB,GAA0C,UAAUM,SAAV,EAAqB;IAC7D,IAAIR,YAAY,GAAG,KAAKrC,WAAxB;IACA,IAAI8C,eAAe,GAAGT,YAAY,CAACd,GAAb,CAAiB,WAAjB,EAA8B,IAA9B,CAAtB;IACA,IAAIwB,mBAAmB,GAAGV,YAAY,CAACd,GAAb,CAAiB,qBAAjB,EAAwC,IAAxC,CAA1B;;IAEA,IAAIkB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC,IAAAC,YAAA,EAAOG,mBAAmB,IAAI,IAAvB,IAA+BD,eAAe,IAAI,IAAzD;IACD;;IAED,IAAIC,mBAAmB,IAAI,IAA3B,EAAiC;MAC/B,IAAIC,MAAM,GAAG,EAAb;;MAEA,IAAIH,SAAS,CAAC/B,MAAV,KAAqB,CAAzB,EAA4B;QAC1B,IAAI2B,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzCK,MAAM,GAAG,6EAAT;QACD;;QAEDC,OAAO,CAACD,MAAD,CAAP;MACD;IACF;;IAED,IAAI5C,UAAJ;IACA,IAAI8C,YAAY,GAAG,EAAnB;IACA,IAAI7C,gBAAgB,GAAG,EAAvB;IACA,IAAA8C,UAAA,EAAKN,SAAL,EAAgB,UAAUO,KAAV,EAAiB;MAC/BA,KAAK,CAAC5C,aAAN;MACA,IAAIY,QAAQ,GAAGgC,KAAK,CAAC9B,SAAN,CAAgByB,mBAAmB,IAAI,CAAvC,CAAf;MACA,IAAIC,MAAM,GAAG,EAAb;;MAEA,IAAID,mBAAmB,IAAI,IAAvB,IAA+B,CAAC3B,QAApC,EAA8C;QAC5C,IAAIqB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzCK,MAAM,GAAG,uDAAuDD,mBAAhE;QACD;;QAEDE,OAAO,CAACD,MAAD,CAAP;MACD;;MAEDE,YAAY,CAACG,IAAb,CAAkBjC,QAAlB;MACAf,gBAAgB,CAACgD,IAAjB,CAAsBD,KAAK,CAAC9C,eAAN,EAAtB;IACD,CAfD;;IAiBA,IAAIwC,eAAJ,EAAqB;MACnB1C,UAAU,GAAG,IAAAkD,6BAAA,EAAmBR,eAAnB,EAAoCI,YAApC,EAAkD;QAC7DK,YAAY,EAAElB,YAAY,CAACmB;MADkC,CAAlD,CAAb;IAGD,CAJD,MAIO,IAAIT,mBAAmB,IAAI,IAA3B,EAAiC;MACtC3C,UAAU,GAAG,CAAC,IAAAqD,0BAAA,EAAmBP,YAAY,CAAC,CAAD,CAA/B,CAAD,CAAb;IACD;;IAED,OAAO;MACL9C,UAAU,EAAEA,UADP;MAELC,gBAAgB,EAAEA;IAFb,CAAP;EAID,CArDD;;EAuDAZ,aAAa,CAACQ,SAAd,CAAwBQ,QAAxB,GAAmC,YAAY;IAC7C,IAAI,KAAKV,MAAT,EAAiB;MACf,OAAO,IAAP;IACD,CAH4C,CAG3C;;;IAGF,IAAIY,eAAe,GAAG,KAAKC,0BAAL,EAAtB;;IAEA,KAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/C,eAAe,CAACG,MAApC,EAA4C4C,CAAC,EAA7C,EAAiD;MAC/C,IAAIC,QAAQ,GAAGhD,eAAe,CAAC+C,CAAD,CAA9B;;MAEA,KAAK;MACL;MACAC,QAAQ,CAAClD,QAAT,MAAuB,KAAKZ,iBAAL,CAAuB6D,CAAvB,MAA8BC,QAAQ,CAACrD,eAAT,EAFrD,EAEiF;QAC/E,OAAO,IAAP;MACD;IACF;EACF,CAjBD;EAkBA;AACF;AACA;AACA;;;EAGEb,aAAa,CAACQ,SAAd,CAAwBqB,SAAxB,GAAoC,UAAUsC,WAAV,EAAuB;IACzDA,WAAW,GAAGA,WAAW,IAAI,CAA7B;IACA,IAAIC,MAAM,GAAG,KAAKlE,WAAL,CAAiBiE,WAAjB,CAAb;;IAEA,IAAI,CAACC,MAAL,EAAa;MACX;MACA,IAAIlD,eAAe,GAAG,KAAKC,0BAAL,EAAtB;;MAEA,OAAOD,eAAe,CAAC,CAAD,CAAf,IAAsBA,eAAe,CAAC,CAAD,CAAf,CAAmBW,SAAnB,CAA6BsC,WAA7B,CAA7B;IACD;;IAED,OAAOC,MAAP;EACD,CAZD;EAaA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEpE,aAAa,CAACQ,SAAd,CAAwB6D,kBAAxB,GAA6C,UAAUC,gBAAV,EAA4B;IACvE,IAAItB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC,IAAAC,YAAA,EAAO5B,QAAQ,CAAC,KAAKhB,WAAN,CAAf,EAAmC,sDAAnC;IACD;;IAED,IAAIgE,MAAM,GAAGD,gBAAgB,CAACE,eAAjB,EAAb;IACA,OAAO,KAAKC,kBAAL,CAAwBF,MAAM,CAAC9B,UAA/B,EAA2C6B,gBAAgB,CAACF,MAA5D,EAAoEG,MAAM,CAACG,IAA3E,CAAP;EACD,CAPD;;EASA1E,aAAa,CAACQ,SAAd,CAAwBiE,kBAAxB,GAA6C,UAAUE,SAAV,EAAqBC,YAArB,EAAmCC,aAAnC,EAAkD;IAC7F;IACA,IAAIV,WAAW,GAAG,CAAlB;IACA,IAAIW,SAAS,GAAG,KAAK3E,UAArB;IACA,IAAI4E,cAAc,GAAGD,SAAS,CAACX,WAAD,CAA9B;;IAEA,IAAI,CAACY,cAAL,EAAqB;MACnBA,cAAc,GAAGD,SAAS,CAACX,WAAD,CAAT,GAAyB,EAA1C;IACD;;IAED,IAAIa,WAAW,GAAGD,cAAc,CAACF,aAAD,CAAhC;;IAEA,IAAI,CAACG,WAAL,EAAkB;MAChB,IAAIpD,WAAW,GAAG,KAAKT,0BAAL,GAAkC,CAAlC,CAAlB;;MAEA,IAAII,QAAQ,CAAC,KAAKhB,WAAN,CAAR,IAA8BqB,WAAlC,EAA+C;QAC7CoD,WAAW,GAAGpD,WAAW,CAAC6C,kBAAZ,CAA+BE,SAA/B,EAA0CC,YAA1C,EAAwDC,aAAxD,CAAd;MACD,CAFD,MAEO;QACLG,WAAW,GAAG,IAAIC,kBAAJ,EAAd,CADK,CAC0B;;QAE/BD,WAAW,CAACE,QAAZ,CAAqB,IAAIC,iCAAJ,CAAwBP,YAAxB,EAAsCD,SAAS,CAACtD,MAAhD,CAArB,EAA8EsD,SAA9E;MACD;;MAEDI,cAAc,CAACF,aAAD,CAAd,GAAgCG,WAAhC;IACD;;IAED,OAAOA,WAAP;EACD,CA3BD;EA4BA;AACF;AACA;AACA;;;EAGEhF,aAAa,CAACQ,SAAd,CAAwBW,0BAAxB,GAAqD,YAAY;IAC/D;IACA;IACA;IACA,IAAIlB,UAAU,GAAG,KAAKM,WAAtB;;IAEA,IAAIgB,QAAQ,CAACtB,UAAD,CAAZ,EAA0B;MACxB,IAAI2C,YAAY,GAAG,IAAAwC,6CAAA,EAAgCnF,UAAhC,CAAnB;MACA,OAAO,CAAC2C,YAAD,GAAgB,EAAhB,GAAqB,CAACA,YAAY,CAACyC,gBAAb,EAAD,CAA5B;IACD,CAHD,MAGO;MACL,OAAO,IAAAC,SAAA,EAAI,IAAAC,+CAAA,EAAkCtF,UAAlC,CAAJ,EAAmD,UAAU2C,YAAV,EAAwB;QAChF,OAAOA,YAAY,CAACyC,gBAAb,EAAP;MACD,CAFM,CAAP;IAGD;EACF,CAdD;;EAgBArF,aAAa,CAACQ,SAAd,CAAwB2B,uBAAxB,GAAkD,YAAY;IAC5D,IAAIlC,UAAU,GAAG,KAAKM,WAAtB;IACA,IAAI+B,cAAJ;IACA,IAAIE,YAAJ;IACA,IAAIC,UAAJ;;IAEA,IAAIlB,QAAQ,CAACtB,UAAD,CAAZ,EAA0B;MACxBqC,cAAc,GAAGrC,UAAU,CAAC6B,GAAX,CAAe,gBAAf,EAAiC,IAAjC,CAAjB;MACAU,YAAY,GAAGvC,UAAU,CAAC6B,GAAX,CAAe,cAAf,EAA+B,IAA/B,CAAf;MACAW,UAAU,GAAGxC,UAAU,CAAC6B,GAAX,CAAe,YAAf,EAA6B,IAA7B,CAAb;IACD,CAJD,CAIE;IAJF,KAKK,IAAI,CAAC,KAAKX,0BAAL,GAAkCE,MAAvC,EAA+C;MAChD,IAAImE,KAAK,GAAGvF,UAAZ;MACAqC,cAAc,GAAGkD,KAAK,CAAC1D,GAAN,CAAU,gBAAV,EAA4B,IAA5B,CAAjB;MACAU,YAAY,GAAGgD,KAAK,CAAC1D,GAAN,CAAU,cAAV,EAA0B,IAA1B,CAAf;MACAW,UAAU,GAAG+C,KAAK,CAAC1D,GAAN,CAAU,YAAV,EAAwB,IAAxB,CAAb;IACD;;IAEH,OAAO;MACLQ,cAAc,EAAEA,cADX;MAELE,YAAY,EAAEA,YAFT;MAGLC,UAAU,EAAEA;IAHP,CAAP;EAKD,CAvBD;;EAyBA,OAAOzC,aAAP;AACD,CA1TD,EAFA;;;;AA8T0B;AAC1B;AAEO,SAASyF,2BAAT,CAAqC7C,YAArC,EAAmD;EACxD,IAAIS,eAAe,GAAGT,YAAY,CAAC8C,MAAb,CAAoBC,SAA1C;EACAtC,eAAe,IAAI,IAAAuC,oBAAA,EAAehD,YAAY,CAAC8C,MAAb,CAAoBC,SAAnC,CAAnB;AACD;;AAED,SAASpE,QAAT,CAAkBtB,UAAlB,EAA8B;EAC5B;EACA,OAAOA,UAAU,CAAC4F,QAAX,KAAwB,QAA/B;AACD;;AAED,SAASrC,OAAT,CAAiBD,MAAjB,EAAyB;EACvB,MAAM,IAAIuC,KAAJ,CAAUvC,MAAV,CAAN;AACD"},"metadata":{},"sourceType":"script"}