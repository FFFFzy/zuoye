{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.box = exports.LOCATION_PARAMS = exports.HV_NAMES = void 0;\nexports.copyLayoutParams = copyLayoutParams;\nexports.fetchLayoutMode = fetchLayoutMode;\nexports.getAvailableSize = getAvailableSize;\nexports.getLayoutParams = getLayoutParams;\nexports.getLayoutRect = getLayoutRect;\nexports.hbox = void 0;\nexports.mergeLayoutParam = mergeLayoutParam;\nexports.positionElement = positionElement;\nexports.sizeCalculable = sizeCalculable;\nexports.vbox = void 0;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar _BoundingRect = _interopRequireDefault(require(\"zrender/lib/core/BoundingRect.js\"));\n\nvar _number = require(\"./number.js\");\n\nvar formatUtil = _interopRequireWildcard(require(\"./format.js\"));\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nexports.LOCATION_PARAMS = LOCATION_PARAMS;\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\nexports.HV_NAMES = HV_NAMES;\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    child.x = x;\n    child.y = y;\n    child.markRedraw();\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nvar box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nexports.box = box;\nvar vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nexports.vbox = vbox;\nvar hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n */\n\nexports.hbox = hbox;\n\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = (0, _number.parsePercent)(positionInfo.left, containerWidth);\n  var y = (0, _number.parsePercent)(positionInfo.top, containerHeight);\n  var x2 = (0, _number.parsePercent)(positionInfo.right, containerWidth);\n  var y2 = (0, _number.parsePercent)(positionInfo.bottom, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n */\n\n\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = (0, _number.parsePercent)(positionInfo.left, containerWidth);\n  var top = (0, _number.parsePercent)(positionInfo.top, containerHeight);\n  var right = (0, _number.parsePercent)(positionInfo.right, containerWidth);\n  var bottom = (0, _number.parsePercent)(positionInfo.bottom, containerHeight);\n  var width = (0, _number.parsePercent)(positionInfo.width, containerWidth);\n  var height = (0, _number.parsePercent)(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new _BoundingRect.default(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * Return true if the layout happend.\n *\n * @param el Should have `getBoundingRect` method.\n * @param positionInfo\n * @param positionInfo.left\n * @param positionInfo.top\n * @param positionInfo.right\n * @param positionInfo.bottom\n * @param positionInfo.width Only for opt.boundingModel: 'raw'\n * @param positionInfo.height Only for opt.boundingModel: 'raw'\n * @param containerRect\n * @param margin\n * @param opt\n * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]\n * @param opt.boundingMode\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\n\nfunction positionElement(el, positionInfo, containerRect, margin, opt, out) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  out = out || el;\n  out.x = el.x;\n  out.y = el.y;\n\n  if (!h && !v) {\n    return false;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new _BoundingRect.default(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  var layoutRect = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n\n  var dx = h ? layoutRect.x - rect.x : 0;\n  var dy = v ? layoutRect.y - rect.y : 0;\n\n  if (boundingMode === 'raw') {\n    out.x = dx;\n    out.y = dy;\n  } else {\n    out.x += dx;\n    out.y += dy;\n  }\n\n  if (out === el) {\n    el.markRedraw();\n  }\n\n  return true;\n}\n/**\n * @param option Contains some of the properties in HV_NAMES.\n * @param hvIdx 0: horizontal; 1: vertical.\n */\n\n\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\n\nfunction fetchLayoutMode(ins) {\n  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n  return zrUtil.isObject(layoutMode) ? layoutMode : layoutMode ? {\n    type: layoutMode\n  } : null;\n}\n/**\n * Consider Case:\n * When default option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         let inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param targetOption\n * @param newOption\n * @param opt\n */\n\n\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  var ignoreSize = opt && opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n      return newParams;\n    } else {\n      // Chose another param from targetOption by priority.\n      for (var i = 0; i < names.length; i++) {\n        var name_1 = names[i];\n\n        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {\n          newParams[name_1] = targetOption[name_1];\n          break;\n        }\n      }\n\n      return newParams;\n    }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n */\n\n\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}","map":{"version":3,"names":["each","zrUtil","LOCATION_PARAMS","HV_NAMES","boxLayout","orient","group","gap","maxWidth","maxHeight","x","y","Infinity","currentLineMaxSize","eachChild","child","idx","rect","getBoundingRect","nextChild","childAt","nextChildRect","nextX","nextY","moveX","width","newline","height","Math","max","moveY","markRedraw","box","vbox","curry","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","parsePercent","left","top","x2","right","y2","bottom","isNaN","parseFloat","formatUtil","normalizeCssArray","getLayoutRect","verticalMargin","horizontalMargin","aspect","BoundingRect","positionElement","el","opt","out","h","hv","v","boundingMode","type","needLocalTransform","transform","getLocalTransform","clone","applyTransform","layoutRect","defaults","dx","dy","sizeCalculable","option","hvIdx","fetchLayoutMode","ins","layoutMode","constructor","isObject","mergeLayoutParam","targetOption","newOption","ignoreSize","isArray","hResult","merge","vResult","copy","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","name","hasProp","hasValue","i","length","name_1","obj","hasOwnProperty","target","source","getLayoutParams","copyLayoutParams"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/util/layout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Layout helpers for each component positioning\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport { parsePercent } from './number.js';\nimport * as formatUtil from './format.js';\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nexport var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nexport var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    child.x = x;\n    child.y = y;\n    child.markRedraw();\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nexport var box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nexport var vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/graphic/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nexport var hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n */\n\nexport function getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.left, containerWidth);\n  var y = parsePercent(positionInfo.top, containerHeight);\n  var x2 = parsePercent(positionInfo.right, containerWidth);\n  var y2 = parsePercent(positionInfo.bottom, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n */\n\nexport function getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * Return true if the layout happend.\n *\n * @param el Should have `getBoundingRect` method.\n * @param positionInfo\n * @param positionInfo.left\n * @param positionInfo.top\n * @param positionInfo.right\n * @param positionInfo.bottom\n * @param positionInfo.width Only for opt.boundingModel: 'raw'\n * @param positionInfo.height Only for opt.boundingModel: 'raw'\n * @param containerRect\n * @param margin\n * @param opt\n * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]\n * @param opt.boundingMode\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\nexport function positionElement(el, positionInfo, containerRect, margin, opt, out) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  out = out || el;\n  out.x = el.x;\n  out.y = el.y;\n\n  if (!h && !v) {\n    return false;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  var layoutRect = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n\n  var dx = h ? layoutRect.x - rect.x : 0;\n  var dy = v ? layoutRect.y - rect.y : 0;\n\n  if (boundingMode === 'raw') {\n    out.x = dx;\n    out.y = dy;\n  } else {\n    out.x += dx;\n    out.y += dy;\n  }\n\n  if (out === el) {\n    el.markRedraw();\n  }\n\n  return true;\n}\n/**\n * @param option Contains some of the properties in HV_NAMES.\n * @param hvIdx 0: horizontal; 1: vertical.\n */\n\nexport function sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\nexport function fetchLayoutMode(ins) {\n  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n  return zrUtil.isObject(layoutMode) ? layoutMode : layoutMode ? {\n    type: layoutMode\n  } : null;\n}\n/**\n * Consider Case:\n * When default option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         let inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param targetOption\n * @param newOption\n * @param opt\n */\n\nexport function mergeLayoutParam(targetOption, newOption, opt) {\n  var ignoreSize = opt && opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n        return newParams;\n      } else {\n        // Chose another param from targetOption by priority.\n        for (var i = 0; i < names.length; i++) {\n          var name_1 = names[i];\n\n          if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {\n            newParams[name_1] = targetOption[name_1];\n            break;\n          }\n        }\n\n        return newParams;\n      }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n */\n\nexport function getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\nexport function copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}