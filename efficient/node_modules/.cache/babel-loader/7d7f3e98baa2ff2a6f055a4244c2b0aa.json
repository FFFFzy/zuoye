{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"C:/Users/Z/Desktop/efficient/efficient/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar zrUtil = _interopRequireWildcard(require(\"zrender/lib/core/util.js\"));\n\nvar _number = require(\"../util/number.js\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(polar, axis) {\n  return axis.dim + polar.model.componentIndex;\n}\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var cx = seriesModel.coordinateSystem.cx;\n    var cy = seriesModel.coordinateSystem.cy;\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = (0, _dataStackHelper.isDimensionStacked)(data, valueDim\n    /*, baseDim*/\n    );\n    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n    var valueAxisStart = valueAxis.dataToCoord(0);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var r0 = void 0;\n      var r = void 0;\n      var startAngle = void 0;\n      var endAngle = void 0; // radial sector\n\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n        var angle = baseAxis.dataToCoord(baseValue);\n\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      } // tangential sector\n      else {\n        var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n        var radius = baseAxis.dataToCoord(baseValue);\n\n        if (Math.abs(angleSpan) < barMinAngle) {\n          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n        }\n\n        r0 = radius + columnOffset;\n        r = r0 + columnWidth;\n        startAngle = baseCoord;\n        endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,\n        // add a round to differentiate it from origin\n        // let extent = angleAxis.getExtent();\n        // let stackCoord = angle;\n        // if (stackCoord === extent[0] && value > 0) {\n        //     stackCoord = extent[1];\n        // }\n        // else if (stackCoord === extent[1] && value < 0) {\n        //     stackCoord = extent[0];\n        // }\n\n        stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n      }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180,\n\n        /**\n         * Keep the same logic with bar in catesion: use end value to\n         * control direction. Notice that if clockwise is true (by\n         * default), the sector will always draw clockwisely, no matter\n         * whether endAngle is greater or less than startAngle.\n         */\n        clockwise: startAngle >= endAngle\n      });\n    }\n  });\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = (0, _number.parsePercent)(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = (0, _number.parsePercent)(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = (0, _number.parsePercent)(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = (0, _number.parsePercent)(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nvar _default = barLayoutPolar;\nexports.default = _default;","map":{"version":3,"names":["getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","polar","axis","dim","model","componentIndex","barLayoutPolar","seriesType","ecModel","api","lastStackCoords","barWidthAndOffset","calRadialBar","zrUtil","filter","getSeriesByType","isSeriesFiltered","coordinateSystem","type","eachSeriesByType","data","getData","baseAxis","getBaseAxis","axisKey","stackId","columnLayoutInfo","columnOffset","offset","columnWidth","width","valueAxis","getOtherAxis","cx","cy","barMinHeight","barMinAngle","valueDim","mapDimension","baseDim","stacked","isDimensionStacked","clampLayout","valueAxisStart","dataToCoord","idx","len","count","value","baseValue","sign","baseCoord","p","n","r0","r","startAngle","endAngle","radiusSpan","angle","Math","abs","angleSpan","radius","setItemLayout","PI","clockwise","barSeries","columnsMap","each","axisExtent","getExtent","bandWidth","getBandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","barWidth","parsePercent","barMaxWidth","barGap","barCategoryGap","min","result","coordSysName","barGapPercent","autoWidth","max","column","stack","widthSum","lastColumn"],"sources":["C:/Users/Z/Desktop/efficient/node_modules/echarts/lib/layout/barPolar.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(polar, axis) {\n  return axis.dim + polar.model.componentIndex;\n}\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var cx = seriesModel.coordinateSystem.cx;\n    var cy = seriesModel.coordinateSystem.cy;\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /*, baseDim*/\n    );\n    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n    var valueAxisStart = valueAxis.dataToCoord(0);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var r0 = void 0;\n      var r = void 0;\n      var startAngle = void 0;\n      var endAngle = void 0; // radial sector\n\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n        var angle = baseAxis.dataToCoord(baseValue);\n\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      } // tangential sector\n      else {\n          var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n          var radius = baseAxis.dataToCoord(baseValue);\n\n          if (Math.abs(angleSpan) < barMinAngle) {\n            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n          }\n\n          r0 = radius + columnOffset;\n          r = r0 + columnWidth;\n          startAngle = baseCoord;\n          endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,\n          // add a round to differentiate it from origin\n          // let extent = angleAxis.getExtent();\n          // let stackCoord = angle;\n          // if (stackCoord === extent[0] && value > 0) {\n          //     stackCoord = extent[1];\n          // }\n          // else if (stackCoord === extent[1] && value < 0) {\n          //     stackCoord = extent[0];\n          // }\n\n          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n        }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180,\n\n        /**\n         * Keep the same logic with bar in catesion: use end value to\n         * control direction. Notice that if clockwise is true (by\n         * default), the sector will always draw clockwisely, no matter\n         * whether endAngle is greater or less than startAngle.\n         */\n        clockwise: startAngle >= endAngle\n      });\n    }\n  });\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nexport default barLayoutPolar;"],"mappings":"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"},"metadata":{},"sourceType":"script"}